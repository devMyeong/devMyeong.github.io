---
title:  "윤성우 열혈 C++ 프로그래밍"

categories:
  - Cpp Language
tags:
  - []

comments: true

toc: true
toc_sticky: true

date: 2021-07-27
last_modified_at: 2021-08-02
---

## Chapter 01 C언어 기반의 C++ 1

### 01-1 printf와 scanf를 대신하는 입출력 방식
- C++ 에서는 프로그래머가 정의하는 헤더파일의 선언이 아닌, 표준 헤더파일의 선언에서는 확장자를 생략하기로 약속되어 있다
- 확장자를 생략하기로 한 첫 번째 이유는 과거의 표준 라이브러리와 새로운 표준 라이브러리의 구분을 위해서 이다
- 확장자를 생략하기로 한 두 번째 이유는 새로운 표준 라이브러리를 사용하는 형태로 소스코드를 쉽게 변경할 수 있도록 하기 위해서이다
- C++의 지역변수 선언은 함수 내 어디든 삽입이 가능하다

### 01-2 함수 오버로딩
- C언어 에서는 함수 오버로딩이 안되고, C++에서는 가능한 이유는 함수를 호출할 때 함수를 찾는 방법이 다르기 때문이다

### 01-3 매개변수의 디폴트값
- 매개변수의 디폴트값은 선언 부분에만 표현하면 된다 ( 컴파일을 위해 )
- `int YourFunc(int num1=12, int num, int num3) { ... }` 이 함수의 매개변수에 지정되어 있는 디폴트 값 12가 의미를 가지려면, num1이 아닌, num2와 num3에만 인자를 전달할 수 있어야 한다 그런데 그것이 가능한가? 불가능하다! 함수에 전달되는 인자가 왼쪽에서부터 오른쪽으로 채워지기 때문이다

### 01-4 인라인(inline) 함수
- 프로그램 코드라인 안으로 들어가 버린 함수 라는 뜻이다
- 매크로 함수의 단점은 정의하기가 어렵다
- 함수의 몸체부분이 함수호출 문장을 완전히 대체했을 때 <u>함수가 인라인화 되었다</u> 라고 표현한다
- 매크로를 이용한 함수의 인라인화는 전처리기에 의해서 처리되지만, 키워드 inline을 이용한 함수의 인라인화는 컴파일러에 의해서 처리가 된다
- 매크로 함수의 장점은 자료형에 의존적이지 않는 함수가 된다는 점인데, 인라인 함수 또한 함수 오버로딩을 통해서 해당 함수 구현이 가능하나, 그렇게 되면 한번만 정의하면 되는 매크로 함수의 장점과 거리가 멀어진다

### 01-5 이름공간(namespace)에 대한 소개
- 이름공간은 BestCom 회사에서 정의한 함수와 ProgCom 회사에서 정의한 함수의 이름이 같으면 안되기 때문에 생겨난 개념이다
- `::` 를 가리켜 범위지정 연산자 라고 하며, 이름공간을 지정할 때 사용한다

```cpp
namespace BestComImpl
{
	void SimpleFunc(void);
}
namespace BestComImpl
{
	void PrettyFunc(void);
}
void BestComImpl::SimpleFunc(void)
{
	PrettyFunc(); // 동일한 이름 공간
}
```

- 위의 코드 처럼 동일한 이름공간에 정의된 함수를 호출할 때에는 이름공간을 명시할 필요가 없으며 이름공간은 둘 이상의 영역으로 나뉘어서 선언할 수 있다
- C++의 기본문법을 익힐 때에는, 간단한 예제를 직접 작성해보면서 결과를 확인하는 것이 좋다

```cpp
namespace Parent
{
	int num=2;

	namespace SubOne
	{
		int num=3;
	}

	namespace SubTwo
	{
		int num=4;
	}
}
```

- 위의 코드처럼 이름공간은 다른 이름공간 안에 삽입될 수 있다

```cpp
int main(void)
{
	using Hybrid::HybFunc; // 이 선언은 HybFunc를 이름공간 Hybrid에서 찾으라는 일종의 선언이다
	HybFunc();
	return 0;
}
```

- 위의 `using Hybrid::HybFunc` 코드는 지역변수의 선언과 마찬가지로 선언된 이후부터 효력을 발휘하며, 선언된 지역을 벗어나면, 선언의 효력을 잃게 된다 따라서 프로그램 전체영역에 효력을 미치게 하려면 전역변수와 마찬가지로 함수 밖에 선언을 해야 한다
- using 선언을 하는 것이 귀찮다면 `using namespace std;` 와 같이 이름공간 std에 선언된 모든 것에 대해 이름공간 지정을 생략할 수 있다 이렇게 선언을 해버리면, 그만큼 이름충돌이 발생할 확률은 상대적으로 높아진다 따라서 상황을 잘 판단해 사용하자
- `namespace ABC=AAA::BBB::CCC;`와 같이 이름에 별칭을 줄 수 있다

```cpp
int SimpleFunc(void)
{
	int val=20;
	val+=3;
	::val+=7; // 범위 지정 연산자를 이용해 전역변수 val의 값을 증가시키고 있다
}
```

## Chapter 02 C언어 기반의 C++ 2

### 02-1 Chapter 02의 시작에 앞서
- const 키워드의 의미, 실행중인 메모리 공간, Callb-by-value와 Call-by-reference 개념의 차이점을 설명해보자

### 02-2 새로운 자료형 bool
- true와 false가 정의되기 이전에는 참을 표현하기 위해서 숫자 1을, 거짓을 표현하기 위해서 숫자 0을 사용했기 때문에, 이 둘을 출력하거나 정수의 형태로 형 변환하는 경우에 각각 1과 0으로 변환되도록 정의되어 있을 뿐이다

### 02-3 참조자의 이해
- 이미 선언된 변수의 앞에 & 연산자가 오면 주소 값의 반환을 명령하는 뜻이 되지만, 새로 선언되는 변수의 이름 앞에 등장하면, 이는 참조자의 선언을 뜻하는 게 된다
- 여러 개의 참조자를 선언하는 것도 가능하다
- 참조자는 무조건 선언과 동시에 <u>변수</u>를 참조하도록 해야 한다 여기서 말하는 변수의 범위에는 배열요소도 포함된다

```cpp
int num=12;
int *ptr=&num;
int **dptr=&ptr;

int &ref=num;
int *(&pref)=ptr;
int **(&dpref)=dptr;
```

- 위의 코드와 같이 포인터 변수의 참조자 선언도 & 연산자를 하나 더 추가하는 형태로 진행이 된다

### 02-4 참조자(Reference)와 함수

- Call by reference에서 주소 값이 전달 되었다는 사실이 중요한게 아니라, 주소 값이 참조의 도구로 사용되었다는 사실이 중요한 것이다
- `void SwapByRef2(int &ref1, int &ref2)` 에서 매개변수 선언시 초기화가 이뤄지지 않은 것이 아니라, 함수호출 시 전달되는 인자로 초기화를 하겠다는 의미이다
- 즉 Call by reference의 구현 방법에는 참조자를 이용하는 방법과 주소 값을 이용하는 방법, 이렇게 두가지가 상존한다
- 함수 내에서, 참조자를 통한 값의 변경을 진행하지 않을 경우, 참조자를 const로 선언해서, 함수의 원형만 봐도 값의 변경이 이뤄지지 않음을 알 수 있게 하자
- 반환형이 참조형인 경우, 반환 값을 무엇으로 저장하느냐에 따라서 그 결과에 차이가 있으므로, 적절한 선택을 해야한다
- 반환형이 기본자료형으로 선언된 함수의 반환 값은 반드시 변수에 저장해야 한다 반환 값은 상수나 다름없기 때문이다 즉 지역변수를 참조형으로 반환하는 일은 없어야 한다

```cpp
const int num=20;
const int &ref=num; // 상수화된 변수에 대한 참조자 선언은 이와 같이 해야한다
const int &ref=50; // const 참조자는 이와 같이 상수도 참조가 가능하다
```

- const 선언에 의해서 만들어진 변수를 가리켜 상수화된 변수라 한다
- `const int &ref=30;` 만약 이와 같은 선언을 하게되면, C++에서는 const 참조자를 이용해서 상수를 참조할 때 임시변수 라는 것을 만든다 그리고 이 장소에 상수 30을 저장하고선 참조자가 이를 참조하게끔 한다 이 개념 덕분에 `Adder(3, 4)` 와 같은 함수 호출이 가능하다

### 02-5 malloc과 free를 대신하는 new와 delete
- new와 delete를 사용하면 malloc 사용시 불편했던 단점인 할당 대상의 정보를 <u>무조건 바이크 크기단위로 전달해야 한다는 것</u>과 <u>적절한 형변환</u>을 해줘야 한다는점이 커버된다

### 02-6 C++에서 C언어의 표준함수 호출하기
- c를 더하고 .h를 빼라 `ex) #include <stdio.h> -> #include<cstdio>`
- 이름공간 std 내에 선언되어 있다는 사실만 제외하면, C++의 헤더는 C언어의 헤더와 별 차이가 없다

<br>

## Chapter 03 클래스의 기본

### 03-1 C++ 에서의 구조체
- 연관 있는 데이터를 하나로 묶으면, 프로그램의 구현 및 관리가 용이하다
- C++에서는 별도의 typedef 선언 없이도 구조체 변수 선언이 가능하다

```cpp
struct Car
{
	enum
	{
		ID_LEN = 20,
		MAX_SPD = 200,
		FUEL_STEP = 2,
		ACC_STEP = 10,
		BRK_STEP = 10
	};
};
```

- 위와 같이 열거형 enum을 이용해서 구조체 내에서만 유요한 상수를 정의하는게 가능하다

```cpp
namespace CAR_CONST
{
	enum
	{
		ID_LEN = 20,
		MAX_SPD = 200,
		FUEL_STEP = 2,
		ACC_STEP = 10,
		BRK_STEP = 10
	};
};
struct Car
{
	char gamerID[CAR_CONST::ID_LEN];
}
```

- 위와 같이 이름공간을 이용하면, 몇몇 구조체들 사이에서만 사용하는 상수들을 선언할 때 좋다
- 구조체 내에 정의된 함수의 수가 많거나 그 길이가 길다면, 구조체 밖으로 함수를 빼낼수 있다
- 구조체 안에 함수가 정의되어 있으면, 해당 함수를 인라인으로 처리해라 라는 의미를 갖게된다 따라서 함수를 구조체 밖으로 빼내면 이러한 의미가 사라지기 때문에 인라인의 의미를 그대로 유지하려면 inline을 이용해서 인라인 처리를 명시적으로 지시해야 한다

<br>

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}
