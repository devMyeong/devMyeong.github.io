---
title:  "윤성우 열혈 C++ 프로그래밍"

categories:
  - Cpp Language
tags:
  - []

comments: true

toc: true
toc_sticky: true

date: 2021-07-27
last_modified_at: 2021-08-02
---

## Chapter 01 C언어 기반의 C++ 1

### 01-1 printf와 scanf를 대신하는 입출력 방식
- C++ 에서는 프로그래머가 정의하는 헤더파일의 선언이 아닌, 표준 헤더파일의 선언에서는 확장자를 생략하기로 약속되어 있다
- 확장자를 생략하기로 한 첫 번째 이유는 과거의 표준 라이브러리와 새로운 표준 라이브러리의 구분을 위해서 이다
- 확장자를 생략하기로 한 두 번째 이유는 새로운 표준 라이브러리를 사용하는 형태로 소스코드를 쉽게 변경할 수 있도록 하기 위해서이다
- C++의 지역변수 선언은 함수 내 어디든 삽입이 가능하다

### 01-2 함수 오버로딩
- C언어 에서는 함수 오버로딩이 안되고, C++에서는 가능한 이유는 함수를 호출할 때 함수를 찾는 방법이 다르기 때문이다

### 01-3 매개변수의 디폴트값
- 매개변수의 디폴트값은 선언 부분에만 표현하면 된다 ( 컴파일을 위해 )
- `int YourFunc(int num1=12, int num, int num3) { ... }` 이 함수의 매개변수에 지정되어 있는 디폴트 값 12가 의미를 가지려면, num1이 아닌, num2와 num3에만 인자를 전달할 수 있어야 한다 그런데 그것이 가능한가? 불가능하다! 함수에 전달되는 인자가 왼쪽에서부터 오른쪽으로 채워지기 때문이다

### 01-4 인라인(inline) 함수
- 프로그램 코드라인 안으로 들어가 버린 함수 라는 뜻이다
- 매크로 함수의 단점은 정의하기가 어렵다
- 함수의 몸체부분이 함수호출 문장을 완전히 대체했을 때 <u>함수가 인라인화 되었다</u> 라고 표현한다
- 매크로를 이용한 함수의 인라인화는 전처리기에 의해서 처리되지만, 키워드 inline을 이용한 함수의 인라인화는 컴파일러에 의해서 처리가 된다
- 매크로 함수의 장점은 자료형에 의존적이지 않는 함수가 된다는 점인데, 인라인 함수 또한 함수 오버로딩을 통해서 해당 함수 구현이 가능하나, 그렇게 되면 한번만 정의하면 되는 매크로 함수의 장점과 거리가 멀어진다

### 01-5 이름공간(namespace)에 대한 소개
- 이름공간은 BestCom 회사에서 정의한 함수와 ProgCom 회사에서 정의한 함수의 이름이 같으면 안되기 때문에 생겨난 개념이다
- `::` 를 가리켜 범위지정 연산자 라고 하며, 이름공간을 지정할 때 사용한다

```cpp
namespace BestComImpl
{
	void SimpleFunc(void);
}
namespace BestComImpl
{
	void PrettyFunc(void);
}
void BestComImpl::SimpleFunc(void)
{
	PrettyFunc(); // 동일한 이름 공간
}
```

- 위의 코드 처럼 동일한 이름공간에 정의된 함수를 호출할 때에는 이름공간을 명시할 필요가 없으며 이름공간은 둘 이상의 영역으로 나뉘어서 선언할 수 있다
- C++의 기본문법을 익힐 때에는, 간단한 예제를 직접 작성해보면서 결과를 확인하는 것이 좋다

```cpp
namespace Parent
{
	int num=2;

	namespace SubOne
	{
		int num=3;
	}

	namespace SubTwo
	{
		int num=4;
	}
}
```

- 위의 코드처럼 이름공간은 다른 이름공간 안에 삽입될 수 있다

```cpp
int main(void)
{
	using Hybrid::HybFunc; // 이 선언은 HybFunc를 이름공간 Hybrid에서 찾으라는 일종의 선언이다
	HybFunc();
	return 0;
}
```

- 위의 `using Hybrid::HybFunc` 코드는 지역변수의 선언과 마찬가지로 선언된 이후부터 효력을 발휘하며, 선언된 지역을 벗어나면, 선언의 효력을 잃게 된다 따라서 프로그램 전체영역에 효력을 미치게 하려면 전역변수와 마찬가지로 함수 밖에 선언을 해야 한다
- using 선언을 하는 것이 귀찮다면 `using namespace std;` 와 같이 이름공간 std에 선언된 모든 것에 대해 이름공간 지정을 생략할 수 있다 이렇게 선언을 해버리면, 그만큼 이름충돌이 발생할 확률은 상대적으로 높아진다 따라서 상황을 잘 판단해 사용하자
- `namespace ABC=AAA::BBB::CCC;`와 같이 이름에 별칭을 줄 수 있다

```cpp
int SimpleFunc(void)
{
	int val=20;
	val+=3;
	::val+=7; // 범위 지정 연산자를 이용해 전역변수 val의 값을 증가시키고 있다
}
```

## Chapter 02 C언어 기반의 C++ 2

### 02-1 Chapter 02의 시작에 앞서
- const 키워드의 의미, 실행중인 메모리 공간, Callb-by-value와 Call-by-reference 개념의 차이점을 설명해보자

### 02-2 새로운 자료형 bool
- true와 false가 정의되기 이전에는 참을 표현하기 위해서 숫자 1을, 거짓을 표현하기 위해서 숫자 0을 사용했기 때문에, 이 둘을 출력하거나 정수의 형태로 형 변환하는 경우에 각각 1과 0으로 변환되도록 정의되어 있을 뿐이다

### 02-3 참조자의 이해
- 이미 선언된 변수의 앞에 & 연산자가 오면 주소 값의 반환을 명령하는 뜻이 되지만, 새로 선언되는 변수의 이름 앞에 등장하면, 이는 참조자의 선언을 뜻하는 게 된다
- 여러 개의 참조자를 선언하는 것도 가능하다
- 참조자는 무조건 선언과 동시에 <u>변수</u>를 참조하도록 해야 한다 여기서 말하는 변수의 범위에는 배열요소도 포함된다

```cpp
int num=12;
int *ptr=&num;
int **dptr=&ptr;

int &ref=num;
int *(&pref)=ptr;
int **(&dpref)=dptr;
```

- 위의 코드와 같이 포인터 변수의 참조자 선언도 & 연산자를 하나 더 추가하는 형태로 진행이 된다

### 02-4 참조자(Reference)와 함수

- Call by reference에서 주소 값이 전달 되었다는 사실이 중요한게 아니라, 주소 값이 참조의 도구로 사용되었다는 사실이 중요한 것이다
- `void SwapByRef2(int &ref1, int &ref2)` 에서 매개변수 선언시 초기화가 이뤄지지 않은 것이 아니라, 함수호출 시 전달되는 인자로 초기화를 하겠다는 의미이다
- 즉 Call by reference의 구현 방법에는 참조자를 이용하는 방법과 주소 값을 이용하는 방법, 이렇게 두가지가 상존한다
- 함수 내에서, 참조자를 통한 값의 변경을 진행하지 않을 경우, 참조자를 const로 선언해서, 함수의 원형만 봐도 값의 변경이 이뤄지지 않음을 알 수 있게 하자
- 반환형이 참조형인 경우, 반환 값을 무엇으로 저장하느냐에 따라서 그 결과에 차이가 있으므로, 적절한 선택을 해야한다
- 반환형이 기본자료형으로 선언된 함수의 반환 값은 반드시 변수에 저장해야 한다 반환 값은 상수나 다름없기 때문이다 즉 지역변수를 참조형으로 반환하는 일은 없어야 한다

```cpp
const int num=20;
const int &ref=num; // 상수화된 변수에 대한 참조자 선언은 이와 같이 해야한다
const int &ref=50; // const 참조자는 이와 같이 상수도 참조가 가능하다
```

- const 선언에 의해서 만들어진 변수를 가리켜 상수화된 변수라 한다
- `const int &ref=30;` 만약 이와 같은 선언을 하게되면, C++에서는 const 참조자를 이용해서 상수를 참조할 때 임시변수 라는 것을 만든다 그리고 이 장소에 상수 30을 저장하고선 참조자가 이를 참조하게끔 한다 이 개념 덕분에 `Adder(3, 4)` 와 같은 함수 호출이 가능하다

### 02-5 malloc과 free를 대신하는 new와 delete
- new와 delete를 사용하면 malloc 사용시 불편했던 단점인 할당 대상의 정보를 <u>무조건 바이크 크기단위로 전달해야 한다는 것</u>과 <u>적절한 형변환</u>을 해줘야 한다는점이 커버된다

### 02-6 C++에서 C언어의 표준함수 호출하기
- c를 더하고 .h를 빼라 `ex) #include <stdio.h> -> #include<cstdio>`
- 이름공간 std 내에 선언되어 있다는 사실만 제외하면, C++의 헤더는 C언어의 헤더와 별 차이가 없다

<br>

## Chapter 03 클래스의 기본

### 03-1 C++ 에서의 구조체
- 연관 있는 데이터를 하나로 묶으면, 프로그램의 구현 및 관리가 용이하다
- C++에서는 별도의 typedef 선언 없이도 구조체 변수 선언이 가능하다

```cpp
struct Car
{
	enum
	{
		ID_LEN = 20,
		MAX_SPD = 200,
		FUEL_STEP = 2,
		ACC_STEP = 10,
		BRK_STEP = 10
	};
};
```

- 위와 같이 열거형 enum을 이용해서 구조체 내에서만 유효한 상수를 정의하는게 가능하다

```cpp
namespace CAR_CONST
{
	enum
	{
		ID_LEN = 20,
		MAX_SPD = 200,
		FUEL_STEP = 2,
		ACC_STEP = 10,
		BRK_STEP = 10
	};
};
struct Car
{
	char gamerID[CAR_CONST::ID_LEN];
}
```

- 위와 같이 이름공간을 이용하면, 몇몇 구조체들 사이에서만 사용하는 상수들을 선언할 때 좋다
- 구조체 내에 정의된 함수의 수가 많거나 그 길이가 길다면, 구조체 밖으로 함수를 빼낼수 있다
- 구조체 안에 함수가 정의되어 있으면, 해당 함수를 인라인으로 처리해라 라는 의미를 갖게된다 따라서 함수를 구조체 밖으로 빼내면 이러한 의미가 사라지기 때문에 인라인의 의미를 그대로 유지하려면 inline을 이용해서 인라인 처리를 명시적으로 지시해야 한다

### 03-2 클래스(Class)와 객체(Object)
- 접근제어 지시자의 뒤에는 세미콜론이 아닌 콜론이 붙는데, 이는 접근제어 지시자가 특정 위치 정보를 알리는 레이블(라벨)이기 때문이다
- 구조체와 클래스는 변수의 성격만 지니는것이 아니기 때문에 변수라는 표현을 대신해서 객체 라는 표현을 사용한다
- 클래스를 구성하는 변수를 가리켜 멤버변수라 하고 클래스를 구성하는 함수를 가리켜 멤버함수라 한다
- 멤버함수의 정의부분을 컴파일 하는데도 클래스의 선언 정보가 필요하다 멤버함수에서 접근하는 변수의 존재유무를 확인해야 하기 때문이다
- 컴파일러는 파일 단위로 컴파일을 한다 따라서 인라인 함수는 <u>클래스의 선언과 동일한 파일에 저장</u>되어서 컴파일러가 동시에 참조할 수 있게 해야 한다

### 03-3 객체지향 프로그래밍의 이해
- 객체지향 프로그래밍은 현실에 존재하는 사물과 대상, 그리고 그에 따른 행동을 있는 그대로 실체화 시키는 형태의 프로그래밍이다
- 객체는 하나 이상의 상태 정보(데이터)와 하나 이상의 행동(기능)으로 구성된다
- 하나의 객체가 다른 하나의 객체에게 메시지를 전달하는 방법은 함수호출을 기반으로 한다 또한 이러한 형태의 함수호출을 가리켜 메시지 전달 이라고 한다

<br>

## Chapter 04 클래스의 완성

### 04-1 정보은닉
- 클래스의 멤버변수가 public으로 선언되면 해당 클래스의 변수를 구조체 변수를 초기화하듯이 초기화가 가능하다
- 프로그래밍 덕목중 하나는 제한된 방법으로의 접근만 허용을 해서 잘못된 값이 저장되지 않도록 도와야 하고, 또 실수를 했을 때, 실수가 쉽게 발견되도록 해야 한다
- 멤버변수를 private으로 선언하고, 해당 변수에 접근하는 함수를 별도로 정의해서, 안전한 형태로 멤버변수의 접근을 유도하는 것이 바로 정보은닉이며, 이는 좋은 클래스가 되기 위한 기본조건이다
- Get(), Set() 함수들을 가리켜 엑세스 함수라고 한다
- `int GetX() const;`  이 함수는 const 함수 이며 함수 내에서는 멤버변수에 저장된 값을 변경하지 못한다 또한 const 함수 내에서는 const가 아닌 함수의 호출이 제한된다
- const 참조자를 이용해서는 const 함수만 호출이 가능하다

### 04-2 캡슐화
- 캡슐화는 어려운 개념이다 왜냐하면 캡슐화의 범위를 결정하는 일이 쉽지 않기 때문이다
- 캡슐화는 기본적으로 정보은닉을 포함하는 개념이라고 이야기 한다

### 04-3 생성자(Constructor)와 소멸자(Destructor)
- 생성자를 이용해서 객체를 생성하기 위해 다음과 같이 문장을 구성하면 안 된다 `SimpleClass sc1();` 대신 다음과 같이 구성을 해야한다 `SimpleClass sc1` 왜냐하면 컴파일러는 첫번째 예시와 같은 문장을 만나면 이것이 객체 생성문인지 함수의 원형선언 인지를 구분할 수 없게 되기 때문이다
- Rectangle 객체를 생성하는 과정에서 Point 클래스의 생성자를 통해서 Point 객체를 초기화할 수 없을까? 이니셜라이저를 사용하면 가능하다

```cpp
Rectangle::Rectangle(const int &x1, const int &y1, const int &x2, const int &y2)
	: upLeft(x1,y1), lowRight(x2, y2) // 이니셜라이저를 이용해 Point 객체를 초기화 해주고 있다
{
	// empty
}
```

- 객체의 생성과정은 1단계 : 메모리 공간의 할당 -> 2단계(필수아님) : 이니셜라이저를 이용한 멤버변수(객체)의 초기화 -> 3단계 : 생성자의 몸체부분 실행
- 이니셜라이저를 이용하면 선언과 동시에 초기화가 이뤄지는 형태로 바이너리 코드가 생성된다 즉 const 멤버변수를 이니셜라이저를 이용해 초기화 할 수 있다
- const 변수와 const 상수는 같은 의미로 사용된다
- 이니셜라이저를 이용하면 참조자도 멤버변수로 선언될 수 있다
- 객체가 되기 위해서는 반드시 하나의 생성자가 호출되어야 한다
- `AAA * ptr = (AAA*)malloc(sizeof(AAA));` 에서 malloc 함수호출 시 실제로는 AAA 클래스의 크기정보만 바이트 단위로 전달되기 때문에 생성자가 호출되지 않는다
- private 생성자는 객체의 생성방법을 제한하고자 하는 경우에 매우 유용하게 사용이 된다
- 소멸자의 매개변수는 void형으로 선언되어야 하기 때문에 오버로딩도, 디폴트 값 설정도 불가능하다

### 04-4 클래스와 배열 그리고 this 포인터
- 객체가 배열을 통해 선언 되더라도 생성자는 호출된다 단 호출할 생성자를 별도로 명시하지 못한다(생성자에 인자를 전달하지 못한다)
- 저장의 대상을 객체로 하느냐, 객체의 주소 값으로 하느냐를 결정해야 하기 때문에 객체 배열과 객체 포인터 배열의 차이점을 정확히 이해해야 한다
- this는 객체자신의 주소 값을 의미한다는 사실을 인지하자 이렇듯 this 포인터는 그 주소 값과 자료형이 정해져 있지 않은 포인터이다
- 객체의 포인터를 가지고는 지역변수에 접근이 불가능하다
- `SelfRef& Adder(int a)` 는 객체 자신의 포인터가 아닌 객체 자신이 반환된다
- 대입 연산자의 왼편에 참조자의 선언이 오거나 반환형으로 참조형이 선언되면, 그 때 전달되는 정보를 표현하기 위해서 참조의 정보 또는 참조 값 이라는 표현을 사용한다

<br>

## Chapter 05 복사 생성자(Copy Constructor)

### 05-1 복사 생성자와의 만남
- `SoSimple sim2 = sim1;` 이 문장은 `SoSimple sim2(sim1);` 과 같은 형태로 묵시적 변환이 일어나는데 이러한 묵시적 변환을 막을수 있는 키워드가 explicit 이다
- 묵시적 변환이 많이 발생하는 코드일수록 코드의 결과를 예측하기가 어려워지기 때문에 explicit 키워드를 적극 활용하자
- 복사생성자의 매개변수가 참조형이 아닐경우 무한루프에 빠진다

### 05-2 깊은 복사와 얕은 복사
- 디폴트 복사 생성자는 멤버 대 멤버의 복사를 진행한다 그리고 이러한 방식의 복사를 가리켜 얕은 복사 라고 한다

### 05-3 복사 생성자의 호출시점
- 복사 생성자가 호출 되는 시점은 크게 세가지로 구분된다 첫째 새로운 객체를 초기화 하는 경우, 둘째 객체를 인자로 전달하는 경우, 셋째 객체를 반환하되 참조형으로 반환하지 않는 경우
- 함수가 값을 반환하면 별도의 메모리 공간이 할당되고 이 공간에 반환 값이 저장된다
- 임시객체는 다음 행으로 넘어가면 바로 소멸되어 버린다
- 참조자에 참조되는 임시객체는 바로 소멸되지 않는다

<br>

## Chapter 06 friend와 static 그리고 const

### 06-1 const와 관련해서 아직 못다한 이야기
- `const SoSimple sim(20);` 이 코드의 의미는 이 객체의 변경을 허용하지 않겠다
- const 선언유무도 함수 오버로딩의 조건에 해당이 된다
- 일반 객체를 대상으로 SimpleFunc 함수를 호출하면 일반 멤버함수가, const 객체를 대상으로 SimpleFunc 함수를 호출하면 const 멤버함수가 호출된다

### 06-2 클래스와 함수에 대한 friend 선언
- friend 선언은 클래스 내에 어디든 위치할 수 있다 private 영역에 존재하든, public 영역에 존재하든 상관없다
- `friend class Girl;` 이 코드는 두 가지를 동시에 선언하는 셈이다 첫째 Girl은 클래스의 이름이다(전방선언) 둘째 Girl클래스를 friend로 선언한다
- friend 선언은 필요한 상황에서 극히 소극적으로 사용해야 한다
- 전역함수를 대상으로도, 클래스의 멤버함수를 대상으로도 friend 선언이 가능하다
- friend 선언을 위해서 별도의 함수원형을 선언할 필요는 없다

### 06-3 C++에서의 static
- 전역변수에 선언된 static의 의미는 선언된 파일 내에서만 참조를 허용하겠다는 의미
- `int SoSimple::simobjCnt = 0;` 이 코드와 같이 static 변수의 초기화는 생성자가 아닌, 클래스 외부에서 해야한다
- simObjCnt에 접근을 허용하는 객체와 cmxObjCnt에 접근을 허용하는 객체가 구분되기 때문에 각각의 변수에 다른 영역에서 잘못 접근하는 일이 발생하지 않는다
- static 멤버가 private으로 선언되면, 해당 클래스의 객체들만 접근이 가능하지만, public으로 선언되면, 클래스의 이름 또는 객체의 이름을 통해서 어디서든 접근이 가능하다
- public static 멤버에 접근할 때에는 클래스의 이름을 이용해서 접근하는 것이 좋다
- static 멤버함수가 멤버변수에 접근하면 안되는 이유 첫번째는 객체의 멤버가 아닌데, 어떻게 멤버변수에 접근을 하겠는가? 두번째는 객체생성 이전에도 호출이 가능하다 그런데 어떻게 멤버변수에 접근이 가능하겠는가? 세번째는 멤버변수에 접근을 한다고 치자 그렇다면 어떤 객체의 멤버변수에 접근을 해야겠는가?
- static 멤버함수 내에서는 static 멤버변수와 static 멤버함수만 호출이 가능하다
- `const static int RUSSIA = 1707540;` 이 코드와 같이 const static으로 선언되는 멤버변수는 선언과 동시에 초기화가 가능하다 ( 원래 const 멤버변수의 초기화는 이니셜라이저를 통해야만 가능하다 )
- mutable 키워드는 const 함수 내에서의 값의 변경을 예외적으로 허용한다

<br>

## Chapter 07 상속(Inheritance)의 이해

### 07-1 상속에 들어가기에 앞서
- 기능의 처리를 실제로 담당하는 클래스를 가리켜 컨트롤 클래스 또는 핸들러 클래스라 한다
- 프로그램 사용자의 요구에 다음과 같이 이야기 하는 일은 없어야 한다, 그 기능을 변경하려면 프로그램을 거의 처음부터 다시 만들다시피 해야 하는데요

### 07-2 상속의 문법적인 이해

```cpp
UnivStudent(char* myname, int myage, char * mymajor)
	: Person(myage, myname)
{
	strcpy(major, mymajor);
}
```

- 위의 코드 처럼 UnivStudent 클래스와 같이 상속받는 클래스는 이니셜라이저를 이용해서 상속하는 클래스의 생성자 호출을 명시할 수 있다
- 부모 멤버 변수가 private이면 자식 클래스에 해당 멤버변수가 상속이 되긴 하지만 직접 접근이 불가능하다 이렇듯 정보의 은닉은 하나의 객체 내에서도 진행이 된다
- 유도 클래스의 생성자에서 기초 클래스의 생성자 호출을 명시하지 않으면, 기초 클래스의 void 생성자가 호출된다 즉 <u>유도 클래스의 객체생성 과정에서 기초클래스의 생성자 호출, 유도 클래스의 생성자 호출 이렇게 생성자가 총 두 번 호출</u>된다
- 클래스의 멤버는 해당 클래스의 생성자를 통해서 초기화해야 한다 라는 사실을 명심하자
- 생성자에서 동적 할당한 메모리 공간은 소멸자에서 해제해야 한다 라는 사실을 명심하자 더불어 부모 생성자에서 할당한 메모리 공간은 부모 소멸자에서 해제하고 자식 생성자에서 할당한 메모리 공간은 자식 소멸자에서 해제하자

### 07-3 protected 선언과 세 가지 형태의 상속
- protected 선언은 private와 public에 비해 그리 많이 사용되지 않는데 그이유는 기초 클래스와 이를 상속하는 유도 클래스 사이에서도 정보은닉은 지켜지는 게 좋기 때문이다
- 상속의 대부분은 public 상속이다

### 07-4 상속을 위한 조건
- 상속관계가 성립하려면 기초 클래스와 유도 클래스간에 IS-A 관계가 성립해야 한다

```cpp
Police(int bnum, int bcuff)
	: handcuffs(bcuff)
{
	if(bnum>0)	// 첫 번째 인자로 0이 전달되면, pistol 멤버변수는 NULL로 초기화되어, 총의 사용이 불가능해진다
		pistol = new Gun(bnum);
		..
}
```

- 위의 코드는 pistol을 NULL로 초기화함으로써 권총을 소유하지 않은 경찰을 매우 간단히 표현했다
- 대부분의 경우에 있어 IS-A와 HAS-A 이외의 관계를 상속으로 표현하지 않는다

<br>

## Chapter 08 상속과 다형성

### 08-1 객체 포인터의 참조관계
- `PermanentWorker::GetPay()` 이는 오버라이딩 된 기초 클래스의 GetPay 함수를 호출하는 구문이다 이렇듯, 클래스의 이름을 명시함으로 인해서 기초 클래스의 오버라이딩 된 함수를 호출할 수 있다
- 기초 클래스와 동일한 이름의 함수를 유도 클래스에서 정의한다고 해서 무조건 함수 오버라이딩이 되는 것은 아니다 매개변수의 자료형 및 개수가 다르면, 이는 함수 오버로딩이 되어, 전달되는 인자에 따라서 호출되는 함수가 결정된다 즉 <u>함수 오버로딩은 상속의 관계에서도 구성이 될 수 있다</u>

### 08-2 가상함수(Virtual Function)
- C++ 컴파일러는 포인터 연산의 가능성 여부를 판단할 때, 포인터의 자료형을 기준으로 판단하지, 실제 가리키는 객체의 자료형을 기준으로 판단하지 않는다
- 가상함수의 선언은 virtual 키워드의 선언을 통해서 이뤄진다 그리고 이렇게 가상함수가 선언되고 나면, 이 함수를 오버라이딩 하는 함수도 가상함수가 된다
- 함수가 가상함수로 선언되면, 해당 함수호출 시, 포인터의 자료형을 기반으로 호출대상을 결정하지 않고, 포인터 변수가 실제로 가리키는 객체를 참조하여 호출의 대상을 결정한다
- 적용하고픈 공통규약을 모아서 부모클래스에 정의하자
- 클래스 중에서는 객체생성을 목적으로 정의되지 않는 클래스도 존재한다 이를위해 가상함수를 순수 가상함수로 선언하여 객체의 생성을 문법적으로 막는것이 좋다
- 순수 가상함수란 함수의 몸체가 정의되지 않은 함수
- 순수 가상함수의 이점 두가지는 첫째 잘못된 객체의 생성을 막을수 있다는 점 둘째 실제로 실행이 되는 함수가 아닌 함수를 보다 명확히 명시하는 효과이다
- 하나 이상의 멤버함수를 순수 가상함수로 선언한 클래스를 가리켜 추상 클래스 라고 한다
- 다형성을 한마디로 정의하면 문장은 같은데 결과는 다르다

<br>

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}
