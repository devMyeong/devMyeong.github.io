---
title:  "삼성 SW 역량 테스트 기출 문제 + 삼성 A형 기출 문제"

categories:
  - Algorithm
tags:
  - []

comments: true

toc: true
toc_sticky: true

date: 2023-05-01
last_modified_at: 2023-05-01
---

## Chapter 01 시뮬레이션

### 01-1 뱀 ( 3190 )
- 첫째 줄에 게임이 몇 초에 끝나는지 출력한다

```cpp
#include <iostream>
#include <algorithm>
#include <deque>
#include <vector>
using namespace std;

int board_size; // 게임판의 크기
int num_of_apple; // 먹이의 개수
int num_of_order; // 뱀의 이동 방향 변경 횟수

deque<pair<int, int>> snake_body; // 뱀의 몸통 좌표
vector<int> order_time; // 뱀의 이동 방향 변경 시간
vector<char> order_direction; // 뱀의 이동 방향 변경 방향

int game_board[100][100]; // 게임판 상태
int dx[] = { 1, 0, -1, 0 }; // x좌표 이동 방향
int dy[] = { 0, 1, 0, -1 }; // y좌표 이동 방향

// 뱀 게임 실행 함수
int run_game(int start_x, int start_y)
{
	int direction = 0; // 초기 방향은 오른쪽
	int cnt = 0; // 게임 진행 시간
	int x, y; // 뱀 머리 좌표
	int order_idx = 0; // 뱀의 이동 방향 변경 명령 인덱스

	snake_body.push_front(make_pair(start_x, start_y)); // 뱀 머리 좌표 큐에 추가

	while (1)
	{
		x = snake_body.front().first;
		y = snake_body.front().second;
		game_board[y][x] = 2; // 뱀이 있는 위치 표시
		cnt++;

		int next_x = x + dx[direction];
		int next_y = y + dy[direction];

		// 게임 종료 조건
		if (next_x < 0 || next_y < 0 || board_size <= next_x || board_size <= next_y || game_board[next_y][next_x] == 2)
		{
			return cnt;
		}
		else
		{
			snake_body.push_front(make_pair(next_x, next_y)); // 뱀 머리를 다음 위치로 이동

			// 먹이를 먹지 않은 경우
			if (game_board[next_y][next_x] != 1)
			{
				int tail_x = snake_body.back().first;
				int tail_y = snake_body.back().second;
				game_board[tail_y][tail_x] = 0; // 꼬리 제거
				snake_body.pop_back(); // 뱀 꼬리 제거
			}

			// 뱀의 이동 방향 변경
			if (cnt == order_time[order_idx])
			{
				if (order_direction[order_idx] == 'L')
				{ // 왼쪽으로 회전
					direction += 3;
					direction %= 4;
				}
				else
				{ // 오른쪽으로 회전
					direction += 1;
					direction %= 4;
				}

				if (order_idx < order_time.size() - 1)
				{
					order_idx++;
				}
			}
		}
	}
}
int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(0);

	cin >> board_size;

	// 사과
	cin >> num_of_apple;
	for (int i = 0; i < num_of_apple; i++)
	{
		int applex, appley;
		cin >> applex >> appley;
		game_board[applex - 1][appley - 1] = 1;
	}

	// 명령
	cin >> num_of_order;
	for (int i = 0; i < num_of_order; i++)
	{
		int t;
		char d;
		cin >> t >> d;
		order_time.push_back(t);
		order_direction.push_back(d);
	}

	cout << run_game(0, 0);
	return 0;
}
```

<br>

## Chapter 02 그래프

### 02-1 문제
- 설명

```cpp
```

<br>

## Chapter 03 DFS

### 03-1 문제
- 설명

```cpp
```

<br>

## Chapter 04 백트래킹

### 04-1 문제
- 설명

```cpp
```

<br>

## Chapter 05 BFS

### 05-1 문제
- 설명

```cpp
```

<br>

## Chapter 06 완전탐색

### 06-1 문제
- 설명

```cpp
```

<br>

## Chapter 07 DP

### 07-1 문제
- 설명

```cpp
```

<br>

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}
