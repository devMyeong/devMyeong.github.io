---
title:  "삼성 SW 역량 테스트 기출 문제 + 삼성 A형 기출 문제"

categories:
  - Algorithm
tags:
  - []

comments: true

toc: true
toc_sticky: true

date: 2023-05-01
last_modified_at: 2023-05-01
---

## Chapter 01 시뮬레이션

### 01-1 뱀 ( 3190 )
- 첫째 줄에 게임이 몇 초에 끝나는지 출력한다

```cpp
#include <iostream>
#include <algorithm>
#include <deque>
#include <vector>
using namespace std;

int board_size; // 게임판의 크기
int num_of_apple; // 먹이의 개수
int num_of_order; // 뱀의 이동 방향 변경 횟수

deque<pair<int, int>> snake_body; // 뱀의 몸통 좌표
vector<int> order_time; // 뱀의 이동 방향 변경 시간
vector<char> order_direction; // 뱀의 이동 방향 변경 방향

int game_board[100][100]; // 게임판 상태
int dx[] = { 1, 0, -1, 0 }; // x좌표 이동 방향
int dy[] = { 0, 1, 0, -1 }; // y좌표 이동 방향

// 뱀 게임 실행 함수
int run_game(int start_x, int start_y)
{
	int direction = 0; // 초기 방향은 오른쪽
	int cnt = 0; // 게임 진행 시간
	int x, y; // 뱀 머리 좌표
	int order_idx = 0; // 뱀의 이동 방향 변경 명령 인덱스

	snake_body.push_front(make_pair(start_x, start_y)); // 뱀 머리 좌표 큐에 추가

	while (1)
	{
		x = snake_body.front().first;
		y = snake_body.front().second;
		game_board[y][x] = 2; // 뱀이 있는 위치 표시

		cnt++;

		int next_x = x + dx[direction];
		int next_y = y + dy[direction];

		// 게임 종료 조건
		if (next_x < 0 || next_y < 0 || board_size <= next_x || board_size <= next_y || game_board[next_y][next_x] == 2)
			return cnt;

		snake_body.push_front(make_pair(next_x, next_y)); // 뱀 머리를 다음 위치로 이동

		// 먹이를 먹지 않은 경우
		if (game_board[next_y][next_x] != 1)
		{
			int tail_x = snake_body.back().first;
			int tail_y = snake_body.back().second;
			game_board[tail_y][tail_x] = 0; // 꼬리 제거
			snake_body.pop_back(); // 뱀 꼬리 제거
		}

		// 뱀의 이동 방향 변경
		if (cnt == order_time[order_idx])
		{
			if (order_direction[order_idx] == 'L')
			{ // 왼쪽으로 회전
				direction += 3;
				direction %= 4;
			}
			else
			{ // 오른쪽으로 회전
				direction += 1;
				direction %= 4;
			}

			if (order_idx < order_time.size() - 1)
			{
				order_idx++;
			}
		}
	}
}
int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(0);

	cin >> board_size;

	// 사과
	cin >> num_of_apple;
	for (int i = 0; i < num_of_apple; i++)
	{
		int applex, appley;
		cin >> applex >> appley;
		game_board[applex - 1][appley - 1] = 1;
	}

	// 명령
	cin >> num_of_order;
	for (int i = 0; i < num_of_order; i++)
	{
		int t;
		char d;
		cin >> t >> d;
		order_time.push_back(t);
		order_direction.push_back(d);
	}

	cout << run_game(0, 0);
	return 0;
}
```

### 01-2 주사위 굴리기 ( 14499 )
- 이동할 때마다 주사위의 윗 면에 쓰여 있는 수를 출력한다 만약 바깥으로 이동시키려고 하는 경우에는 해당 명령을 무시해야 하며, 출력도 하면 안 된다

```cpp
https://excited-hyun.tistory.com/215 참고

#include<bits/stdc++.h>
using namespace std;

int mymap[20][20];
int X[5] = { 0, 1, -1, 0, 0 };
int Y[5] = { 0, 0, 0, -1, 1 };
vector<int> dice(6, 0);

int main()
{
	int n, m, x, y, k;

	scanf("%d %d %d %d %d", &n, &m, &y, &x, &k);
	for (int i = 0; i < n; ++i)
	{
		for (int j = 0; j < m; ++j)
			scanf("%d", &mymap[i][j]);
	}

	int move;
	for (int i = 0; i < k; ++i)
	{
		scanf("%d", &move);
		int newX = x + X[move];
		int newY = y + Y[move];

		if (newX < 0 || m <= newX || newY < 0 || n <= newY)
			continue;

		if (move == 1)
			dice = { dice[3], dice[1], dice[0], dice[5], dice[4], dice[2] };
		else if (move == 2)
			dice = { dice[2], dice[1], dice[5], dice[0], dice[4], dice[3] };
		else if (move == 3)
			dice = { dice[4], dice[0], dice[2], dice[3], dice[5], dice[1] };
		else if (move == 4)
			dice = { dice[1], dice[5], dice[2], dice[3], dice[0], dice[4] };

		if (mymap[newY][newX] == 0)
			mymap[newY][newX] = dice[5];
		else
		{
			dice[5] = mymap[newY][newX];
			mymap[newY][newX] = 0;
		}

		cout << dice[0] << endl;

		x = newX;
		y = newY;
	}

	return 0;
}
```

### 01-3 문제
- 설명

```cpp
```

<br>

## Chapter 02 그래프

### 02-1 문제
- 설명

```cpp
```

<br>

## Chapter 03 DFS

### 03-1 문제
- 설명

```cpp
```

<br>

## Chapter 04 백트래킹

### 04-1 문제
- 설명

```cpp
```

<br>

## Chapter 05 BFS

### 05-1 연구소 
- 첫째 줄에 얻을 수 있는 안전 영역의 최대 크기를 출력한다

```cpp
#include<bits/stdc++.h>
using namespace std;

int answer = 0;

int dx[4] = { 1, -1, 0, 0 };
int dy[4] = { 0, 0, 1, -1 };

// 여기서는 참조자를 사용해도 된다
void BFS(vector<vector<int>>& mymap)
{
	queue<pair<int, int>> que;

	// 바이러스 최초 위치들을 모두 큐에 담는다
	for (int y = 0; y < mymap.size(); y++)
	{
		for (int x = 0; x < mymap[0].size(); x++)
		{
			if (mymap[y][x] == 2)
				que.push({ x, y });
		}
	}

	// 바이러스를 최대한 퍼뜨린다
	while (!que.empty())
	{
		int x = que.front().first;
		int y = que.front().second;
		que.pop();

		for (int i = 0; i < 4; i++)
		{
			int nx = x + dx[i];
			int ny = y + dy[i];

			if (nx < 0 || ny < 0 || mymap[0].size() <= nx || mymap.size() <= ny || mymap[ny][nx] != 0)
				continue;

			mymap[ny][nx] = 2;
			que.push({ nx, ny });
		}
	}

	// 바이러스가 모두 퍼진 상태에서 안전 영역 크기를 계산한다
	int cnt = 0;
	for (int y = 0; y < mymap.size(); y++)
	{
		for (int x = 0; x < mymap[0].size(); x++)
		{
			if (mymap[y][x] == 0)
				cnt++;
		}
	}

	answer = max(answer, cnt);
}

// 여기서는 참조자를 사용하면 안된다
void DFS(vector<vector<int>> mymap, int x, int y, int cnt)
{
	mymap[y][x] = 1;
	cnt = cnt - 1;

	// 벽을 더이상 세울수 없다면 바이러스를 퍼뜨린다
	if (cnt == 0)
	{
		BFS(mymap);

		return;
	}

	// 벽 2개를 세울수 있는 모든 경우의 수를 체크한다
	for (int y = 0; y < mymap.size(); y++)
	{
		for (int x = 0; x < mymap[0].size(); x++)
		{
			if (mymap[y][x] == 0)
				DFS(mymap, x, y, cnt);
		}
	}
}

int main()
{
	int N, M;
	cin >> N >> M;

	vector<vector<int>> mymap(N, vector<int>(M, 0));

	for (int y = 0; y < N; y++)
	{
		for (int x = 0; x < M; x++)
			cin >> mymap[y][x];
	}

	// 벽 3개를 세울수 있는 모든 경우의 수를 체크한다
	for (int y = 0; y < N; y++)
	{
		for (int x = 0; x < M; x++)
		{
			if (mymap[y][x] == 0)
				DFS(mymap, x, y, 3);
		}
	}

	cout << answer << endl;

	return 0;
}
```

<br>

## Chapter 06 완전탐색

### 06-1 테트로미노 ( 14500 )
- 첫째 줄에 테트로미노가 놓인 칸에 쓰인 수들의 합의 최댓값을 출력한다

```cpp
// https://9967han.tistory.com/15 참고

#include<bits/stdc++.h>
using namespace std;

const int MAX = 501;

int dx[] = { 1, -1, 0, 0 };
int dy[] = { 0, 0, 1, -1 };
int N, M, ans = 0;

void getMaxNum(vector<vector<int>>& mymap, vector<vector<bool>>& visited, int x, int y, int cnt, int curScore)
{
	// 블록이 4개라면 스코어 갱신이 가능한지 체크
	if (cnt == 4)
	{
		if (ans < curScore) ans = curScore;
		return;
	}

	// 현재 노드에서 만들수 있는 모든 도형을 만들자
	for (int i = 0; i < 4; ++i)
	{
		int nx = x + dx[i];
		int ny = y + dy[i];

		if (nx < 0 || ny < 0 || M <= nx || N <= ny || visited[ny][nx]) continue;

		visited[ny][nx] = true;
		getMaxNum(mymap, visited, nx, ny, cnt + 1, curScore + mymap[ny][nx]);
		visited[ny][nx] = false;
	}
}

int main()
{
	vector<vector<int>> mymap(MAX, vector<int>(MAX, 0));
	vector<vector<bool>> visited(MAX, vector<bool>(MAX, false));

	cin >> N >> M;

	for (int y = 0; y < N; ++y)
	{
		for (int x = 0; x < M; ++x)
		{
			cin >> mymap[y][x];
		}
	}

	for (int y = 0; y < N; ++y)
	{
		for (int x = 0; x < M; ++x)
		{
			// 모든 노드를 방문한다
			visited[y][x] = true;
			getMaxNum(mymap, visited, x, y, 1, mymap[y][x]);
			visited[y][x] = false;

			// ㅏ ㅓ ㅗ ㅜ 를 만들자
			if (0 <= y - 1 && x + 1 < M && y + 1 < N) //ㅏ
			{
				ans = max(ans, (mymap[y - 1][x] + mymap[y][x] + mymap[y][x + 1] + mymap[y + 1][x]));
			}
			if (0 <= y - 1 && 0 <= x - 1 && y + 1 < N) //ㅓ
			{
				ans = max(ans, (mymap[y - 1][x] + mymap[y][x] + mymap[y][x - 1] + mymap[y + 1][x]));
			}
			if (0 <= y - 1 && 0 <= x - 1 && x + 1 < M) //ㅗ
			{
				ans = max(ans, (mymap[y - 1][x] + mymap[y][x - 1] + mymap[y][x] + mymap[y][x + 1]));
			}
			if (0 <= x - 1 && x + 1 < M && y + 1 < N) //ㅜ
			{
				ans = max(ans, (mymap[y][x - 1] + mymap[y][x] + mymap[y][x + 1] + mymap[y + 1][x]));
			}
		}
	}

	cout << ans;
}
```

<br>

## Chapter 07 DP

### 07-1 문제
- 설명

```cpp
```

<br>

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}
