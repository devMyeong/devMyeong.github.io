---
title:  "프로그래머스 코딩테스트 고득점 Kit"

categories:
  - Algorithm
tags:
  - []

comments: true

toc: true
toc_sticky: true

date: 2022-07-06
last_modified_at: 2022-07-09
---

## Chapter 01 해시

### 01-1 완주하지 못한 선수
- 수많은 마라톤 선수들이 마라톤에 참여하였습니다
- 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다
- 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요

```cpp
#include <iostream>
#include <string>
#include <stack>
#include <queue>
#include <set>
#include <algorithm>
#include <vector>
#include <functional>
#include <string>
#include <unordered_map>
#include <map>

using namespace std;

string solution(vector<string> participant, vector<string> completion)
{
	string answer = "";

    // 맵은 중복키 허용하지 않는다
	unordered_map<string, int> mListCount;

    
    // 해당하는 이름의 value를 증가시킨다
	for (auto name : completion)
	{
		mListCount[name] = mListCount[name] + 1;
	}

    
    // 해당하는 이름의 value를 감소시킨다
	for (auto name : participant)
	{
		mListCount[name] = mListCount[name] - 1;
        
        // 해당하는 이름이 음수가 되면 완주하지 못한 애다
		if (mListCount[name] < 0)
			answer = name;
	}

	return answer;
}
```

### 01-2 완주하지 못한 선수
- 전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다
- 전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다
- 구조대 : 119
- 박준영 : 97 674 223
- 지영석 : 11 9552 4421
- 전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요

```cpp
#include <string>
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

bool solution(vector<string> phone_book)
{
    // phoneBook 배열을 정렬한다
    sort(phone_book.begin(), phone_book.end());

    // 1중 Loop을 돌며 앞 번호가 뒷 번호의 접두어인지 확인한다
    for (int i = 0; i < phone_book.size() - 1; i++)
        if (phone_book[i + 1].find(phone_book[i]) == 0)
            return false;

    // 여기까지 오면 접두어가 없다는 것이다
    return true;
}
```

### 01-3 위장
- 스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다
- 예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다
- 스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요

```cpp
#include <string>
#include <vector>
#include <unordered_map>

using namespace std;

int solution(vector<vector<string>> clothes)
{
    int answer = 1;
    unordered_map<string, int> mClothes;
    
    // 모든 종류를 체크한다
    for(auto cloth : clothes)
    {
        mClothes[cloth[1]] = mClothes[cloth[1]] + 1;
    }
    
    // 만약, 상의 3개, 하의 2개, 장신구 2개가 있었다고 가정하면, 총 가능한 경우의 수는 (3+1) * (2+1) * (2+1) = 36가지 이다
    // 참고로 (3+1) * (2+1) * (2+1) = 36가지 에서 +1은 선택 안함에 해당하는 경우의 수이다
    for(auto it = mClothes.begin(); it != mClothes.end(); it++)
    {
        answer = answer * (it->second + 1);
    }
    
    // 그런데, 이 경우에는 (상의 선택 안 함, 하의 선택 안 함, 장신구 선택 안 함)이 포함되어 있으므로 그 경우를 빼주는 것이다
    // 덧 붙이자면, 문제의 제한사항에 스파이는 하루에 최소 한 개의 의상은 입습니다 라고 했다
    return answer - 1;
}
```

### 01-4 베스트앨범
- 스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다 노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다
- 속한 노래가 많이 재생된 장르를 먼저 수록합니다
- 장르 내에서 많이 재생된 노래를 먼저 수록합니다
- 장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다
- 노래의 장르를 나타내는 문자열 배열 genres와 노래별 재생 횟수를 나타내는 정수 배열 plays가 주어질 때, 베스트 앨범에 들어갈 노래의 고유 번호를 순서대로 return 하도록 solution 함수를 완성하세요

```cpp
#include <string>
#include <vector>
#include <map>
using namespace std;
 
vector<int> solution(vector<string> genres, vector<int> plays)
{
    // 여기에 고유번호 저장
    vector<int> answer;
    //각 장르별로 횟수저장
    map<string, int> music;
    //각 장르별로 무슨노래가 몇번씩 저장됬는지
    map<string, map<int, int>> musiclist;
    
    //들어온 리스트만큼 반복
    for (int i = 0; i < genres.size(); i++) 
    {
        //music map에 장르별로 횟수추가
        music[genres[i]] += plays[i];
        //musiclist map에 노래번호와 플레이횟수 추가
        musiclist[genres[i]][i] = plays[i];
    }
    
    //장르가 다없어질때까지 반복
    while (music.size() > 0)
    {
        string genre{};
        int max{0};
        
        //장르중에서 제일높은것 찾기
        for (auto mu : music)
        {
            if (max < mu.second)
            {
                max = mu.second;
                genre = mu.first;
            }
        }
        
        //2곡을 넣어야하므로 2번반복
        for (int i = 0; i < 2; i++)
        {
            int val = 0, ind = -1;
            
            //노래중에서 제일높은것 찾기
            for (auto ml : musiclist[genre]) 
            {
                if (val < ml.second) 
                {
                    val = ml.second;
                    ind = ml.first;
                }
            }
            
            //만약 노래가 0~1곡밖에없다면 반복문 탈출
            if (ind == -1)    break;
            
            //리턴할 리스트에 노래번호 추가
            answer.push_back(ind);
            musiclist[genre].erase(ind);
        }
        
        //map 에서 사용한 장르삭제
        music.erase(genre);
    }

    return answer;

}
```

<br>

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}
