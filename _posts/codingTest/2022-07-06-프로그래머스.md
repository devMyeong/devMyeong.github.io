---
title:  "프로그래머스 코딩테스트 고득점 Kit"

categories:
  - Algorithm
tags:
  - []

comments: true

toc: true
toc_sticky: true

date: 2022-07-06
last_modified_at: 2022-07-12
---

## Chapter 01 해시

### 01-1 폰켓몬
- 당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다
- 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다
- 홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다
- 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다
- 이때, 4마리의 폰켓몬 중 2마리를 고르는 방법은 다음과 같이 6가지가 있습니다
- 첫 번째(3번), 두 번째(1번) 폰켓몬을 선택
- 첫 번째(3번), 세 번째(2번) 폰켓몬을 선택
- 첫 번째(3번), 네 번째(3번) 폰켓몬을 선택
- 두 번째(1번), 세 번째(2번) 폰켓몬을 선택
- 두 번째(1번), 네 번째(3번) 폰켓몬을 선택
- 세 번째(2번), 네 번째(3번) 폰켓몬을 선택
- 이때, 첫 번째(3번) 폰켓몬과 네 번째(3번) 폰켓몬을 선택하는 방법은 한 종류(3번 폰켓몬 두 마리)의 폰켓몬만 가질 수 있지만, 다른 방법들은 모두 두 종류의 폰켓몬을 가질 수 있습니다
- 따라서 위 예시에서 가질 수 있는 폰켓몬 종류 수의 최댓값은 2가 됩니다
- 당신은 최대한 다양한 종류의 폰켓몬을 가지길 원하기 때문에, 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택하려 합니다
- N마리 폰켓몬의 종류 번호가 담긴 배열 nums가 매개변수로 주어질 때, N/2마리의 폰켓몬을 선택하는 방법 중, 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 하도록 solution 함수를 완성해주세요

```cpp
#include <vector>
#include <unordered_map>
using namespace std;

int solution(vector<int> nums)
{
    int answer = 0;
    unordered_map<int, int> mMonster;
    
    int iCount = nums.size();
    // 몬스터가 종류별로 몇개가 있는지 분류한다
    for(int i = 0; i < iCount; ++i)
    {
        mMonster[nums[i]] = mMonster[nums[i]] + 1;
    }
    
    // 몬스터 종류의 최대 갯수를 구한다
    int iMax = mMonster.size();
    
    // 문제에서 N/2마리 까지 몬스터를 가질수 있다고 했으니 이를 초과하지 못하게 방지한다
    if(nums.size()/2 < iMax)
        answer = nums.size()/2;
    else
        answer = iMax;
    
    return answer;
}
```

### 01-2 완주하지 못한 선수
- 수많은 마라톤 선수들이 마라톤에 참여하였습니다
- 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다
- 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요

```cpp
#include <iostream>
#include <string>
#include <stack>
#include <queue>
#include <set>
#include <algorithm>
#include <vector>
#include <functional>
#include <string>
#include <unordered_map>
#include <map>

using namespace std;

string solution(vector<string> participant, vector<string> completion)
{
	string answer = "";

    // 맵은 중복키 허용하지 않는다
	unordered_map<string, int> mListCount;

    
    // 해당하는 이름의 value를 증가시킨다
	for (auto name : completion)
	{
		mListCount[name] = mListCount[name] + 1;
	}

    
    // 해당하는 이름의 value를 감소시킨다
	for (auto name : participant)
	{
		mListCount[name] = mListCount[name] - 1;
        
        // 해당하는 이름이 음수가 되면 완주하지 못한 애다
		if (mListCount[name] < 0)
			answer = name;
	}

	return answer;
}
```

### 01-3 전화번호 목록
- 전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다
- 전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다
- 구조대 : 119
- 박준영 : 97 674 223
- 지영석 : 11 9552 4421
- 전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요

```cpp
#include <string>
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

bool solution(vector<string> phone_book)
{
    // phoneBook 배열을 정렬한다
    sort(phone_book.begin(), phone_book.end());

    // 1중 Loop을 돌며 앞 번호가 뒷 번호의 접두어인지 확인한다
    for (int i = 0; i < phone_book.size() - 1; i++)
        if (phone_book[i + 1].find(phone_book[i]) == 0)
            return false;

    // 여기까지 오면 접두어가 없다는 것이다
    return true;
}
```

### 01-4 위장
- 스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다
- 예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다
- 스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요

```cpp
#include <string>
#include <vector>
#include <unordered_map>

using namespace std;

int solution(vector<vector<string>> clothes)
{
    int answer = 1;
    unordered_map<string, int> mClothes;
    
    // 모든 종류를 체크한다
    for(auto cloth : clothes)
    {
        mClothes[cloth[1]] = mClothes[cloth[1]] + 1;
    }
    
    // 만약, 상의 3개, 하의 2개, 장신구 2개가 있었다고 가정하면, 총 가능한 경우의 수는 (3+1) * (2+1) * (2+1) = 36가지 이다
    // 참고로 (3+1) * (2+1) * (2+1) = 36가지 에서 +1은 선택 안함에 해당하는 경우의 수이다
    for(auto it = mClothes.begin(); it != mClothes.end(); it++)
    {
        answer = answer * (it->second + 1);
    }
    
    // 그런데, 이 경우에는 (상의 선택 안 함, 하의 선택 안 함, 장신구 선택 안 함)이 포함되어 있으므로 그 경우를 빼주는 것이다
    // 덧 붙이자면, 문제의 제한사항에 스파이는 하루에 최소 한 개의 의상은 입습니다 라고 했다
    return answer - 1;
}
```

### 01-5 베스트앨범
- 스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다 노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다
- 속한 노래가 많이 재생된 장르를 먼저 수록합니다
- 장르 내에서 많이 재생된 노래를 먼저 수록합니다
- 장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다
- 노래의 장르를 나타내는 문자열 배열 genres와 노래별 재생 횟수를 나타내는 정수 배열 plays가 주어질 때, 베스트 앨범에 들어갈 노래의 고유 번호를 순서대로 return 하도록 solution 함수를 완성하세요

```cpp
#include <string>
#include <vector>
#include <map>
using namespace std;
 
vector<int> solution(vector<string> genres, vector<int> plays)
{
    // 여기에 고유번호 저장
    vector<int> answer;
    //각 장르별로 횟수저장
    map<string, int> music;
    //각 장르별로 무슨노래가 몇번씩 저장됬는지
    map<string, map<int, int>> musiclist;
    
    //들어온 리스트만큼 반복
    for (int i = 0; i < genres.size(); i++) 
    {
        //music map에 장르별로 횟수추가
        music[genres[i]] += plays[i];
        //musiclist map에 노래번호와 플레이횟수 추가
        musiclist[genres[i]][i] = plays[i];
    }
    
    //장르가 다없어질때까지 반복
    while (music.size() > 0)
    {
        string genre{};
        int max{0};
        
        //장르중에서 제일높은것 찾기
        for (auto mu : music)
        {
            if (max < mu.second)
            {
                max = mu.second;
                genre = mu.first;
            }
        }
        
        //2곡을 넣어야하므로 2번반복
        for (int i = 0; i < 2; i++)
        {
            int val = 0, ind = -1;
            
            //노래중에서 제일높은것 찾기
            for (auto ml : musiclist[genre]) 
            {
                if (val < ml.second) 
                {
                    val = ml.second;
                    ind = ml.first;
                }
            }
            
            //만약 노래가 0~1곡밖에없다면 반복문 탈출
            if (ind == -1)    break;
            
            //리턴할 리스트에 노래번호 추가
            answer.push_back(ind);
            musiclist[genre].erase(ind);
        }
        
        //map 에서 사용한 장르삭제
        music.erase(genre);
    }

    return answer;

}
```

## Chapter 02 스택/큐

### 02-1 기능개발
- 프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다
- 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다
- 먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요

```cpp
#include <string>
#include <vector>
#include <queue>

using namespace std;

vector<int> solution(vector<int> progresses, vector<int> speeds)
{
    // 정답을 담을 곳
    vector<int> answer;
    // 배포될 작업을 임시로 담을 곳
    queue<int> q;
    // 작업 개수라고 보면 되는 사이즈
    int size = speeds.size();
    
    // 작업에 해당하는 인덱스를 담는다
    for (int i = 0; i < size; ++i)
    {
        q.push(i);
    }
    
    // 큐에 인덱스 값이 남아 있으면 없을때 까지 돈다
    while(!q.empty())
    {
        int cnt = 0;
        
        // 작업 진척도 퍼센테이지를 담아놓은 벡터의 값을 증가시킨다
        for(int j = 0; j < size; ++j)
        {
            progresses[j] += speeds[j];
        }
        
        // 여기서 각 배포마다 몇 개의 기능이 배포되는지를 카운트 한다
        while(!q.empty() && progresses[q.front()] >= 100)
        { 
            ++cnt;
            q.pop();
        }
        
        // 각 배포마다 몇 개의 기능이 배포되는지 정답지에 담는다
        if(cnt != 0)
            answer.push_back(cnt);  
    }
    
    return answer;
    
}
```

### 02-2 프린터
- 일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다
- 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다
- 이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다
- 이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다

```cpp
#include <string>
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

int solution(vector<int> priorities, int location)
{
    int answer = 0, count = 0;
    //일반큐
    queue<pair<int, int>> que;
    //우선순위 큐
    priority_queue <int> prio_que;
 
    for (int i = 0; i < priorities.size(); ++i)
    {
        //큐에 들어온 순서와 중요도를 넣음
        que.push(make_pair(i, priorities[i]));
        //우선순위 큐에 중요도를 넣음
        prio_que.push(priorities[i]);
    }
    //큐가 빌때까지 반복
    while (!que.empty())
    {
        int index = que.front().first;
        int value = que.front().second;
        que.pop();
        //우선순위 1순위와 현재값이 같다면
        if (prio_que.top() == value)
        {
            //우선순위큐 pop
            prio_que.pop();
            //하나가 나갔으므로 count
            count++;
            //현재 나간것이 원하는것과 같다면
            if (index == location)
            {
                //현재 카운터를 리턴
                answer = count;
                break;
            }
        }
        //우선순위 1순위와 현재값이 같지않다면 큐 뒤에 넣기
        else
            que.push(make_pair(index, value));
    }
    return answer;
}
```

### 02-3 다리를 지나는 트럭
- 트럭 여러 대가 강을 가로지르는 일차선 다리를 정해진 순으로 건너려 합니다
- 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다
- 다리에는 트럭이 최대 bridge_length대 올라갈 수 있으며, 다리는 weight 이하까지의 무게를 견딜 수 있습니다
- 단, 다리에 완전히 오르지 않은 트럭의 무게는 무시합니다

```cpp
    queue<int> que;
    int time = 0;
    int sum = 0;
    int truckIdx = 0;
    
    while(true)
    {
        // 1초인 시점부터 트럭이 진입하기 시작하자나 그러니까 시작하자 마자 ++ 시켜준거다
         time++;
        // 트럭의 무게가 다리의 무게보다 작으면, 트럭을 삽입
        if(sum + truck_weights[truckIdx] <= weight)
        {
            // 마지막 트럭이 삽입되면 종료
            if(truckIdx == truck_weights.size()-1)
            {
                // 마지막 트럭 도착시간 추가
                time += bridge_length;
                break;
            }
            
            que.push(truck_weights[truckIdx]);
            sum += truck_weights[truckIdx];
            truckIdx++;
        }
        // 트럭의 무게가 다리의 무게보다 크면, 0을 삽입해서 트럭을 도착점으로 민다
        else
        {
            que.push(0);
        }

        // 큐 사이즈 = 다리길이 -> 트럭 도착
        if(que.size() == bridge_length)
        {
            sum -= que.front();
            que.pop();
        }
    }
    return time;
```

### 02-4 주식가격
- 초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요

```cpp
#include <string>
#include <vector>
#include <stack>
 
using namespace std;
 
vector<int> solution(vector<int> prices)
{
    vector<int> answer(size);
    stack<int> st;

    int size = prices.size();
    for (int i = 0; i < size; i++)
    {
        //스택이 비어있지않고 스택마지막 값이 현재값보다 크다면
        //-> 가격이 떨어졌다면
        while (!st.empty() && prices[st.top()] > prices[i])
        {
            //가격이 떨어졌으므로 i - 스택 마지막값 대입
            answer[st.top()] = i - st.top();
            //값제거
            st.pop();
            //반복문인 이유: 가격이 같은값이 유지되었을경우
            //현재값보다 계속작으므로 1개차이씩 넣어주기 위해서다.
        }
        //현재 인덱스를 스택에 넣기
        st.push(i);
    }
    //스택이 빌때까지 반복
    while (!st.empty())
    {
        //위에서 특정위치에 이미값을 넣었으므로 pushback이나 insert로하면 안된다.
        //뒤에서부터 넣어야하므로 size-1 에서 top값을 빼준다.
        answer[st.top()] = size - st.top() - 1;
        st.pop();
    }
    return answer;
}
```

<br>

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}
