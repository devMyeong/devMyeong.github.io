---
title:  "백준 ( 쉽고, 깔끔하고, 시간복잡도가 좋은 코드 )"

categories:
  - Algorithm
tags:
  - []

comments: true

toc: true
toc_sticky: true

date: 2022-09-25
last_modified_at: 2022-09-25
---

## Chapter 01 그리디

### 01-1 회의실 배정 ( 1931 )
- 한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다
- 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자
- 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다
- 회의의 시작시간과 끝나는 시간이 같을 수도 있다
- 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    int totalmeeting = 0;
    
    int meeting = 0;
    cin>>meeting;
    
    // 미팅 목록을 기록한다 ( 끝나는 시간 기준 정렬을 하기 위해, 끝나는 시간이 앞에 오게 저장한다 )
    vector<pair<int,int>> vMeeting;
    for(int i = 0; i < meeting; ++i)
    {
        int start = 0, end = 0;
        cin>>start>>end;
        vMeeting.push_back(make_pair(end,start));
    }
    sort(vMeeting.begin(), vMeeting.end());
    
    // 마지막 미팅 시간 이후 미팅 목록 중에서 가장 빠른 시간대를 예약한다
    int lastTime = 0;
    for(int i = 0; i < meeting; ++i)
    {
        if(lastTime <= vMeeting[i].second)
        {
            lastTime = vMeeting[i].first;
            totalmeeting = totalmeeting + 1;
        }
    }
    
    cout<<totalmeeting;
    
    return 0;
}
```

### 01-2 수 묶기 ( 1744 )
- 수열이 주어졌을 때, 수열의 각 수를 적절히 묶었을 때, 그 합이 최대가 되게 하는 프로그램을 작성하시오

```cpp
#include<bits/stdc++.h>
using namespace std;

int total, onecount, zerocount;
vector<int> positive;
vector<int> negative;

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    
    // 숫자들을 분류한다
    cin >> total;
    for (int i = 0; i < total; i++)
    {
        int value = 0;
        cin >> value;
        if (value > 1) positive.push_back(value);
        else if (value < 0) negative.push_back(value);
        else if (value == 0) zerocount++;
        else onecount++;
    }

    // 자리수를 맞춰준다
    if (positive.size() % 2 == 1)
        positive.push_back(1);
    if (negative.size() % 2 == 1)
    {
        if (zerocount == 0) negative.push_back(1);
        else negative.push_back(0);
    }

    // 양수는 오름차순 음수는 내림차순으로 정렬한다
    sort(positive.begin(), positive.end());
    sort(negative.rbegin(), negative.rend());

    // 두개씩 계산한다
    int sum = onecount;
    for (int i = 0; i < positive.size(); i += 2) 
        sum += positive[i] * positive[i + 1];
    for (int i = 0; i < negative.size(); i += 2)
        sum += negative[i] * negative[i + 1];
    
    cout << sum;
}
```

<br>

## Chapter 02 DFS

### 02-1 일곱 난쟁이 ( 2309 )
- 왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다
- 일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다
- 아홉 명의 난쟁이는 모두 자신이 "백설 공주와 일곱 난쟁이"의 주인공이라고 주장했다
- 뛰어난 수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다
- 아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오

```cpp
#include <bits/stdc++.h>
using namespace std;

int cnt = 0, sum = 0, value[10], check[10];

void dfs(int l)
{
    // 카운트가 7이라면 난쟁이 키의 합이 100인지 확인하자
    if(cnt == 7)
    {
        if(sum == 100)
        {
            for(int i = 1; i <= 9; ++i)
            {
                if(check[i] == 1)
                    cout << value[i] << endl;
            }
            exit(0);
        }
        
        return;
    }
    
    // 레벨의 끝에 도달했다면 리턴하자
    if(l==10)
        return;
    else
    {
        // 레벨의 끝이 아니고 현재 인덱스를 더하는 경우
        sum = sum + value[l];
        check[l] = 1;
        cnt++;
        dfs(l + 1);
        
        // 레벨의 끝이 아니고 현재 인덱스를 더하지 않는 경우
        sum = sum - value[l];
        check[l] = 0;
        cnt--;
        dfs(l+1);
    }
}

int main(void)
{
    ios_base::sync_with_stdio(false);
    cout.tie(NULL);
    cin.tie(NULL);
    
    for (int i = 1;i <= 9;i++)
        cin >> value[i];
    
    sort(value + 1, value + 10);
    
    dfs(1);
    
    return 0;
}
```

### 02-2 1, 2, 3 더하기 ( 9095 )
- 정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오

```cpp
#include <bits/stdc++.h>
using namespace std;

int answer = 0;

void dfs(int target, int sum)
{
    // 타겟이 맞는지 체크
    if(target <= sum)
    {
        if(target == sum)
        {
            answer++;
        }
        
        return;
    }
    
    // 경로 1
    dfs(target, sum + 1);
    // 경로 2
    dfs(target, sum + 2);
    // 경로 3
    dfs(target, sum + 3);
}

int main()
{
    ios_base::sync_with_stdio(false);
    cout.tie(NULL);
    cin.tie(NULL);
    
    int TestCase = 0;
    vector<int> vTestCase;
    cin>>TestCase;
    
    for(int i = 0; i < TestCase; ++i)
    {
        int value = 0;
        cin>>value;
        vTestCase.push_back(value);
    }
    
    for(int i = 0; i < vTestCase.size(); ++i)
    {
        dfs(vTestCase[i], 0);
        cout<<answer<<endl;
        answer = 0;
    }
    
    return 0;
}
```

### 02-3 에너지 모으기 ( 16198 )
- N과 에너지 구슬의 무게가 주어졌을 때, 모을 수 있는 에너지 양의 최댓값을 구하는 프로그램을 작성하시오

```cpp
#include<bits/stdc++.h>
using namespace std;

int max_energe = 0;

void dfs(vector<int> vBall, int erasenumber, int sum_energe)
{
    if(vBall.size() == 2)
    {
        return;
    }
    
    // MAX 에너지 갱신
    int current_energe = sum_energe + (vBall[erasenumber - 1] * vBall[erasenumber + 1]);
    vBall.erase(vBall.begin()+erasenumber);
    if(max_energe <= current_energe)
        max_energe = current_energe;
    
    // 두번째 이후 에너지 구슬 선택
    for(size_t erasenumber = 1; erasenumber < vBall.size() - 1; ++erasenumber)
    {
        dfs(vBall, erasenumber, current_energe);
    }
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    
    int ball = 0;
    cin >> ball;
    
    vector<int> vBall;
    for(int i = 0; i < ball; ++i)
    {
        int value = 0;
        cin >> value;
        vBall.push_back(value);
    }
    
    // 첫번째 에너지 구슬 선택
    for(size_t erasenumber = 1; erasenumber < ball - 1; ++erasenumber)
    {
        dfs(vBall, erasenumber, 0);
    }
    
    cout << max_energe << endl;
    
    return 0;
}
```

<br>

## Chapter 03 BFS

### 03-1 뱀과 사다리 게임 ( 16928 )
- 게임은 정육면체 주사위를 사용하며, 주사위의 각 면에는 1부터 6까지 수가 하나씩 적혀있다. 게임은 크기가 10×10이고, 총 100개의 칸으로 나누어져 있는 보드판에서 진행된다
- 보드판에는 1부터 100까지 수가 하나씩 순서대로 적혀져 있다
- 플레이어는 주사위를 굴려 나온 수만큼 이동해야 한다
- 예를 들어, 플레이어가 i번 칸에 있고, 주사위를 굴려 나온 수가 4라면, i+4번 칸으로 이동해야 한다
- 만약 주사위를 굴린 결과가 100번 칸을 넘어간다면 이동할 수 없다
- 도착한 칸이 사다리면, 사다리를 타고 위로 올라간다
- 뱀이 있는 칸에 도착하면, 뱀을 따라서 내려가게 된다
- 즉, 사다리를 이용해 이동한 칸의 번호는 원래 있던 칸의 번호보다 크고, 뱀을 이용해 이동한 칸의 번호는 원래 있던 칸의 번호보다 작아진다
- 게임의 목표는 1번 칸에서 시작해서 100번 칸에 도착하는 것이다
- 게임판의 상태가 주어졌을 때, 100번 칸에 도착하기 위해 주사위를 굴려야 하는 횟수의 최솟값을 구해보자

```cpp
#include<bits/stdc++.h>
using namespace std;

int warp[102] = {0};
bool visited[102] = {0};
 
void game(int x, int c)
{
    queue<pair<int, int>> que;
    que.push(make_pair(x, c));
    
    while(!que.empty())
    {
        // 다음 위치 세팅
        int location = que.front().first;
        int cnt = que.front().second;
        que.pop();
 
        for (int i = 1; i <= 6;i++)
        {
            // 주사위 숫자만큼 이동
            int nx = location + i;
            
            // 도착 했다면 정답을 출력
            if(nx == 100)
            {
                cout << cnt+1;
                return;
            }
            else if(nx < 100)
            { 
                // 워프를 태울수 있을때 까지 태운다
                while(warp[nx] != 0)
                {
                    nx = warp[nx];
                }
                
                // 아직 방문한적 없는 노드라면 큐에 넣는다
                if(!visited[nx])
                {
                    que.push(make_pair(nx, cnt + 1));
                    visited[nx] = true;
                }
                
            }
        }
    }
}

int main()
{
    ios_base::sync_with_stdio(false); cout.tie(NULL); cin.tie(NULL);
    
    int sadari, snake;
    cin >> sadari >> snake;
    
    for (int i = 0; i < sadari;i++)
    {
        int from = 0, to = 0;
        cin >> from >> to; 
        warp[from] = to;
    }
    for (int i = 0; i < snake;i++)
    {
        int from = 0, to = 0;
        cin >> from >> to;
        warp[from] = to;
    }
    
    game(1, 0);
    return 0;
}
```

### 03-2 4연산 ( 14395 )
- 정수 s가 주어진다
- 정수 s의 값을 t로 바꾸는 최소 연산 횟수를 구하는 프로그램을 작성하시오

```cpp
#include<bits/stdc++.h>
using namespace std;

const long long MAX = 1e9;

int start, target;

int main()
{
    cin >> start >> target;
    if(start == target)
    {
        cout << 0 << "\n";
        return 0;
    }
    
    // 필요한 변수 초기화
    queue<pair<long long, string>> que;
    set<long long> visited;
    que.push({start, ""});
    
    while (!que.empty())
    {
        // 다음 숫자 세팅
        long long n = que.front().first;
        string temp = que.front().second;
        que.pop();

        // 원하는 숫자라면 연산자 출력후 리턴
        if (n == target)
        {
            cout << temp << "\n";
            return 0;
        }

        // 현재 노드에서 방문할 수 있는 노드를 모두 큐에 담는다 ( https://twpower.github.io/92-how-to-use-set-in-cpp // count 함수에 대한 정보 )
        if (0 <= n * n && n * n <= MAX && visited.count(n*n) == 0 )
        {
            que.push({ n * n, temp + "*" });
            visited.insert(n*n);
        }
        if (0 <= n + n && n + n <= MAX && visited.count(n+n) == 0)
        {
            que.push({ n + n, temp + "+" });
            visited.insert(n + n);
        }
        if (0 <= n - n && n - n <= MAX && visited.count(n-n) == 0)
        {
            que.push({ n - n, temp + "-" });
            visited.insert(n - n);
        }
        if (n != 0 && 0 <= n / n && n / n <= MAX && visited.count(n/n) == 0)
        {
            que.push({ n / n, temp + "/" });
            visited.insert(n / n);
        }

    }
    
    // 변환이 불가능한 경우 -1을 출력한다
    cout << -1 << "\n";
    return 0;
}
```

<br>

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}
