---
title:  "백준 ( 쉽고, 깔끔하고, 시간복잡도가 좋은 코드 )"

categories:
  - Algorithm
tags:
  - []

comments: true

toc: true
toc_sticky: true

date: 2022-09-25
last_modified_at: 2022-10-05
---

## Chapter 01 그리디

### 01-1 회의실 배정 ( 1931 )
- 한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다
- 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자
- 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다
- 회의의 시작시간과 끝나는 시간이 같을 수도 있다
- 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    int totalmeeting = 0;
    
    int meeting = 0;
    cin>>meeting;
    
    // 미팅 목록을 기록한다 ( 끝나는 시간 기준 정렬을 하기 위해, 끝나는 시간이 앞에 오게 저장한다 )
    vector<pair<int,int>> vMeeting;
    for(int i = 0; i < meeting; ++i)
    {
        int start = 0, end = 0;
        cin>>start>>end;
        vMeeting.push_back(make_pair(end,start));
    }
    sort(vMeeting.begin(), vMeeting.end());
    
    // 마지막 미팅 시간 이후 미팅 목록 중에서 가장 빠른 시간대를 예약한다
    int lastTime = 0;
    for(int i = 0; i < meeting; ++i)
    {
        if(lastTime <= vMeeting[i].second)
        {
            lastTime = vMeeting[i].first;
            totalmeeting = totalmeeting + 1;
        }
    }
    
    cout<<totalmeeting;
    
    return 0;
}
```

### 01-2 수 묶기 ( 1744 )
- 수열이 주어졌을 때, 수열의 각 수를 적절히 묶었을 때, 그 합이 최대가 되게 하는 프로그램을 작성하시오

```cpp
#include<bits/stdc++.h>
using namespace std;

int total, onecount, zerocount;
vector<int> positive;
vector<int> negative;

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    
    // 숫자들을 분류한다
    cin >> total;
    for (int i = 0; i < total; i++)
    {
        int value = 0;
        cin >> value;
        if (value > 1) positive.push_back(value);
        else if (value < 0) negative.push_back(value);
        else if (value == 0) zerocount++;
        else onecount++;
    }

    // 자리수를 맞춰준다
    if (positive.size() % 2 == 1)
        positive.push_back(1);
    if (negative.size() % 2 == 1)
    {
        if (zerocount == 0) negative.push_back(1);
        else negative.push_back(0);
    }

    // 양수는 오름차순 음수는 내림차순으로 정렬한다
    sort(positive.begin(), positive.end());
    sort(negative.rbegin(), negative.rend());

    // 두개씩 계산한다
    int sum = onecount;
    for (int i = 0; i < positive.size(); i += 2) 
        sum += positive[i] * positive[i + 1];
    for (int i = 0; i < negative.size(); i += 2)
        sum += negative[i] * negative[i + 1];
    
    cout << sum;
}
```

### 01-3 A와 B ( 12904 )
- 주어진 조건을 이용해서 S를 T로 만들 수 있는지 없는지 알아내는 프로그램을 작성하시오

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    string S = "", T = "";
    cin>>S;
    cin>>T;
    
    while(true)
    {
        if(T.size() == S.size())
        {
            if(S == T)
            {
                cout << 1 << endl;
                break;
            }
            else
            {
                cout << 0 << endl;
                break;
            }
        }
        
        // 문자열 T를 문자열 S로 역변환해 문제를 해결한다
        if(T[T.size()-1] == 'A')
        {
            T.pop_back();
            continue;
        }
        else if(T[T.size()-1] == 'B')
        {
            T.pop_back();
            reverse(T.begin(), T.end());
            continue;
        }
        
        cout << 0 << endl;
        break;
    }
}
```

<br>

## Chapter 02 DFS

### 02-1 일곱 난쟁이 ( 2309 )
- 왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다
- 일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다
- 아홉 명의 난쟁이는 모두 자신이 "백설 공주와 일곱 난쟁이"의 주인공이라고 주장했다
- 뛰어난 수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다
- 아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int>  vecValue;

void dfs(vector<bool>& visited, int targetcount, int targetsum, int level, int cnt, int sum)
{
    // targetcount에 도달하면 난쟁이 키의 합이 targetsum인지 확인하자
    if(cnt == targetcount)
    {
        if(sum == targetsum)
        {
            for(int i = 0; i < vecValue.size(); ++i)
            {
                if(visited[i] == true)
                    cout << vecValue[i] << endl;
            }
            exit(0);
        }
        
        return;
    }
    
    // 레벨의 끝에 도달했다면 리턴하자
    if(level == vecValue.size())
        return;
    else
    {
        // 레벨의 끝이 아니고 현재 인덱스를 더하는 경우
        visited[level] = true;
        dfs(visited, targetcount, targetsum, level + 1, cnt + 1, sum + vecValue[level]);
        
        // 레벨의 끝이 아니고 현재 인덱스를 더하지 않는 경우
        visited[level] = false;
        dfs(visited, targetcount, targetsum, level+1, cnt, sum);
    }
}

int main(void)
{
    ios_base::sync_with_stdio(false);
    cout.tie(NULL);
    cin.tie(NULL);
    
    for (int i = 0; i < 9;i++)
    {
        int value;
        cin >> value;
        vecValue.push_back(value);
    }
    
    sort(vecValue.begin(), vecValue.end());
    
    vector<bool> visited(vecValue.size());
    dfs(visited, 7, 100, 0, 0, 0);
    
    return 0;
}
```

### 02-2 1, 2, 3 더하기 ( 9095 )
- 정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오

```cpp
#include <bits/stdc++.h>
using namespace std;

int answer = 0;

void dfs(int target, int sum)
{
    // 타겟이 맞는지 체크
    if(target <= sum)
    {
        if(target == sum)
        {
            answer++;
        }
        
        return;
    }
    
    // 경로 1
    dfs(target, sum + 1);
    // 경로 2
    dfs(target, sum + 2);
    // 경로 3
    dfs(target, sum + 3);
}

int main()
{
    ios_base::sync_with_stdio(false);
    cout.tie(NULL);
    cin.tie(NULL);
    
    int TestCase = 0;
    vector<int> vTestCase;
    cin>>TestCase;
    
    for(int i = 0; i < TestCase; ++i)
    {
        int value = 0;
        cin>>value;
        vTestCase.push_back(value);
    }
    
    for(int i = 0; i < vTestCase.size(); ++i)
    {
        dfs(vTestCase[i], 0);
        cout<<answer<<endl;
        answer = 0;
    }
    
    return 0;
}
```

### 02-3 에너지 모으기 ( 16198 )
- N과 에너지 구슬의 무게가 주어졌을 때, 모을 수 있는 에너지 양의 최댓값을 구하는 프로그램을 작성하시오

```cpp
#include<bits/stdc++.h>
using namespace std;

int max_energe = 0;

void dfs(vector<int> vBall, int erasenumber, int sum_energe)
{
    if(vBall.size() == 2)
    {
        return;
    }
    
    // MAX 에너지 갱신
    int current_energe = sum_energe + (vBall[erasenumber - 1] * vBall[erasenumber + 1]);
    vBall.erase(vBall.begin()+erasenumber);
    if(max_energe <= current_energe)
        max_energe = current_energe;
    
    // 두번째 이후 에너지 구슬 선택
    for(size_t erasenumber = 1; erasenumber < vBall.size() - 1; ++erasenumber)
    {
        dfs(vBall, erasenumber, current_energe);
    }
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    
    int ball = 0;
    cin >> ball;
    
    vector<int> vBall;
    for(int i = 0; i < ball; ++i)
    {
        int value = 0;
        cin >> value;
        vBall.push_back(value);
    }
    
    // 첫번째 에너지 구슬 선택
    for(size_t erasenumber = 1; erasenumber < ball - 1; ++erasenumber)
    {
        dfs(vBall, erasenumber, 0);
    }
    
    cout << max_energe << endl;
    
    return 0;
}
```

### 02-4 파이프 옮기기 1 ( 17070 )
- 파이프의 한쪽 끝을 (N, N)로 이동시키는 방법의 개수를 구해보자

```cpp
#include<bits/stdc++.h>
using namespace std;
    
int visited[20][20];

void dfs(int y, int x, int dir, int housecount)
{
    visited[y][x] = visited[y][x] + 1;
    
    // 경로 1
    if(dir == 0 || dir == 2)
    {
        if(x < housecount && visited[y][x+1] != -1)
        {
            dfs(y, x+1, 0, housecount);
        }
    }
    // 경로 2
    if(dir == 1 || dir == 2)
    {
        if(y < housecount && visited[y+1][x] != -1)
        {
            dfs(y+1, x, 1, housecount);
        }
    }
    // 경로 3
    if(x < housecount && y < housecount && visited[y][x+1] != -1 && visited[y+1][x] != -1 && visited[y+1][x+1] != -1)
    {
        dfs(y+1, x+1, 2, housecount);
    }
    
    return;
}

int main()
{
    int housecount = 0;
    cin >> housecount;
    
    for(int i = 1; i <= housecount; i++)
    for(int j = 1; j <= housecount; j++)
    {
        int value = 0;
        cin >> value;
        if(value == 0)
        {
            visited[i][j] = 0;
        }
        else
        {
            visited[i][j] = -1;
        }
	}
    
    dfs(1,2,0,housecount);
    
    if(visited[housecount][housecount] != -1) cout << visited[housecount][housecount] << endl;
    else cout << 0 << endl;
}
```

### 02-5 암호 만들기 ( 1759 )
- 가능성 있는 암호들을 모두 구하는 프로그램을 작성하시오

```cpp
#include<bits/stdc++.h>
using namespace std;

void dfs(vector<char> vChar, int L, int C, int level, int length, string curstr)
{
    // 문자열 길이 체크
    if(length == L)
    {
        int mo = 0, ja = 0;
        for(int i = 0; i < L; ++i)
        {
            if(curstr[i] == 'a' || curstr[i] == 'e' || curstr[i] == 'i' || curstr[i] == 'o' || curstr[i] == 'u' )
                mo++;
            ja = L - mo;
        }
        
        if(1 <= mo && 2 <= ja)
            cout << curstr << endl;
        
        return;
    }
    
    // 레벨의 끝에 도달했다면 리턴하자
    if(level == C)
    {
        return;
    }
    else
    {
        // 문자열을 추가해주는 경우
        dfs(vChar, L, C, level + 1, length + 1, curstr + vChar[level]);
        // 문자열을 추가해주지 않는 경우
        dfs(vChar, L, C, level + 1, length, curstr);
    }
}

int main()
{
    int L = 0, C = 0;
    cin >> L >> C;
    
    vector<char> vChar;
    for(int i = 0; i < C; ++i)
    {
        char value;
        cin >> value;
        vChar.push_back(value);
    }
    
    sort(vChar.begin(), vChar.end());
    
    dfs(vChar, L, C, 0, 0, "");
    
    return 0;
}
```

### 02-6 테크노미노 ( 14500 )
- 테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다

```cpp
// https://9967han.tistory.com/15 참고

#include<bits/stdc++.h>
using namespace std;

int mymap[501][501], visited[501][501];
int dx[] = {1, -1, 0, 0};
int dy[] = {0, 0, 1, -1};
int N, M, ans=0;

void getMaxNum(int x, int y, int cnt, int curScore)
{
    // 블록이 4개라면 스코어 갱신이 가능한지 체크
    if(cnt == 4)
    {
        if(ans < curScore) ans = curScore;
        return;
    }

    // 현재 노드에서 만들수 있는 모든 도형을 만들자
    for(int i = 0; i < 4; ++i)
    {
        int nx = x + dx[i];
        int ny = y + dy[i];
        if(nx < 0 || ny < 0 || ny >= N || nx >= M || visited[ny][nx]) continue;
        visited[ny][nx] = 1;
        getMaxNum(nx, ny, cnt + 1, curScore + mymap[ny][nx]);
        visited[ny][nx] = 0;
    }
}

int main()
{
    memset(visited, 0, sizeof(visited));
 
    cin >> N >> M;

    for(int y = 0; y < N; ++y)
    {
        for(int x = 0; x < M; ++x)
        {
            cin >> mymap[y][x];
        }
    }

    for(int y = 0; y < N; ++y)
    {
        for(int x = 0; x < M; ++x)
        {
            // 모든 노드를 방문한다
            visited[y][x] = 1;
            getMaxNum(x, y, 1, mymap[y][x]);
            visited[y][x] = 0;
            
            // ㅏ ㅓ ㅗ ㅜ 를 만들자
            if(y-1 >= 0 && x+1 < M && y+1 < N) //ㅏ
            {
                ans = max(ans, (mymap[y-1][x] + mymap[y][x] + mymap[y][x+1] + mymap[y+1][x]));
            }
            if(x-1 >= 0 && y-1 >= 0 && y+1 < N) //ㅓ
            {
                ans = max(ans, (mymap[y-1][x] + mymap[y][x] + mymap[y][x-1] + mymap[y+1][x]));
            }
            if(x-1 >= 0 && y-1 >= 0 && x+1 < M) //ㅗ
            {
                ans = max(ans, (mymap[y-1][x] + mymap[y][x] + mymap[y][x-1] + mymap[y][x+1]));
            }
            if(x-1 >= 0 && x+1 < M && y+1 < N) //ㅜ
            {
                ans = max(ans, (mymap[y][x] + mymap[y][x-1] + mymap[y][x+1] + mymap[y+1][x]));
            }
        }
    }

    cout << ans;
}
```

### 02-7 테트리스 ( 3019 )
- 블록을 놓는 서로 다른 방법의 수를 구하는 프로그램을 작성하시오

```cpp
// https://hsdevelopment.tistory.com/506 참고

#include <bits/stdc++.h>
using namespace std;
 
#define MAX 105
 
int mymap[MAX], c, p;
vector<string> v;
 
int simulation(int number)
{
    int ret = 0;
 
    if (number == 1)
    {
        v.push_back("0");
        v.push_back("0000");
    }
    else if (number == 2)
    {
        v.push_back("00");
    }
    else if (number == 3)
    {
        v.push_back("001");
        v.push_back("10");
    }
    else if (number == 4)
    {
        v.push_back("100");
        v.push_back("01");
    }
    else if (number == 5)
    {
        v.push_back("000");
        v.push_back("01");
        v.push_back("101");
        v.push_back("10");
    }
    else if (number == 6)
    {
        v.push_back("000");
        v.push_back("00");
        v.push_back("011");
        v.push_back("20");
    }
    else if (number == 7)
    {
        v.push_back("000");
        v.push_back("02");
        v.push_back("110");
        v.push_back("00");
    }
 
    for (int i = 0; i < v.size(); i++)
    {
        int len = v[i].length();
 
        vector<int> temp;
        for (auto k : v[i])
        {
            temp.push_back(k - '0');
        }
 
        for (int j = 0; j + len <= c; j++)
        {
            bool calc = true;
 
            for (int k = j + 1; k < j + len; k++)
            {
                if (mymap[k] - mymap[k - 1] != temp[k - j] - temp[k - j - 1])
                {
                    calc = false;
                    break;
                }
            }
            if (calc)
            {
                ++ret;
            }
        }
    }
 
    return ret;
}
 
int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);

    cin >> c >> p;
 
    for (int i = 0; i < c; i++)
    {
        cin >> mymap[i];
    }
    
    cout << simulation(p) << endl;
    
    return 0;
}
```

<br>

## Chapter 03 BFS

### 03-1 뱀과 사다리 게임 ( 16928 )
- 게임은 정육면체 주사위를 사용하며, 주사위의 각 면에는 1부터 6까지 수가 하나씩 적혀있다. 게임은 크기가 10×10이고, 총 100개의 칸으로 나누어져 있는 보드판에서 진행된다
- 보드판에는 1부터 100까지 수가 하나씩 순서대로 적혀져 있다
- 플레이어는 주사위를 굴려 나온 수만큼 이동해야 한다
- 예를 들어, 플레이어가 i번 칸에 있고, 주사위를 굴려 나온 수가 4라면, i+4번 칸으로 이동해야 한다
- 만약 주사위를 굴린 결과가 100번 칸을 넘어간다면 이동할 수 없다
- 도착한 칸이 사다리면, 사다리를 타고 위로 올라간다
- 뱀이 있는 칸에 도착하면, 뱀을 따라서 내려가게 된다
- 즉, 사다리를 이용해 이동한 칸의 번호는 원래 있던 칸의 번호보다 크고, 뱀을 이용해 이동한 칸의 번호는 원래 있던 칸의 번호보다 작아진다
- 게임의 목표는 1번 칸에서 시작해서 100번 칸에 도착하는 것이다
- 게임판의 상태가 주어졌을 때, 100번 칸에 도착하기 위해 주사위를 굴려야 하는 횟수의 최솟값을 구해보자

```cpp
#include<bits/stdc++.h>
using namespace std;

int warp[102] = {0};
bool visited[102] = {0};
 
void game(int x, int c)
{
    queue<pair<int, int>> que;
    que.push(make_pair(x, c));
    
    while(!que.empty())
    {
        // 다음 위치 세팅
        int location = que.front().first;
        int cnt = que.front().second;
        que.pop();
 
        for (int i = 1; i <= 6;i++)
        {
            // 주사위 숫자만큼 이동
            int nx = location + i;
            
            // 도착 했다면 정답을 출력
            if(nx == 100)
            {
                cout << cnt+1;
                return;
            }
            else if(nx < 100)
            { 
                // 워프를 태울수 있을때 까지 태운다
                while(warp[nx] != 0)
                {
                    nx = warp[nx];
                }
                
                // 아직 방문한적 없는 노드라면 큐에 넣는다
                if(!visited[nx])
                {
                    que.push(make_pair(nx, cnt + 1));
                    visited[nx] = true;
                }
            }
        }
    }
}

int main()
{
    ios_base::sync_with_stdio(false); cout.tie(NULL); cin.tie(NULL);
    
    int sadari, snake;
    cin >> sadari >> snake;
    
    for (int i = 0; i < sadari;i++)
    {
        int from = 0, to = 0;
        cin >> from >> to; 
        warp[from] = to;
    }
    for (int i = 0; i < snake;i++)
    {
        int from = 0, to = 0;
        cin >> from >> to;
        warp[from] = to;
    }
    
    game(1, 0);
    return 0;
}
```

### 03-2 4연산 ( 14395 )
- 정수 s가 주어진다
- 정수 s의 값을 t로 바꾸는 최소 연산 횟수를 구하는 프로그램을 작성하시오

```cpp
#include<bits/stdc++.h>
using namespace std;

const long long MAX = 1e9;

set<long long> visited;

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);

    int start, target;
    cin >> start >> target;

    if(start == target)
    {
        cout << 0 << "\n";
        return 0;
    }
    
    // 필요한 변수 초기화
    queue<pair<long long, string>> que;
    que.push({start, ""});
    
    while (!que.empty())
    {
        // 다음 숫자 세팅
        long long n = que.front().first;
        string temp = que.front().second;
        que.pop();

        // 원하는 숫자라면 연산자 출력후 리턴
        if (n == target)
        {
            cout << temp << "\n";
            return 0;
        }

        // 현재 노드에서 방문할 수 있는 노드를 모두 큐에 담는다 ( https://twpower.github.io/92-how-to-use-set-in-cpp // count 함수에 대한 정보 )
        if (0 <= n * n && n * n <= MAX && visited.count(n*n) == 0 )
        {
            que.push({ n * n, temp + "*" });
            visited.insert(n*n);
        }
        if (0 <= n + n && n + n <= MAX && visited.count(n+n) == 0)
        {
            que.push({ n + n, temp + "+" });
            visited.insert(n + n);
        }
        if (0 <= n - n && n - n <= MAX && visited.count(n-n) == 0)
        {
            que.push({ n - n, temp + "-" });
            visited.insert(n - n);
        }
        if (n != 0 && 0 <= n / n && n / n <= MAX && visited.count(n/n) == 0)
        {
            que.push({ n / n, temp + "/" });
            visited.insert(n / n);
        }

    }
    
    // 변환이 불가능한 경우 -1을 출력한다
    cout << -1 << "\n";
    return 0;
}
```

### 03-3 물통 ( 2251 )
- 각각 부피가 A, B, C(1≤A, B, C≤200) 리터인 세 개의 물통이 있다
- 처음에는 앞의 두 물통은 비어 있고, 세 번째 물통은 가득(C 리터) 차 있다
- 이제 어떤 물통에 들어있는 물을 다른 물통으로 쏟아 부을 수 있는데, 이때에는 한 물통이 비거나, 다른 한 물통이 가득 찰 때까지 물을 부을 수 있다
- 이 과정에서 손실되는 물은 없다고 가정한다
- 이와 같은 과정을 거치다보면 세 번째 물통(용량이 C인)에 담겨있는 물의 양이 변할 수도 있다
- 첫 번째 물통(용량이 A인)이 비어 있을 때, 세 번째 물통(용량이 C인)에 담겨있을 수 있는 물의 양을 모두 구해내는 프로그램을 작성하시오

```cpp
#include<bits/stdc++.h>
using namespace std;

#define MAX 201
 
int CapacityA, CapacityB, CapacityC;
bool visited[MAX][MAX][MAX];
 
vector<int> answer;
 
void Input()
{
    cin >> CapacityA >> CapacityB >> CapacityC;
}
 
void Solution()
{
    // 필요한 변수 초기화
    queue<pair<pair<int, int>, int>> que;
    que.push(make_pair(make_pair(0, 0), CapacityC));
 
    while (que.empty() == 0)
    {
        // 다음 물높이 세팅
        int a = que.front().first.first;
        int b = que.front().first.second;
        int c = que.front().second;
        que.pop();
 
        // 해당 물높이 방문 처리
        if (visited[a][b][c] == true) continue;
        visited[a][b][c] = true;
 
        // 첫 번째 물통(용량이 A인)이 비어 있을 때, 세 번째 물통(용량이 C인)에 담겨있는 물의 양을 정답지에 넣는다
        if (a == 0) answer.push_back(c);
 
        // A물통에서 B물통으로 줄 때
        if (a + b > CapacityB) que.push(make_pair(make_pair(a + b - CapacityB, CapacityB), c));
        else que.push(make_pair(make_pair(0, a + b), c));
 
        // A물통에서 C물통으로 줄 때
        if (a + c > CapacityC) que.push(make_pair(make_pair(a + c - CapacityC, b), CapacityC));
        else que.push(make_pair(make_pair(0, b), a + c));
 
        // B물통에서 A물통으로 줄 때
        if (b + a > CapacityA) que.push(make_pair(make_pair(CapacityA, b + a - CapacityA), c));
        else que.push(make_pair(make_pair(b + a, 0), c));
 
        // B물통에서 C물통으로 줄 때
        if (b + c > CapacityC) que.push(make_pair(make_pair(a, b + c - CapacityC), CapacityC));
        else que.push(make_pair(make_pair(a, 0), b + c));
 
        // C물통에서 A물통으로 줄 때
        if (c + a > CapacityA) que.push(make_pair(make_pair(CapacityA, b), c + a - CapacityA));
        else que.push(make_pair(make_pair(c + a, b), 0));
 
        // C물통에서 B물통으로 줄 때
        if (c + b > CapacityB) que.push(make_pair(make_pair(a, CapacityB), c + b - CapacityB));
        else que.push(make_pair(make_pair(a, c + b), 0));
    }
 
    sort(answer.begin(), answer.end());

    for (int i = 0; i < answer.size(); i++)
    {
        cout << answer[i] << " ";
    }
}
 
void Solve()
{
    Input();
    Solution();
}
 
int main(void)
{
    ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    
    Solve();
 
    return 0;
}
```

### 03-4 점프 게임 ( 15558 )
- 각 칸의 정보가 주어졌을 때, 게임을 클리어 할 수 있는지, 없는지 구하는 프로그램을 작성하시오

```cpp
#include<bits/stdc++.h> 
using namespace std;

bool visited[2][100001];
 
struct node
{
    int x, y, y_limit;
};
 
int main()
{
    int N, K;
    cin >> N >> K;
    for (int i = 0; i < 2; i++)
    {
        for (int j = 0; j < N; j++)
        {
            char value;
            cin>>value;
            
            if(value == '0')
            {
                visited[i][j] = true;
            }
            else
            {
                visited[i][j] = false;
            }
        }
    }
 
    // 필요한 변수 초기화
    bool flag = false;
    queue<node> q;
    q.push({ 0,0,0 });
    visited[0][0] = 1;
 
    while (!q.empty())
    {
        // 다음 위치 세팅
        node cur = q.front();
        q.pop();
        int x = cur.x, y = cur.y, y_limit = cur.y_limit;
 
        // 목적지를 넘어서면 플래그를 true로 세팅한다
        if(y >= N)
            flag = true;
        
        //전진
        if (visited[x][y + 1] == 0)
        {
            visited[x][y + 1] = 1;
            q.push({ x, y + 1, y_limit + 1 });
        }
 
        //후진 
        if (visited[x][y - 1] == 0 && y - 1 > y_limit)
        {
            visited[x][y - 1] = 1;
            q.push({ x, y - 1, y_limit + 1 });
        }
        
        //점프
        if (y + K >= N)
            flag = true;
        else if (visited[1 - x][y + K] == 0)
        {
            visited[1 - x][y + K] = 1;
            q.push({ 1 - x, y + K, y_limit + 1 });
        }
 
    }
 
    // 플래그에 따라 결과 출력
    if (flag == false)
        cout << 0;
    else
        cout << 1;
}
```

<br>

## Chapter 04 그래프

### 04-1 경로 찾기 ( 11403 )
- 가중치 없는 방향 그래프 G가 주어졌을 때, 모든 정점 (i, j)에 대해서, i에서 j로 가는 경로가 있는지 없는지 구하는 프로그램을 작성하시오

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAX = 101;

int N;
int graph[MAX][MAX];

void floyd(void)
{
    for(int k = 0; k < N; ++k)
    {
        for(int x = 0; x < N; ++x)
        {
            for(int nx = 0; nx < N; ++nx)
            {
                // x에서 nx로 가는 길이 없어도 k를 거쳐갈 수 있으면 갈 수 있다고 여긴다
                if(graph[x][k] && graph[k][nx])
                    graph[x][nx] = 1;
            }
        }
    }
}

int main()
{
    cin >> N;
    
    for(int x = 0; x < N; ++x)
    {
        for(int nx = 0; nx < N; ++nx)
        {
            cin >> graph[x][nx];
        }
    }
    
    floyd();
    
    for(int x = 0; x < N; ++x)
    {
        for(int nx = 0; nx < N; ++nx)
        {
            cout << graph[x][nx] << " ";
        }
        cout << endl;
    }
}
```



<br>

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}
