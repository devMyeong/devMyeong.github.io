---
title:  "백준 ( 쉽고, 깔끔하고, 시간복잡도가 좋은 코드 )"

categories:
  - Algorithm
tags:
  - []

comments: true

toc: true
toc_sticky: true

date: 2022-09-25
last_modified_at: 2022-10-05
---

## Chapter 01 그리디

### 01-1 회의실 배정 ( 1931 )
- 한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다
- 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자
- 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다
- 회의의 시작시간과 끝나는 시간이 같을 수도 있다
- 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    int totalmeeting = 0;
    
    int meeting = 0;
    cin>>meeting;
    
    // 미팅 목록을 기록한다 ( 끝나는 시간 기준 정렬을 하기 위해, 끝나는 시간이 앞에 오게 저장한다 )
    vector<pair<int,int>> vMeeting;
    for(int i = 0; i < meeting; ++i)
    {
        int start = 0, end = 0;
        cin>>start>>end;
        vMeeting.push_back(make_pair(end,start));
    }
    sort(vMeeting.begin(), vMeeting.end());
    
    // 마지막 미팅 시간 이후 미팅 목록 중에서 가장 빠른 시간대를 예약한다
    int lastTime = 0;
    for(int i = 0; i < meeting; ++i)
    {
        if(lastTime <= vMeeting[i].second)
        {
            lastTime = vMeeting[i].first;
            totalmeeting = totalmeeting + 1;
        }
    }
    
    cout<<totalmeeting;
    
    return 0;
}
```

### 01-2 수 묶기 ( 1744 )
- 수열이 주어졌을 때, 수열의 각 수를 적절히 묶었을 때, 그 합이 최대가 되게 하는 프로그램을 작성하시오

```cpp
#include<bits/stdc++.h>
using namespace std;

int total, onecount, zerocount;
vector<int> positive;
vector<int> negative;

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    
    // 숫자들을 분류한다
    cin >> total;
    for (int i = 0; i < total; i++)
    {
        int value = 0;
        cin >> value;
        if (value > 1) positive.push_back(value);
        else if (value < 0) negative.push_back(value);
        else if (value == 0) zerocount++;
        else onecount++;
    }

    // 자리수를 맞춰준다
    if (positive.size() % 2 == 1)
        positive.push_back(1);
    if (negative.size() % 2 == 1)
    {
        if (zerocount == 0) negative.push_back(1);
        else negative.push_back(0);
    }

    // 양수는 오름차순 음수는 내림차순으로 정렬한다
    sort(positive.begin(), positive.end());
    sort(negative.rbegin(), negative.rend());

    // 두개씩 계산한다
    int sum = onecount;
    for (int i = 0; i < positive.size(); i += 2) 
        sum += positive[i] * positive[i + 1];
    for (int i = 0; i < negative.size(); i += 2)
        sum += negative[i] * negative[i + 1];
    
    cout << sum;
}
```

### 01-3 A와 B ( 12904 )
- 주어진 조건을 이용해서 S를 T로 만들 수 있는지 없는지 알아내는 프로그램을 작성하시오

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    string S = "", T = "";
    cin>>S;
    cin>>T;
    
    while(true)
    {
        if(T.size() == S.size())
        {
            if(S == T)
            {
                cout << 1 << endl;
                break;
            }
            else
            {
                cout << 0 << endl;
                break;
            }
        }
        
        // 문자열 T를 문자열 S로 역변환해 문제를 해결한다
        if(T[T.size()-1] == 'A')
        {
            T.pop_back();
            continue;
        }
        else if(T[T.size()-1] == 'B')
        {
            T.pop_back();
            reverse(T.begin(), T.end());
            continue;
        }
        
        cout << 0 << endl;
        break;
    }
}
```

<br>

## Chapter 02 DFS

### 02-1 일곱 난쟁이 ( 2309 )
- 왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다
- 일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다
- 아홉 명의 난쟁이는 모두 자신이 "백설 공주와 일곱 난쟁이"의 주인공이라고 주장했다
- 뛰어난 수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다
- 아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오

```cpp
#include <bits/stdc++.h>
using namespace std;

int cnt = 0, sum = 0, value[10], check[10];

void dfs(int l)
{
    // 카운트가 7이라면 난쟁이 키의 합이 100인지 확인하자
    if(cnt == 7)
    {
        if(sum == 100)
        {
            for(int i = 1; i <= 9; ++i)
            {
                if(check[i] == 1)
                    cout << value[i] << endl;
            }
            exit(0);
        }
        
        return;
    }
    
    // 레벨의 끝에 도달했다면 리턴하자
    if(l==10)
        return;
    else
    {
        // 레벨의 끝이 아니고 현재 인덱스를 더하는 경우
        sum = sum + value[l];
        check[l] = 1;
        cnt++;
        dfs(l + 1);
        
        // 레벨의 끝이 아니고 현재 인덱스를 더하지 않는 경우
        sum = sum - value[l];
        check[l] = 0;
        cnt--;
        dfs(l+1);
    }
}

int main(void)
{
    ios_base::sync_with_stdio(false);
    cout.tie(NULL);
    cin.tie(NULL);
    
    for (int i = 1;i <= 9;i++)
        cin >> value[i];
    
    sort(value + 1, value + 10);
    
    dfs(1);
    
    return 0;
}
```

### 02-2 1, 2, 3 더하기 ( 9095 )
- 정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오

```cpp
#include <bits/stdc++.h>
using namespace std;

int answer = 0;

void dfs(int target, int sum)
{
    // 타겟이 맞는지 체크
    if(target <= sum)
    {
        if(target == sum)
        {
            answer++;
        }
        
        return;
    }
    
    // 경로 1
    dfs(target, sum + 1);
    // 경로 2
    dfs(target, sum + 2);
    // 경로 3
    dfs(target, sum + 3);
}

int main()
{
    ios_base::sync_with_stdio(false);
    cout.tie(NULL);
    cin.tie(NULL);
    
    int TestCase = 0;
    vector<int> vTestCase;
    cin>>TestCase;
    
    for(int i = 0; i < TestCase; ++i)
    {
        int value = 0;
        cin>>value;
        vTestCase.push_back(value);
    }
    
    for(int i = 0; i < vTestCase.size(); ++i)
    {
        dfs(vTestCase[i], 0);
        cout<<answer<<endl;
        answer = 0;
    }
    
    return 0;
}
```

### 02-3 에너지 모으기 ( 16198 )
- N과 에너지 구슬의 무게가 주어졌을 때, 모을 수 있는 에너지 양의 최댓값을 구하는 프로그램을 작성하시오

```cpp
#include<bits/stdc++.h>
using namespace std;

int max_energe = 0;

void dfs(vector<int> vBall, int erasenumber, int sum_energe)
{
    if(vBall.size() == 2)
    {
        return;
    }
    
    // MAX 에너지 갱신
    int current_energe = sum_energe + (vBall[erasenumber - 1] * vBall[erasenumber + 1]);
    vBall.erase(vBall.begin()+erasenumber);
    if(max_energe <= current_energe)
        max_energe = current_energe;
    
    // 두번째 이후 에너지 구슬 선택
    for(size_t erasenumber = 1; erasenumber < vBall.size() - 1; ++erasenumber)
    {
        dfs(vBall, erasenumber, current_energe);
    }
}

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    
    int ball = 0;
    cin >> ball;
    
    vector<int> vBall;
    for(int i = 0; i < ball; ++i)
    {
        int value = 0;
        cin >> value;
        vBall.push_back(value);
    }
    
    // 첫번째 에너지 구슬 선택
    for(size_t erasenumber = 1; erasenumber < ball - 1; ++erasenumber)
    {
        dfs(vBall, erasenumber, 0);
    }
    
    cout << max_energe << endl;
    
    return 0;
}
```

### 02-4 파이프 옮기기 1 ( 17070 )
- 파이프의 한쪽 끝을 (N, N)로 이동시키는 방법의 개수를 구해보자

```cpp
#include<bits/stdc++.h>
using namespace std;
    
int visited[20][20];

void dfs(int y, int x, int dir, int housecount)
{
    visited[y][x] = visited[y][x] + 1;
    
    // 경로 1
    if(dir == 0 || dir == 2)
    {
        if(x < housecount && visited[y][x+1] != -1)
        {
            dfs(y, x+1, 0, housecount);
        }
    }
    // 경로 2
    if(dir == 1 || dir == 2)
    {
        if(y < housecount && visited[y+1][x] != -1)
        {
            dfs(y+1, x, 1, housecount);
        }
    }
    // 경로 3
    if(x < housecount && y < housecount && visited[y][x+1] != -1 && visited[y+1][x] != -1 && visited[y+1][x+1] != -1)
    {
        dfs(y+1, x+1, 2, housecount);
    }
    
    return;
}

int main()
{
    int housecount = 0;
    cin >> housecount;
    
    for(int i = 1; i <= housecount; i++)
    for(int j = 1; j <= housecount; j++)
    {
        int value = 0;
        cin >> value;
        if(value == 0)
        {
            visited[i][j] = 0;
        }
        else
        {
            visited[i][j] = -1;
        }
	}
    
    dfs(1,2,0,housecount);
    
    if(visited[housecount][housecount] != -1) cout << visited[housecount][housecount] << endl;
    else cout << 0 << endl;
}
```

### 02-5 암호 만들기 ( 1759 )
- 가능성 있는 암호들을 모두 구하는 프로그램을 작성하시오

```cpp
#include<bits/stdc++.h>
using namespace std;

void dfs(vector<char> vChar, int L, int C, int level, int length, string curstr)
{
    // 문자열 길이 체크
    if(length == L)
    {
        int mo = 0, ja = 0;
        for(int i = 0; i < L; ++i)
        {
            if(curstr[i] == 'a' || curstr[i] == 'e' || curstr[i] == 'i' || curstr[i] == 'o' || curstr[i] == 'u' )
                mo++;
            ja = L - mo;
        }
        
        if(1 <= mo && 2 <= ja)
            cout << curstr << endl;
        
        return;
    }
    
    // 문자열 레벨 체크
    if(level == C)
    {
        return;
    }
    else
    {
        // 문자열을 추가해주는 경우
        dfs(vChar, L, C, level + 1, length + 1, curstr + vChar[level]);
        // 문자열을 추가해주지 않는 경우
        dfs(vChar, L, C, level + 1, length, curstr);
    }
}

int main()
{
    int L = 0, C = 0;
    cin >> L >> C;
    
    vector<char> vChar;
    for(int i = 0; i < C; ++i)
    {
        char value;
        cin >> value;
        vChar.push_back(value);
    }
    
    sort(vChar.begin(), vChar.end());
    
    dfs(vChar, L, C, 0, 0, "");
    
    return 0;
}
```

<br>

## Chapter 03 BFS

### 03-1 뱀과 사다리 게임 ( 16928 )
- 게임은 정육면체 주사위를 사용하며, 주사위의 각 면에는 1부터 6까지 수가 하나씩 적혀있다. 게임은 크기가 10×10이고, 총 100개의 칸으로 나누어져 있는 보드판에서 진행된다
- 보드판에는 1부터 100까지 수가 하나씩 순서대로 적혀져 있다
- 플레이어는 주사위를 굴려 나온 수만큼 이동해야 한다
- 예를 들어, 플레이어가 i번 칸에 있고, 주사위를 굴려 나온 수가 4라면, i+4번 칸으로 이동해야 한다
- 만약 주사위를 굴린 결과가 100번 칸을 넘어간다면 이동할 수 없다
- 도착한 칸이 사다리면, 사다리를 타고 위로 올라간다
- 뱀이 있는 칸에 도착하면, 뱀을 따라서 내려가게 된다
- 즉, 사다리를 이용해 이동한 칸의 번호는 원래 있던 칸의 번호보다 크고, 뱀을 이용해 이동한 칸의 번호는 원래 있던 칸의 번호보다 작아진다
- 게임의 목표는 1번 칸에서 시작해서 100번 칸에 도착하는 것이다
- 게임판의 상태가 주어졌을 때, 100번 칸에 도착하기 위해 주사위를 굴려야 하는 횟수의 최솟값을 구해보자

```cpp
#include<bits/stdc++.h>
using namespace std;

int warp[102] = {0};
bool visited[102] = {0};
 
void game(int x, int c)
{
    queue<pair<int, int>> que;
    que.push(make_pair(x, c));
    
    while(!que.empty())
    {
        // 다음 위치 세팅
        int location = que.front().first;
        int cnt = que.front().second;
        que.pop();
 
        for (int i = 1; i <= 6;i++)
        {
            // 주사위 숫자만큼 이동
            int nx = location + i;
            
            // 도착 했다면 정답을 출력
            if(nx == 100)
            {
                cout << cnt+1;
                return;
            }
            else if(nx < 100)
            { 
                // 워프를 태울수 있을때 까지 태운다
                while(warp[nx] != 0)
                {
                    nx = warp[nx];
                }
                
                // 아직 방문한적 없는 노드라면 큐에 넣는다
                if(!visited[nx])
                {
                    que.push(make_pair(nx, cnt + 1));
                    visited[nx] = true;
                }
            }
        }
    }
}

int main()
{
    ios_base::sync_with_stdio(false); cout.tie(NULL); cin.tie(NULL);
    
    int sadari, snake;
    cin >> sadari >> snake;
    
    for (int i = 0; i < sadari;i++)
    {
        int from = 0, to = 0;
        cin >> from >> to; 
        warp[from] = to;
    }
    for (int i = 0; i < snake;i++)
    {
        int from = 0, to = 0;
        cin >> from >> to;
        warp[from] = to;
    }
    
    game(1, 0);
    return 0;
}
```

### 03-2 4연산 ( 14395 )
- 정수 s가 주어진다
- 정수 s의 값을 t로 바꾸는 최소 연산 횟수를 구하는 프로그램을 작성하시오

```cpp
#include<bits/stdc++.h>
using namespace std;

const long long MAX = 1e9;

set<long long> visited;

int main()
{
    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);

    int start, target;
    cin >> start >> target;

    if(start == target)
    {
        cout << 0 << "\n";
        return 0;
    }
    
    // 필요한 변수 초기화
    queue<pair<long long, string>> que;
    que.push({start, ""});
    
    while (!que.empty())
    {
        // 다음 숫자 세팅
        long long n = que.front().first;
        string temp = que.front().second;
        que.pop();

        // 원하는 숫자라면 연산자 출력후 리턴
        if (n == target)
        {
            cout << temp << "\n";
            return 0;
        }

        // 현재 노드에서 방문할 수 있는 노드를 모두 큐에 담는다 ( https://twpower.github.io/92-how-to-use-set-in-cpp // count 함수에 대한 정보 )
        if (0 <= n * n && n * n <= MAX && visited.count(n*n) == 0 )
        {
            que.push({ n * n, temp + "*" });
            visited.insert(n*n);
        }
        if (0 <= n + n && n + n <= MAX && visited.count(n+n) == 0)
        {
            que.push({ n + n, temp + "+" });
            visited.insert(n + n);
        }
        if (0 <= n - n && n - n <= MAX && visited.count(n-n) == 0)
        {
            que.push({ n - n, temp + "-" });
            visited.insert(n - n);
        }
        if (n != 0 && 0 <= n / n && n / n <= MAX && visited.count(n/n) == 0)
        {
            que.push({ n / n, temp + "/" });
            visited.insert(n / n);
        }

    }
    
    // 변환이 불가능한 경우 -1을 출력한다
    cout << -1 << "\n";
    return 0;
}
```

### 03-3 물통 ( 2251 )
- 각각 부피가 A, B, C(1≤A, B, C≤200) 리터인 세 개의 물통이 있다
- 처음에는 앞의 두 물통은 비어 있고, 세 번째 물통은 가득(C 리터) 차 있다
- 이제 어떤 물통에 들어있는 물을 다른 물통으로 쏟아 부을 수 있는데, 이때에는 한 물통이 비거나, 다른 한 물통이 가득 찰 때까지 물을 부을 수 있다
- 이 과정에서 손실되는 물은 없다고 가정한다
- 이와 같은 과정을 거치다보면 세 번째 물통(용량이 C인)에 담겨있는 물의 양이 변할 수도 있다
- 첫 번째 물통(용량이 A인)이 비어 있을 때, 세 번째 물통(용량이 C인)에 담겨있을 수 있는 물의 양을 모두 구해내는 프로그램을 작성하시오

```cpp
#include<bits/stdc++.h>
using namespace std;

#define MAX 201
 
int CapacityA, CapacityB, CapacityC;
bool visited[MAX][MAX][MAX];
 
vector<int> answer;
 
void Input()
{
    cin >> CapacityA >> CapacityB >> CapacityC;
}
 
void Solution()
{
    queue<pair<pair<int, int>, int>> que;
    que.push(make_pair(make_pair(0, 0), CapacityC));
 
    while (que.empty() == 0)
    {
        int a = que.front().first.first;
        int b = que.front().first.second;
        int c = que.front().second;
        que.pop();
 
        if (visited[a][b][c] == true) continue;
        visited[a][b][c] = true;
 
        if (a == 0) answer.push_back(c);
 
        // A물통에서 B물통으로 줄 때
        if (a + b > CapacityB) que.push(make_pair(make_pair(a + b - CapacityB, CapacityB), c));
        else que.push(make_pair(make_pair(0, a + b), c));
 
        // A물통에서 C물통으로 줄 때
        if (a + c > CapacityC) que.push(make_pair(make_pair(a + c - CapacityC, b), CapacityC));
        else que.push(make_pair(make_pair(0, b), a + c));
 
        // B물통에서 A물통으로 줄 때
        if (b + a > CapacityA) que.push(make_pair(make_pair(CapacityA, b + a - CapacityA), c));
        else que.push(make_pair(make_pair(b + a, 0), c));
 
        // B물통에서 C물통으로 줄 때
        if (b + c > CapacityC) que.push(make_pair(make_pair(a, b + c - CapacityC), CapacityC));
        else que.push(make_pair(make_pair(a, 0), b + c));
 
        // C물통에서 A물통으로 줄 때
        if (c + a > CapacityA) que.push(make_pair(make_pair(CapacityA, b), c + a - CapacityA));
        else que.push(make_pair(make_pair(c + a, b), 0));
 
        // C물통에서 B물통으로 줄 때
        if (c + b > CapacityB) que.push(make_pair(make_pair(a, CapacityB), c + b - CapacityB));
        else que.push(make_pair(make_pair(a, b + c), 0));
    }
 
    sort(answer.begin(), answer.end());
    for (int i = 0; i < answer.size(); i++)
    {
        cout << answer[i] << " ";
    }
    cout << endl;
}
 
void Solve()
{
    Input();
    Solution();
}
 
int main(void)
{
    ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    
    Solve();
 
    return 0;
}
```

### 03-4 점프 게임 ( 15558 )
- 각 칸의 정보가 주어졌을 때, 게임을 클리어 할 수 있는지, 없는지 구하는 프로그램을 작성하시오

```cpp
#include<bits/stdc++.h> 
using namespace std;

bool visited[2][100001];
 
struct node
{
    int x, y, y_limit;
};
 
int main()
{
    int N, K;
    cin >> N >> K;
    for (int i = 0; i < 2; i++)
    {
        for (int j = 0; j < N; j++)
        {
            char value;
            cin>>value;
            
            if(value == '0')
            {
                visited[i][j] = true;
            }
            else
            {
                visited[i][j] = false;
            }
        }
    }
 
    // 필요한 변수 초기화
    bool flag = false;
    queue<node> q;
    q.push({ 0,0,0 });
    visited[0][0] = 1;
 
    while (!q.empty())
    {
        // 다음 위치 세팅
        node cur = q.front();
        q.pop();
        int x = cur.x, y = cur.y, y_limit = cur.y_limit;
 
        // 목적지를 넘어서면 리턴
        if(y >= N)
            flag = true;
        
        //전진
        if (visited[x][y + 1] == 0)
        {
            visited[x][y + 1] = 1;
            q.push({ x, y + 1, y_limit + 1 });
        }
 
        //후진 
        if (visited[x][y - 1] == 0 && y - 1 > y_limit)
        {
            visited[x][y - 1] = 1;
            q.push({ x, y - 1, y_limit + 1 });
        }
        
        //점프
        if (y + K >= N)
            flag = true;
        else if (visited[1 - x][y + K] == 0)
        {
            visited[1 - x][y + K] = 1;
            q.push({ 1 - x, y + K, y_limit + 1 });
        }
 
    }
 
    // 플래그 처리
    if (flag == false)
        cout << 0;
    else
        cout << 1;
}
```

<br>

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}
