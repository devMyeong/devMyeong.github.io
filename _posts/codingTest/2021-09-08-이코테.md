---
title:  "이것이 취업을 위한 코딩 테스트다"

categories:
  - Algorithm
tags:
  - []

comments: true

toc: true
toc_sticky: true

date: 2021-09-08
last_modified_at: 2021-09-08
---

## Chapter 03 그리디

### 03-1 당장 좋은 것만 선택하는 그리디
- 현재 상황에서 지금 당장 좋은 것만 고르는 방법
- 그리디 알고리즘은 기준에 따라 좋은 것을 선택하는 알고리즘이므로 문제에서 <u>가장 큰 순서대로, 가장 작은 순서대로</u>와 같은 기준을 알게 모르게 제시해준다

```cpp
// 거스름돈
// 시간 복잡도는 O(K)
#include <bits/stdc++.h>

using namespace std;

int n = 1260;
int cnt = 0;
int coinTypes[4] = {500, 100, 50, 10};

int main() {
    for (int i = 0; i < 4; i++) {
        int coin = coinTypes[i];
        cnt += n / coin;
        n %= coin;
    }
    cout << cnt << '\n';
}
```

```cpp
// 1이 될 때까지
#include <bits/stdc++.h>

using namespace std;

int n, k;
int result;

int main() {
    // N, K를 공백을 기준으로 구분하여 입력 받기
    cin >> n >> k;

    while (true) {
        // N이 K로 나누어 떨어지는 수가 될 때까지만 1씩 빼기
        int target = (n / k) * k;
        result += (n - target);
        n = target;
        // N이 K보다 작을 때 (더 이상 나눌 수 없을 때) 반복문 탈출
        if (n < k) break;
        // K로 나누기
        result += 1;
        n /= k;
    }

    // 마지막으로 남은 수에 대하여 1씩 빼기
    result += (n - 1);
    cout << result << '\n';
}
```

- 그리디 알고리즘으로 문제의 해법을 찾았을 때는 그 해법이 정당한지 검토해야 한다
- 그리디 알고리즘으로 해결 방법을 찾을 수 없다면, 그때는 이후의 장에서 다루게 될 다이나믹 프로그래밍이나 그래프 알고리즘 등으로 문제를 해결할 수 있는지를 재차 고민해보자

<br>

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}
