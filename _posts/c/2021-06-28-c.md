---
title:  "혼자 공부하는 C언어" 

categories:
  - C
tags:
  - []

toc: true
toc_sticky: true

date: 2021-06-28
last_modified_at: 2021-07-04
---

## Chapter 01 프로그램 만들기

### 01-1 프로그램과 C언어
- C언어는 <u>유닉스 시스템</u>에 사용하기 위해 만들었다
- C언어의 장점으로는 <u>시스템 프로그래밍</u>이 가능하다는 점이 있다

### 01-2 컴파일과 컴파일러 사용법
- 비주얼 스튜디오가 엄격한 검사 기능을 사용하지 않도록 제한하는 템플릿을 만드는게 좋다
- 컴파일 과정 3단계는 전처리 - 컴파일 - 링크

<br>

## Chapter 02 상수와 데이터 출력

### 02-1 C 프로그램의 구조와 데이터 출력 방법
- 함수는 일정한 기능을 수행하는 코드 단위
- 함수 head는 함수 원형이라고 하며 함수의 이름과 필요한 데이터 등을 표시
- 제어 문자란 출력 방식에 영향을 주는 문자

### 02-2 상수와 데이터 표현 방법
- 코드에서 8진수는 숫자앞에 0, 16진수는 0x를 붙여 표현
- e는 밑수 10을 의미하며 대문자로 쓸 수도 있다 ex) 3.14e-5
- <u>정규화 표기법</u> 이란 소수점 앞에 0이 아닌 유효숫자 한 자리를 사용하여 지수 형태로 바꾼것
- 소수를 지수 형태로 출력하라면 <u>%le 변환문자</u> 사용
- 상수의 크기는 컴파일러에 따라 다르므로 sizeof 연산자를 통해 확인하자
- 음수를 2의 보수로 처리하는 이유는 <u>특별한 과정없이 바로 양수와 음수를 더할 수 있기 때문</u>
- 실수는 제한된 데이터 크기에 수를 표현하기 위해 <u>IEEE 754 표준</u>을 따른다

<br>

## Chapter 03 변수와 데이터 입력

### 03-1 변수
- short형은 int형보다 크기가 작아 메모리를 적게 사용하지만, 연산 과정에서 int형으로 변환되므로 <u>실행 속도가 느려질 수 있다</u>
- unsigned 자료형은 양수만 저장하고 <u>%u를 통해 출력하기를 권고</u>
- float형은 <u>유효숫자 7자리</u>, double형은 <u>15자리</u> 라는것을 참고
- <u>배열명은 주소 상수</u> 이므로 변수만 가능한 대입 연산자의 왼쪽에 쓸 수 없다
- char 배열에 초기화 이외에 문자열을 저장할 때는 strcpy함수 이용

### 03-2 데이터 입력
- VS++ 2019 컴파일러는 시스템 보안 문제 때문에 메모리에 직접 접근하는 함수를 사용하면 에러 메시지를 띄우니, 시스템 보안 검사 기능을 제한하는 속성을 적용해야 한다
- 만약 변환문자와 다른 예상치 못한 데이터가 scanf 함수를 통해 입력되면 변환을 포기하고 실행을 중단하는데 이경우 변수값이 입력되지 않으므로 <u>이전에 변수에 있던 값이 계속 사용됨</u>
- scanf_s 함수는 배열의 크기 까지만 문자열을 입력하도록 제한한다

<br>

## Chapter 04 연산자

### 04-1 산술 연산자, 관계 연산자, 논리 연산자
- 일반적으로 연산자는 컴파일되면 명령어로 바뀌므로 연산자를 배우는 것은 결국 명령어를 익히는 것이다
- 하나의 수식에서 같은 변수를 두 번 이상 사용할 때는 그 변수에 <u>증감 연산자를 사용하면 안된다</u> ex) (++a) + a + (++a)
- 숏 서킷 룰이란? 좌항만으로 AND와 OR 연산 결과를 판별하는 기능
- 연산을 하려면 메모리에 있는 a와 b의 값을 CPU의 저장 공간인 레지스터에 복사해야 하며 이과정을 <u>로드</u>라 한다
- 데이터가 레지스터에 저장되면 연산장치인 ALU에 의해 연산이 수행된다

### 04-2 그외 유용한 연산자
- 자료형의 크기는 <u>컴파일러나 CPU</u>에 따라 다를 수 있다
- 대입 연산자와 복합대입 연산자의 특징은 왼쪽 피연산자는 반드시 변수가 와야 한다는점
- 복합대입 연산자는 <u>저장되는 공간과 연산되는 공간이 다르다</u>는 개념을 이해하자
- 비트연산자를 사용해보면 값을 왼쪽으로 한 비트씩 이동할 때마다 <u>2가 곱해짐</u>을 알 수 있다

<br>

## Chapter 05 선택문

### 05-1 if문
- 2개의 실행문 중에 하나를 선택하는 경우에는 주저없이 if-else 문을 사용하자

### 05-2 if문 활용과 switch ~ case문
- if문은 선행조건이 참인 경우만 다음 조건을 따진다는 점을 활용해 불필요한 연산을 줄일 수 있다
- <u>분할 정복 기법등</u>을 구현할때 유용하게 사용할 수 있다
- switch문의 case에 사용하는 상수식은 정수만 가능

<br>

## Chapter 06 반복문

### 06-1 while문, for문, do ~ while문
- while문은 반복 문장을 실행하기 전에 반복 조건을 먼저 검사한다
- for문은 반복 횟수가 정해진 경우 사용하면 편리하다

### 06-2 반복문 활용
- continue를 사용하면 조건에 따라 반복문의 일부를 제외하고 반복할 수 있다 ex) 3의 배수를 빼고 1부터 100까지의 합을 구할 때

<br>

## Chapter 07 함수

### 07-1 함수의 작성과 사용
- 함수를 만들기 전에 고려해야할 사항은 <u>함수 기능에 맞는 이름, 함수가 기능을 수행하는데 필요한 데이터, 함수가 수행된 후 결과</u>
- 컴파일러는 변수명의 사용범위를 선언한 블록 내부로 제한한다
- 실행 순서는 함수호출 -> 연산자 순이다
- 컴파일러는 컴파일할 때 함수를 호출한 자리에 <u>반환값과 같은 형태의 저장 공간</u>을 준비한다

### 07-2 여러 가지 함수 유형
- 반환형이 void인 함수는 컴파일러가 반환값이 없다고 가정하여 호출한 위치에 반환값을 저장할 공간을 준비하지 않는다
- 함수가 무한으로 호출되면 프로그램 하나가 쓸 수 있는 <u>메모리( 해당 프로세스에 할당된 스택 메모리 )</u>를 모두 사용하여 강제 종료된다
- 재귀호출 함수는 최초 호출한 곳이 아니라 <u>이전에 호출했던 곳</u>으로 돌아간다
- 재귀호출은 하나의 함수에서 코드를 반복 실행하는 듯하지만 실제로는 새로운 함수를 실행하는 것과 같다

<br>

## Chapter 08 배열

### 08-1 배열의 선언과 사용
- 배열 요소의 개수는 다음과 같이 구한다 sizeof(배열명) / sizeof(배열 요소)

### 08-2 문자를 저장하는 배열
- 널 문자를 저장하기 위해 저장할 문자열의 길이보다 최소한 하나 이상 크게 배열을 선언하자
- strcpy 함수는 char형 배열에 새로운 문자열을 저장하는 함수로, 저장할 문자열의 길이를 파악하여 딱 그 길이만큼만 char형 배열에 복사한다
- 대입연산자 왼쪽에 배열명이 올 수 없음을 기억하자
- gets 함수는 빈칸을 포함하여 한 줄 전체를 문자열로 입력한다
- gets 함수는 입력할 배열의 크기를 검사하지 않는다 즉 <u>메모리 영역을 침범할 가능성</u>이 있다
- char형 배열에 문자를 하나씩 대엽하여 직접 문자열을 만드는 경우에는 문자열의 맨 끝에 널 문자를 저장하는 것을 잊지말자

<br>

## Chapter 09 포인터

### 09-1 포인터의 기본 개념
- 포인터는 코드블록 벗어난 경우에도 데이터를 공유할 수 있도록 해준다
- 메모리의 위치를 식별하는 주소값은 바이트 단위로 구분된다
- 2바이트 이상 크기를 갖는 변수는 여러 개의 주소 값에 걸쳐 할당된다
- 시작 주소는 연산자 &를 사용해서 구한다
- 주소는 보통 16진수로 표기한다 따라서 주소를 출력할 때는 전용 문자인 %p를 사용하는 것이 좋다
- 주소를 저장할 포인터도 변수처럼 선언하고 사용한다 다만 선언할 때 변수 앞에 *만 붙여주면 된다
- x -> y의 의미는 x는 포인터이며 변수 y의 주소를 저장하고 있다는 뜻이다
- `*pa 는 a`와 같으므로 `&a는 &*pa`와 같다
- `const int *pa = &a` 에서 사용된 const의 의미는 pa가 가르키는 변수 a는 pa를 간접 참조하여 바꿀 수 없다는 것이다
- 포인터에 const를 사용하는 대표적인 예는 문자열 상수를 인수로 받는 함수

### 09-2 포인터 완전 정복을 위한 포인터 이해하기
- 주소는 <u>상수</u>이고 포인터는 <u>변수</u>이다
- 포인터의 크기는 컴파일러에 따라 다를 수 있으나 모든 주소와 포인터는 가리키는 자료형과 상관없이 그 크기가 같다
- 포인터는 가리키는 변수의 형태가 같을 때만 대입해야 한다
- 형 변환을 사용한 <u>포인터의 대입은 언제나 가능</u>하나, 정상적으로 할당받은 메모리 공간의 주소를 저장해서 사용하자
- 포인터를 초기화 하지 않는 행위는 매우 위험하다
- 함수는 오직 하나의 값만을 반환할 수 있으므로 한 번의 함수 호출을 통해 두 변수의 값을 바꾸는 것은 불가능하다
- 포인터의 주요 기능 중 하나는 함수 간에 효과적으로 데이터를 <u>공유</u>하는 것이다

<br>

## Chapter 10 배열과 포인터

### 10-1 배열과 포인터의 관계
- 컴파일러는 첫 번째 배열 요소의 주소를 쉽게 사용하도록 배열명을 컴파일 과정에서 첫 번째 배열 요소의 주소로 변경한다
- 배열명은 첫 번째 배열 요소의 주소 값 이라는 것을 명심하자
- 주소 + 정수 연산은 주소 + ( 정수 * 주소를 구한 변수의 크기 )로 수행된다
- 배열 `ary+2`는 `&ary[2]`와 같다
- 대괄호[]는 포인터 연산의 간접참조, 괄호, 더하기 기능을 갖는다 ( 배열 요소에 사용하는 대괄호는 연산식이다 )
- 배열 요소 표현식 `ary[1]`은 포인터 연산식 `*(ary + 1)`과 같다
- 배열과 포인터의 차이는 첫째 sizeof 연산의 결과가 다르다 둘째 변수와 상수의 차이가 있다
- `*(pa++)`에서 컴파일러는 pa가 증가되기 이전 값을 임시공간에 저장해두었다가 간접 참조 연산에 사용한다
- 배열명은 주소 상수로 그 값이 바뀌지 않으므로 언제든지 배열의 시작 위치를 찾아갈 때 사용할 수 있다
- `++(*pa)`의 경우 pa의 값 자체는 바뀌지 않으며 pa가 가르키는 배열 요소의 값이 증가한다
- 포인터 - 포인터 -> 값의 차 / 가리키는 자료형의 크기

<br>

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}