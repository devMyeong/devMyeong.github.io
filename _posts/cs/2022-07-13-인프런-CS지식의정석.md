---
title:  "CS지식의 정석" 

categories:
  - Interview
tags:
  - []

comments: true

toc: true
toc_sticky: true

date: 2022-07-13
last_modified_at: 2022-07-22
---

## Chapter 02 네트워크

### 02-1 네트워크의 기초 #1 처리량, 지연시간
- 노드란 서버, 라우터, 스위치 등 네트워크 장치를 의미한다
- 스위치는 데이터의 목적지를 파악하여 적합한 경로로 스위칭 해주는 역할을 한다
- 라우터는 자신이 보유한 정보를 토대로 목적지까지의 적합한 경로를 찾아주는 라우팅 기능을 한다
- 스위치는 데이터 링크 계층에, 라우터는 네트워크 계층에 속한다 그래서 스위치는 MAC 주소를 기반으로 작동하고, 라우터는 IP주소를 기반으로 작동한다
- 링크는 유선 또는 무선을 의미한다

![network](https://user-images.githubusercontent.com/80055816/183006706-3ffaf87f-df19-4346-8029-b24cc3942f8b.png){: width="70%" height="70%"}{: .align-center}

### 02-2 네트워크의 기초 #2 네트워크 토폴로지와 병목현상
- 네트워크 토폴로지는 노드와 링크가 어떻게 배치되어 있는지에 대한 방식이자 연결 형태를 의미한다
- 스푸핑이란 데이터를 탈취 당하는것을 의미한다
- 스타 토폴로지는 장애 노드가 중앙 노드가 아닐 경우 다른 노드에 영향을 끼치는 것이 적다
- 링형 토폴로지는 네트워크 구성 변경이 어렵고 회선에 장애가 발생하면 전체 네트워크에 영향을 끼치는 단점이 있다
- 메시 토폴로지는 한 단말 장치에 장애가 발생해도 여러 개의 경로가 존재하므로 네트워크를 계속 사용할 수 있고 트래픽도 분산처리가 가능하다 하지만 노드의 추가가 어렵고 구축 비용과 운용 비용이 고가인 단점이 있다
- 네트워크가 어떤 토폴로지를 갖는지, 또한 어떠한 경로로 이루어져 있는지 알아야 회선을 추가하여 병목현상을 해결할 수 있다

### 02-3 네트워크의 기초 #3 LAN, MAN, WAN
- LAN은 같은 건물이나 캠퍼스 같은 좁은 공간에서 운영된다
- MAN은 대도시 지역 네트워크를 나타내며 도시 같은 넓은 지역에서 운영된다
- WAN은 광역 네트워크를 의미하며 국가 또는 대륙 같은 더 넓은 지역에서 운영된다

<br>

## Chapter 03 운영체제

### 03-1 운영체제와 컴퓨터 그리고 인터럽트
- 운영체제의 역할은 크게 네가지가 있다
- CPU 스크줄링과 프로세스 관리 : CPU 소유권을 어떤 프로세스에 할당할지, 프로세스의 생성과 삭제, 자원 할당 및 반환을 관리
- 메모리 관리 : 한정된 메모리를 어떤 프로세스에 얼만큼 할당해야 하는지 관리
- 디스크 파일 관리 : 디스크 파일을 어떠한 방법으로 보관할지 관리
- I/O 디바이스 관리 : I/O 디바이스들인 마우스, 키보드와 컴퓨터 간에 데이터를 주고받는 것을 관리
- 운영체제의 구조는 GUI, 시스템콜, 커널, 드라이버가 핵심이다
- GUI : 사용자가 전자장치와 상호 작용할 수 있도록 하는 사용자 인터페이스의 한 형태
- 시스템콜 : 운영체제가 커널에 접근하기 위한 인터페이스이며 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 쓴다, 유저 프로그램이 I/O 요청으로 트랩(trap)을 발동하면 올바른 I/O 요청인지 확인한 후 유저 모드가 시스템콜을 통해 커널 모드로 변환되어 실행된다
- 커널 : 운영체제의 핵심 부분이자 시스템콜 인터페이스를 제공하며 보안, 메모리, 프로세스, 파일 시스템, I/O 디바이스, I/O 요청 관리 등 운영체제의 중추적인 역할을 한다
- 드라이버 : 하드웨어를 제어하기 위한 소프트웨어
- 컴퓨터는 CPU, DMA 컨트롤러, 메모리, 타이머, 디바이스 컨트롤러 등으로 이루어져 있다
- CPU : 산술논리연산장치, 제어장치, 레지스터로 구성되어 있는 컴퓨터 장치이며 <u>인터럽트에</u> 의해 단순히 메모리에 존재하는 명령어를 해석하여 실행하는 일꾼이다, 커널이 프로그램을 메모리에 올려 프로세스로 만들면 일꾼인 CPU가 이를 처리한다
- 제어장치가 메모리에 계산할 값을 로드 또는 레지스터에 로드 -> 제어장치가 레지스터에 있는 값을 계산하라고 산술논리연산장치에 명령 -> 제어장치가 계산된 값을 다시 레지스터에서 메모리로 계산한 값을 저장
- 인터럽트는 어떤 신호가 들어왔을 때 CPU를 잠깐 정지시키는 것을 말한다 키보드 마우스 등 IO 디바이스로 인한 인터럽트, 0으로 숫자를 나누는 산술 연산에서의 인터럽트, 프로세스 오류 등으로 발생한다
- <u>인터럽트가 발생되면 인터럽트 핸들러 함수가 모여 있는 인터럽트 벡터로 가서 인터럽트 핸들러 함수가 실행된다</u> ( 하드웨어 인터럽트, 소프트웨어 인터럽트 )
- DMA 컨트롤러 : I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치인데 CPU에만 너무 많은 인터럽트 요청이 들어오기 때문에 CPU 부하를 막아주는 보조 일꾼 이라고 보면 된다
- 디바이스 컨트롤러 : 컴퓨터와 연결되어 있는 IO 디바이스들의 작은 CPU를 말한다

### 03-2 시스템콜과 modebit
- 시스템콜이 존재하는 이유는 컴퓨터 자원에 대한 직접 접근을 차단할 수 있고 프로그램을 다른 프로그램으로부터 보호할 수 있다
- 프로세스, 스레드, 메모리 -> 시스템콜 -> 커널 -> OS ( 프로세스나 스레드에서 운영체제로 어떠한 요청을 할 때 시스템콜 이라는 인터페이스와 커널을 거쳐 운영체제에 전달되는 과정 )
- 시스템콜이 작동될 때 modebit을 참고해서 유저 모드와 커널 모드를 구분한다
- modebit의 0은 커널 모드, 1은 유저모드라고 설정됩니다 ( 책에 있는 오타 수정 )

### 03-3 메모리계층

![memory_layer](https://user-images.githubusercontent.com/80055816/178681983-146ca6be-e261-4062-b761-58173f0deb3d.png){: width="70%" height="70%"}{: .align-center}

- 레지스터 : CPU 안에 있는 작은 매모리이며 속도가 가장 빠르다
- 메모리 계층이 존재하는 이유는 경제성 때문이다
- 게임을 실행하다 보면 로딩 중 이라는 메시지가 나오는 것을 볼 수 있다 이는 하드디스크 또는 인터넷에서 데이터를 읽어 RAM으로 전송하는 과정이 아직 끝나지 않음을 의미한다
- 캐시 : 데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리를 말한다
- 메모리와 CPU 사이의 속도 차이가 너무 크기 때문에 그 중간에 레지스터 계층을 둬서 속도 차이를 해결 하는데 이렇게 속도 차이를 해결하기 위해 계층 사이에 있는 계층을 캐시 계층 이라고 한다
- 지역성의 원리, 시간 지역성 : 최근 사용한 데이터에 다시 접근하려는 특성
- 공간 지역성, 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성을 말한다
- 캐시히트 : 캐시에서 원하는 데이터를 찾았다면 캐시히트라고 한다
- 캐시미스 : 캐시에서 원하는 데이터를 찾지 못해 주 메모리로 가서 데이터를 찾아오는 것을 캐시미스라고 한다
- 레지스터는 주 메모리에 비하면 굉장히 작고 주 메모리는 굉장히 크기 때문에 작은 레지스터가 캐시 계층으로써 역할을 잘 해주려면 캐시 매핑을 어떻게 하느냐가 중요하다
- 캐시 매핑이란 소용량의 캐시메모리와 상대적 대용량의 중앙메모리 간 효율적인 매핑을 통해 캐시 적중률(Hit Ratio)를 높이기 위한 메커니즘

### 03-4 가상메모리와 스와핑, 페이지폴트 그리고 스레싱
- 가상메모리 : 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것을 말한다
- 추상화란 어떤 복잡한 것들을 단순화 시켜서 표현한 것이다
- 가상 주소는 메모리관리장치(MMU)에 의해 실제 주소로 변환되며, 이 덕분에 사용자는 실제 주소를 의식할 필요 없이 프로그램을 구축할 수 있게 된다
- 가상 메모리는 가상 주소와 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어 있는 페이지 테이블로 관리된다 이때 속도 향상을 위해 TLB를 쓴다
- TLB : 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시이다 페이지 테이블에 있는 리스트를 보관하며 CPU가 페이지 테이블까지 가지 않도록 해 속도를 향상시킬 수 있는 캐시 계층이다 ( 페이지 테이블은 주메모리에 있다 )
- 페이지 폴트 : 프로세스의 주소 공간에는 존재하지만 지금 이 컴퓨터의 RAM에는 없는 데이터에 접근했을 경우에 발생한다, 페이지 폴트가 일어나면 스와핑이 작동하는데 자세한 과정은 영상을 참고하자 <u>4:45</u> ( 교재 오타 )
- 스와핑 : 메모리의 당장 사용하지 않는 영역을 하드디스크로 옮기고 하드디스크의 일부분을 마치 메모리처럼 불러와쓰는 것, 이를 통해 마치 페이지폴트가 일어나지 않은 것처럼 만듭니다 ( 교재 오타 수정 )
- 페이지 : 가상 메모리를 사용하는 최소 크기 단위
- 프레임 : 실제 메모리를 사용하는 최소 크기 단위
- 스레싱 : 메모리의 페이지 폴트율이 높은 것을 의미하며, 이는 컴퓨터의 심각한 성능 저하를 초래한다
- 스레싱의 원인 : 메모리에 너무 많은 프로세스가 동시에 올라가기 때문이다
- 스레싱의 악순환 과정 : 페이지 폴트가 일어나면 CPU 이용률이 낮아진다 -> 운영체제가 CPU가 한가한가? 라고 생각하여 가용성을 더 높이기 위해 더 많은 프로세스를 메모리에 올린다 -> 이와 같은 악순환이 반복된다
- 스레싱을 해결하는 하드웨어 적인 방법 : 메모리를 늘리거나 HDD를 SSD로 바꾼다
- 스레싱을 해결하는 운영체제 적인 방법 1 : 작업 세트(working set)는 프로세스의 과거 사용 이력인 지역성을 통해 결정된 페이지 집합을 만들어서 미리 메모리에 로드하는 것이다 미리 메모리에 로드하면 탐색에 드는 비용을 줄일 수 있고 스와핑 또한 줄일 수 있다
- 스레싱을 해결하는 운영체제 적인 방법 2 : PFF(Page Fault Frequency)는 페이지 폴트 빈도를 조절하는 방법으로 상한선과 하한선을 만드는 방법이다 만약 상한선에 도달하면 프레임을 늘리고 하한선에 도달하면 프레임을 줄인다
- 메모리 할당, 연속 할당 : 고정 분할 방식과 가변 분할 방식이 있는데 고정 분할 방식은 내부 단편화가 발생할 수 있고 가변 분할 방식은 외부 단편화가 발생할 수 있다
- 가변 분할 방식은 메모리에 적재되는 프로세스 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식이다
- 메모리 할당, 불연속 할당 : 페이징은 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당하는 것이고 세그멘테이션은 페이지 단위가 아니라 의미 단위인 세그먼트로 나누는 방식이다
- 페이지 교체 알고리즘, FIFO : 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법
- 페이지 교체 알고리즘, LRU : 참조가 가장 오래된 페이지를 바꾸는 방법
- 페이지 교체 알고리즘, LFU :가장 참조 횟수가 적은 페이지를 교체하는 방법

### 03-5 프로그램과 프로세스 그리고 스레드의 차이
- 프로세스는 컴퓨터에서 실행되고 있는 프로그램을 말한다
- HDD/SSD에 있는 프로그램을 인스턴스화 하면 프로세스가 된다
- 컴파일 과정 : 전처리( 주석 제거, 헤더 파일 병합, 매크로 치환 ) -> 컴파일러( 어셈블리어로 변환 ) -> 어셈블러 ( 어셈블리어를 목적 코드로 변환 ) -> 링커( 프로그램 내에 있는 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합하여 실행 파일을 만든다 )
- 정적 라이브러리 : 프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는다 ( 외부 의존도가 낮고, 메모리 효율성이 떨어진다 )
- 동적 라이브러리 : 프로그램 실행 시 필요할 때만 DLL 파일에서 함수를 참조한다 ( 외부 의존도가 높고, 메모리 효율성이 좋다 )

![process](https://user-images.githubusercontent.com/80055816/179761460-dde873bc-0a6c-472f-b58c-937daa9cc880.png){: width="70%" height="70%"}{: .align-center}

- 생성 : 프로세스가 생성된 상태를 의미하며 이때 PCB가 할당된다
- 대기 : CPU 스케줄러로 부터 CPU 소유권이 넘어오기를 기다리는 상태이다
- 대기 중단 : 메모리 부족으로 일시 중단된 상태이다
- 실행 : CPU 소유권과 메모리를 할당받고 인스트럭션을 수행 중인 상태를 의미한다 ( CPU burst가 일어났다고도 표현한다 )
- 중단 : 어떤 이벤트가 발생한 이후 기다리며 프로세스가 차단된 상태이다, IO 디바이스에 의한 인터럽트로 이런 현상이 많이 발생한다, 예를 들어 프린트 인쇄 버튼을 눌렀을 때 프로세스가 잠깐 멈춘 듯할 때가 바로 그 상태이다
- 일시 중단 : 중단된 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시 중단된 상태이다
- 종료 : 메모리와 CPU 소유권을 모두 놓고 가는 상태이다

### 03-6 프로세스의 메모리 구조

![memory](https://user-images.githubusercontent.com/80055816/179764764-856c18b2-2054-4c3b-a15a-3c3f8f0b284d.png){: width="70%" height="70%"}{: .align-center}

- 스택 : 지역변수, 매개변수, 함수가 저장되고 컴파일 시에 크기가 결정되며 동적인 특성을 갖는다
- 힙 : 동적 할당할 때 사용되며 런타임 시 크기가 결정된다
- 데이터 영역 : 전역변수, 정적변수가 저장되고 프로그램이 종료되면 사라지는 변수가 들어 있는 영역이다
- 코드 영역 : 프로그램에 내장되어 있는 소스 코드가 들어가는 영역이다

### 03-7 PCB와 컨텍스트 스위칭
- PCB(Process Control Block) : 운영체제에서 프로세스에 대한 메타데이터를 저장한 '데이터'를 말한다
- PCB는 커널 스택의 가장 앞부분에서 관리된다
- PCB는 프로세스 스케줄링 상태, 프로세스 ID 등의 정보로 이루어져 있다
- 컨텍스트 스위칭 : CPU가 PCB를 교환하는 과정을 말한다, 한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생한다
- 스레드에서의 컨텍스트 스위칭의 경우 스택 영역을 제외한 모든 메모리를 공유하기 때문에 비용이 더 적고 시간도 더 적게 걸린다

### 03-8 멀티프로세싱과 멀티스레딩, 그리고 IPC
- 멀티프로세싱은 여러 개의 프로세서 즉 멀티프로세서를 통해 동시에 두 가지 이상의 일을 수행할 수 있는 것을 말한다
- 멀티프로세싱은 하나 이상의 일을 병렬로 처리할 수 있으며 특정 프로세서의 메모리, 프로세서 중 일부에 문제가 발생되더라도 다른 프로세서를 이용해서 처리할 수 있으므로 신뢰성이 높은 강점이 있다
- 멀티스레드는 여러개의 스레드로 구성된 하나의 프로세스를 의미한다
- 멀티스레딩은 멀티스레드를 기반으로 동작하는 것을 의미
- 멀티프로세스는 IPC가 가능하며, IPC는 프로세스끼리 데이터를 주고받고 공유 데이터를 관리하는 메커니즘을 뜻한다
- IPC의 종류로는 공유 메모리, 파일, 소켓, 메시지 큐가 있으며 모두 메모리가 완전히 공유되는 스레드보다는 속도가 떨어진다
- 공유 메모리 : 여러 프로세스에 동일한 메모리 블록에 대한 접근 권한이 부여되어 프로세스가 서로 통신할 수 있도록 공유 버퍼를 생성하는 것을 말한다
- 파일 : 디스크에 저장된 데이터 또는 파일 서버에서 제공하는 데이터를 말한다
- 소켓 : 동일한 컴퓨터의 다른 프로세스나 네트워크의 다른 컴퓨터로 네트워크 인터페이스를 통해 전송하는 데이터를 의미하며 TCP와 UDP가 있다
- 메시지 큐 : 메시지를 큐 데이터 구조 형태로 관리하는 것을 의미한다, 이는 커널에서 전역적으로 관리된다

### 03-9 공유자원과 임계 영역, 그리고 경쟁상태(race condition)
- 이번 단원은 PDF 내용만 보면된다

### 03-10 세마포어, 뮤텍스, 모니터의 차이 그리고 교착상태(deadlock)
- 세마포어에는 조건 변수가 없고 한 프로세스가 세마포어 값을 수정할 때 다른 프로세스는 동시에 세마포어 값을 수정할 수 없다
- 뮤텍스는 한 개의 프로세스 또는 스레드만의 임계영역접근을 처리하지만 세마포어는 여러 개의 임계영역접근을 처리할 수 있다
- 교착 상태의 원인 1 : 상호 배제, 한 프로세스가 자원을 독점하고 있으며 다른 프로세스들은 접근이 불가능하다
- 교착 상태의 원인 2 : 점유 대기, 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 상태
- 교착 상태의 원인 3 : 비선점, 다른 프로세스의 자원을 강제적으로 가져올 수 없다
- 교착 상태의 원인 4 : 환형 대기, 프로세스 A는 프로세스 B의 자원을 요구하고, 프로세스 B는 프로세스 A의 자원을 요구하는 등 서로가 서로의 자원을 요구하는 상황을 말한다
- 교착 상태의 해결방법 1 : 자원을 할당할 때 애초에 조건이 성립되지 않도록 설계한다
- 교착 상태의 해결방법 2 : 교착 상태 가능성이 없을 때만 자원 할당되며, 프로세스당 요청할 자원들의 최대치를 통해 자원 할당가능 여부를 파악하는 '은행원 알고리즘'을 쓴다, 은행원 알고리즘이란 총 자원의 양과 현재 할당한 자원의 양을 기준으로 안정 또는 불안정 상태로 나누고 안정 상태로 가도록 자원을 할당하는 알고리즘이다
- 교착 상태의 해결방법 3 : 교착 상태가 발생하면 사이클이 있는지 찾아보고 이에 관련된 프로세스를 한개씩 지운다
- 교착 상태의 해결방법 4 : 교착 상태는 매우 드물게 일어나기 때문에 이를 처리하는 비용이 더 커서 교착 상태가 발생하면 사용자가 작업을 종료한다, 현대 운영체제는 이 방법을 채택했다

### 03-11 CPU 스케줄링 알고리즘(비선점형, 선점형)
- CPU 스케줄러는 CPU 스케줄링 알고리즘에 따라 프로세스에서 해야 하는 일을 스레드 단위로 CPU에 할당한다
- 프로그램이 실행될 때는 CPU 스케줄링 알고리즘이 어떤 프로그램에 CPU 소유권을 줄 것인지 결정한다
- CPU 스케쥴링 알고리즘은 CPU 이용률은 높게, 주어진 시간에 많은 일을 하게, 준비 큐에 있는 프로세스는 적게, 응답 시간은 짧게 설정하는 것을 목표로 한다
- 비선점형 방식은 프로세스가 스스로 CPU 소유권을 포기하는 방식이며, 강제로 프로세스를 중지하지 않는다 따라서 컨텍스트 스위칭으로 인한 부하가 적다
- 선점형 방식은 현대 운영체제가 쓰는 방식으로 지금 사용하고 있는 프로세스를 알고리즘에 의해 중단시켜 버리고 강제로 다른 프로세스에 CPU 소유권을 할당하는 방식이다
- 라운드 로빈은 할당 시간이 짧으면 컨텍스트 스위칭이 잦아져서 비용이 커진다, 일반적으로 전체 작업 시간은 길어지지만 평균 응답 시간은 짧아진다는 특징이 있다
- 다단계 큐는 큐간의 프로세스 이동이 안되므로 스케줄링 부담이 적지만, 유연성이 떨어지는 특징이 있다

### 03-12 캐시, 캐시히트, 캐시미스와 캐시 사례
- 지역성을 기반으로 캐시히트를 높여야 한다 ( 시간 지역성, 공간 지역성 )

![chach](https://user-images.githubusercontent.com/80055816/181683749-91ff7045-f177-4520-8c55-0df5c0a2a584.png){: width="70%" height="70%"}{: .align-center}

### 03-13 메모리할당 : 고정분할과 가변분할 (연속할당)
- 고정 분할 방식은 메모리를 미리 나누어 관리하는 방식이며, 메모리가 미리 나뉘어 있기 때문에 융통성이 없다 또한 내부 단편화가 발생한다
- 가변 분할 방식은 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용한다 내부 단편화는 발생하지 않고 외부 단편화는 발생할 수 있다 ( 최초적합은 위쪽이나 아래쪽부터 시작해서 홀을 찾으면 바로 할당한다, 최적적합은 프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당한다, 최악적합은 프로세스의 크기와 가장 많이 차이가 나는 홀에 할당한다 )
- 내부 단편화는 메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 현상이다
- 외부 단편화는 메로리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 많이 발생하는 현상이다

### 03-14 메모리할당 : 페이징, 세그멘테이션, 페이지드 세그멘테이션 (불연속할당)
- 이번 단원은 PDF 내용만 보면된다

### 03-15 페이지교체 알고리즘 : FIFO, LRU, NUR, LFU
- 메모리는 한정되어 있기 때문에 스와핑이 많이 일어난다
- 스와핑은 많이 일어나지 않도록 설계되어야 하며 이는 페이지 교체 알고리즘을 기반으로 스와핑이 일어난다

### 03-16 개발자가 꼭 알아야 하는 리눅스 명령어(터미널 사용법)
- 이번 단원은 PDF 내용만 보면된다

<br>

## Chapter 05 자료구조

### 05-1 자료구조와 C++
- bits/stdc++.h는 모든 표준 라이브러리가 포함된 헤더이다

### 05-2 빅오표기법, 시간복잡도와 공간복잡도
- 자료구조의 시간 복잡도를 생각할 때 접근, 탐색, 삽입, 삭제를 고려하자

![time](https://user-images.githubusercontent.com/80055816/182283765-6ba8ac1f-34f8-488a-a4f4-d93f6ca47772.PNG){: width="70%" height="70%"}{: .align-center}

- 위의 표는 외우는게 좋다

### 05-3 연결리스트와 배열의 차이
- 싱글 연결 리스트 : next 포인터만 가진다
- 이중 연결 리스트 : next 포인터와 prev 포인터를 가진다
- 원형 이중 연결 리스트 : 이중 연결리스트와 같지만 마지막 노드의 next 포인터(tail)가 헤드 노드를 가리키는 것을 말한다

### 05-4 벡터와 push_back()의 시간복잡도가 O(1)인 이유
- 특정 자료구조의 메소드 시간 복잡도를 물어보는 면접 질문이 나올수 있다
- push_back()을 할때 2의 제곱승 + 1 마다 크기를 2배로 늘린다 이를 시그마 관계식으로 만든뒤, 일반화 하면 3n - 1이 되는데 이 수식은 push_back()을 n번 했을때 비용이다 때문에 n으로 나누면 O(3)이 나온다 이는 상수 시간보다는 크지만 상수 시간에 가까운 amortized 복잡도를 가지기 때문에 O(1)의 시간 복잡도를 가진다 할 수 있다

### 05-5 스택과 큐의 차이
- 스택(LIFO)과 큐(FIFO)의 차이는 면접에서 가장 많이 나오는 질문중 하나이다
- 이번 단원은 PDF 내용만 보면된다

### 05-6 그래프와 트리, 그리고 BST
- 간선은 단방향 간선과 양방향 간선이 있다
- 어떠한 정점으로부터 나가는 간선을 outdegree 라고 하고 들어오는 간선을 indegree라고 한다
- 가중치는 간선과 정점 사이에 드는 비용을 뜻한다
- 트리는 루트 노드, 내부 노드, 리프 노드(자식이 없다) 등으로 구성된다
- 깊이는 각 노드마다 다르며, 루트 노드부터 특정 노드까지 최단 거리로 갔을 때의 거리를 말한다
- 높이는 루트 노드부터 리프 노드까지 거리 중 가장 긴 거리를 의미한다
- 레벨은 보통 깊이와 같은 의미를 지닌다
- 서브트리는 트리 내의 하위 집합을 의미한다
- 정이진 트리는 자식 노드가 0 또는 두 개인 이진 트리를 의미한다
- 완전 이진 트리는 왼쪽에서부터 채워져 있는 이진 트리를 의미한다
- 변질 이진 트리는 자식 노드가 하나밖에 없는 이진 트리를 의미한다
- 포화 이진 트리는 모든 노드가 꽉 차 있는 이진 트리를 의미한다
- 균형 이진 트리는 왼쪽과 오른쪽 노드의 높이 차이가 1 이하인 이진 트리를 의미한다

### 05-7 균형잡힌 트리 : AVL 트리, 레드블랙트리
- AVL트리는 자식 서브트리의 높이가 항상 최대 1만큼 차이가 난다

### 05-8 해시테이블
- 이번 단원은 PDF 내용만 보면된다

### 05-9 DEEP DIVE : 해시테이블과 이중연결리스트로 LRU 페이지 교체 알고리즘 구현하기
- 이번 단원은 PDF 내용만 보면된다

### 05-10 DEEP DIVE : 해시테이블과 충돌문제(collision)
- 이번 단원은 PDF 내용만 보면된다

### 05-11 로또번호 7개를 셔플하기 위한 가장 좋은 자료구조는?
- 면접관은 이 단원의 주제와 비슷하게 질문을 하는데, 이때 시간복잡도를 고려해서 적절한 자료구조를 대답해야한다

<br>

## Chapter 99 Copyright

[ 인프런 큰돌님 강의 영상 ](https://www.inflearn.com/course/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%A9%B4%EC%A0%91-cs-%ED%8A%B9%EA%B0%95/dashboard)

<br>

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}