---
title:  "CS면접 준비" 

categories:
  - Interview
tags:
  - []

comments: true

toc: true
toc_sticky: true

date: 2022-09-05
last_modified_at: 2022-09-05
---

## 면접 질문

### 01-1 C++ 프로그래밍 언어 ( 중요도 최상 )
- 컴파일 이란 무엇인가? 인간이 이해할 수 있는 언어로 작성된 소스 코드(고수준 언어 : C, C++, Java 등)를 CPU가 이해할 수 있는 언어(저수준 언어 : 기계어)로 번역(변환)하는 작업을 말한다 ([**참고**](https://bradbury.tistory.com/226))
- 컴파일 과정에 대해 설명하면? 전처리된 소스 코드 파일(.i)을 컴파일러(Compiler)를 통해 어셈블리어 파일(.s)로 변환하는 과정이다 ([**참고**](https://bradbury.tistory.com/226))
- 빌드 과정이란? 전처리 과정 - 컴파일 과정 - 어셈블리 과정 - 링킹 과정을 묶어서 빌드 과정이라고 한다 ([**참고**](https://bradbury.tistory.com/226))
- 전처리 과정이란? 전처리기(Preprocessor)를 통해 소스 코드 파일(.c)을 전처리된 소스 코드 파일(.i)로 변환하는 과정이다 ([**참고**](https://bradbury.tistory.com/226))
- 어셈블리(Assembly) 과정에 대해서 설명하면? 어셈블리어 파일(.s)을 어셈블러(Assembler)를 통해 오브젝트 파일(.o)로 변환하는 과정이다 ([**참고**](https://bradbury.tistory.com/226))
- 링킹(Linking) 과정에 대해서 설명하면? 오브젝트 파일(.o)들을 링커(Linker)를 통해 묶어 실행 파일로 만드는 과정이다 ([**참고**](https://bradbury.tistory.com/226))
- rvalue와 lvalue에 대해 설명하면? lvalue는 표현식 이후에도 사라지지 않는 값 즉 이름을 지니는 변수이다 rvalue, 표현식 이후에는 사라지는 값 즉 임시 변수이다 ([**참고**](https://m.blog.naver.com/luku756/221808884092))
- 추상 클래스와 인터페이스의 차이점은? 인터페이스는 상태나 구현을 가질 수 없다, 인터페이스를 구현하는 클래스는 해당 인터페이스의 모든 메소드를 구현해야 한다, 추상 클래스는 상태(data members) 및/또는 구현(method)을 포함할 수 있다, 추상 클래스는 추상 메소드를 구현하지 않고 상속될 수 있다 이때 유도 클래스 역시 추상 클래스가 된다 ([**참고**](https://velog.io/@hyongti/C%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs.-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%ED%81%B4%EB%9E%98%EC%8A%A4))
- 구조체와 클래스의 차이는? 구조체는 접근 제어 지시자를 따로 선언하지 않으면 모든 변수와 함수가 public으로 선언되고, class의 경우 접근제어 지시자를 따로 선언하지 않으면 모든 변수와 함수가 private로 선언된다 ([**참고**](https://k96-ozon.tistory.com/31))
- 객체직렬화(Object Serialization)에 대해 설명하면? 객체의 메모리를 연속적인 바이트로 만들고, 만들어진 연속적인 바이트를 원래의 객체로 복원하는 작업을 말한다 ([**참고**](https://www.ikpil.com/1053))
- C++의 특징에 대해 설명하면? 첫번째는 다형성(Polymorphism)으로 하나의 객체가 여러 가지 타입을 가질수 있는 것을 의미한다, 두번째는 캡슐화로 비슷한 속성과 메소드를 하나의 클래스로 묶는것을 말한다, 세번째는 상속으로 부모 클래스의 메소드와 필드를 자식 클래스에서 그대로 물려 받는 것을 의미한다, 네번째는 추상화로 어떤 실체들에서 관심이 있는 공통적인 특성을 뽑아내어 하나의 분류로 만드는 것을 말한다 ([**참고**](https://cclient.tistory.com/m/11))
- 다형성의 예시에 대해서 설명하면? 가상함수, 함수 템플릿, 함수 오버로드, 연산자 오버로드가 있다 ([**참고**](https://younggwan.tistory.com/50))
- C++과 C언어의 차이는? 속도적인 차이에 대한 이유에 대해서 말씀드리겠습니다 C++이 C언어보다 상대적으로 느립니다 그 이유는 템플릿이나 객체 지향 언어가 제공하는 기능에서 발생합니다. 객체지향 언어의 특성상 데이터 타입 변환이나 다형성의 기능을 지원하기 위해 다수의 메모리 테이블을 추가합니다 결과적으로 더 많은 메모리가 필요하며, 또한 메모리 관리하는 기능들이 추가되다 보니 전반적으로 느려지게 됩니다 그리고 객체를 이용한 출력, 함수를 이용한 출력이 다르고 C++은 namespace 개념을 사용개념을 사용합니다 ([**참고**](https://cclient.tistory.com/m/11))
- 추상클래스란 무엇인가? C++에서는 하나 이상의 순수 가상 함수를 포함하는 클래스를 추상 클래스(abstract class)라고 한다
- 인터페이스란 무엇인가? 인터페이스는 구현이 없다 즉, 인터페이스 클래스에는 가상 소멸자와 순수 가상함수만 포함된다 ([**참고**](https://velog.io/@hyongti/C%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs.-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%ED%81%B4%EB%9E%98%EC%8A%A4))
- 생성자는 왜 가상함수가 될 수 없는가? 개체를 만들려면 완전한 정보가 필요합니다 특히 생성하려는 정확한 유형을 알아야 합니다 결과적으로 "생성자 호출"은 가상이 될 수 없습니다 ([**참고**](https://stackoverflow.com/questions/733360/why-do-we-not-have-a-virtual-constructor-in-c))
- 가상함수와 순수 가상 함수에 대해서 설명하면? 순수 가상 함수는 인터페이스(Interface)를 자식 클래스에게 전달하기 위해 사용하는 함수이고, 일반(단순) 가상 함수는 인터페이스(Interface) + 함수의 선언(내부 구현) 까지 자식 클래스에게 전달하기 위해 사용하는 함수입니다 ([**참고**](https://stackoverflow.com/questions/733360/why-do-we-not-have-a-virtual-constructor-in-c))
- volatile 키워드에 대해서 설명하면? volatile 키워드는 해당 변수의 컴파일러 최적화를 제한하는 용도로 사용합니다 ([**참고**](https://psychoria.tistory.com/592))
- calloc, malloc, new에 대해서 차이점을 설명하면? 리턴값, 매개변수, 라이브러리 제공 함수라는 차이점이 있습니다, 리턴값의 경우 malloc은 void형을 return하고 new는 할당할 타입만 지정하게 되면 자동으로 할당할 타입의 자료형의 포인터를 리턴한다 매개변수의 경우 malloc은 데이터 타입의 사이즈와 공간을 할당할 개수를 곱한 값을 매개변수로 받고 메모리만 할당해준다 new는 할당과 동시에 초기화가 가능하다 라이브러리 제공 함수의 경우 new는 C++ 자체 라이브러리 이고 malloc은 라이브러리 제공함수를 필요로 한다

### 01-2 자료구조, C++ STL ( 중요도 상 )
- vector와 list의 차이는? vector를 중간삽입시 원소를 밀어내지만 list는 노드를 연결만 하기 때문에, 삽입 삭제 부분에서 시간복잡도의 우위를 가진다 또한 vector는 랜덤부분접근이 가능하지만 list는 더블링크드리스트로 되어 있기 때문에 x[2]와 같은 랜덤 접근이 되지 않는다 검색적인 측면에서는 vector가 우위에 있다 ([**참고**](https://chanheess.tistory.com/154))
- 단일 연결 리스트를 뒤집기 하려면? 전, 지금, 다음 포인터를 만든 뒤 지금 노드의 다음은 전 포인터를 가리킨다 전 포인터는 지금 포인터를 가리킨다 지금 포인터는 다음 포인터를 가리킨다 ([**참고**](https://www.fwantastic.com/2021/01/leetcode-206-reverse-linked-list.html)), ([**참고**](https://modernalchemist.tistory.com/43))
- Hash란 무엇인가? 데이터 삽입 및 삭제 시, 데이터와 연관된 고유한 숫자를 생성해 인덱스로 사용하는 방법 ([**참고**](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Interview/Interview%20List.md#%EC%96%B8%EC%96%B4))

### 01-3 알고리즘 ( 중요도 상 )
- QuickSort를 설명하면? 리스트 안에 있는 한 요소를 선택한다(이렇게 고른 원소를 pivot 이라고 한다) -> 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고 피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮겨진다 -> 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다 -> 부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다 ([**참고**](https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html))
- QuickSort에서 pivot을 선택하는 방법은? Median Of Three Pivot 이라는 방법이 있으며 3개의 원소를 후보로 두고 그 중간 값을 선택하는 방법이다 ([**참고**](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=ljy9378&logNo=221508655059))
- 다익스트라 알고리즘에 대해 설명하면? 다익스트라 알고리즘은 그래프에서 여러 개의 노드가 있을 때, 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘이다, 동작 원리는 ( 1 ) 시작 노드와 직접적으로 연결된 모든 정점들의 거리를 비교해서 업데이트 시켜주고, 시작 노드를 방문한 노드로 체크한다. -> ( 2 ) 방문한 정점들과 연결되어 있는 정점들 중, 비용이 가장 적게 드는 정점을 선택하고, 해당 정점을 방문한 정점으로 선택해준다. -> ( 3 ) 2번 과정에 의해서 갱신될 수 있는 정점들의 거리를 갱신시켜준다 -> ( 4 ) 2 ~ 3번 과정을 반복한다 ([**참고**](https://yabmoons.tistory.com/364))

### 01-4 그래픽스 ( 중요도 상 )
- 

### 01-5 운영체제 ( 중요도 중 )
- 운영체제가 사용하는 메모리 영역에 대해 설명하면? OS 메모리 구조는 2가지 영역으로 나누는데 바로 유저 영역, 커널 영역이다 유저영역 메모리는 4가지로 나눠지는데 데이터영역, 힙영역, 코드영역, 스택 영역으로 구분이 된다 그리고 커널 영역은 시스템 운영에 필요한 메모리로 운영체제가 올려져 있다 ([**참고**](https://webstone.tistory.com/96))
- 스레드란 무엇인가? 프로세스가 할당받은 자원을 이용하는 실행 단위다 ([**참고**](https://becomeweasel.me/process-and-thread/))
- 프로세스가 사용하는 메모리 영역과 스레드가 사용하는 메모리 영역의 차이점은? 프로세스는 각자 본인이 사용하는 메모리 영역과 레지스터 값을 가지며 프로세스의 메모리 영역은 데이터, 힙, 코드, 스택 영역으로 구성된다 그리고 스레드는 각자의 레지스터와 스택을 가지지만, 나머지 영역은 가지지 않는다. 대신에 데이터, 힙, 코드 영역을 공유해서 병렬적인 수행이 가능하다. ([**참고**](https://becomeweasel.me/process-and-thread/))
- 라운드 로빈 알고리즘에 대해서 설명((사용하는 이유, 멀티 스레드 환경에서의 필요성))하면? 라운드 로빈(RR) 스케쥴링 알고리즘은 시간 할당량 또는 타임슬라이스 라고 하는 작은 단위의 시간을 정의하고 CPU 스케쥴러는 준비 큐를 돌면서 한 번에 한 프로세스에 정의된 시간 할당량 동안 CPU를 할당한다 사용하는 이유와 필요성은 멀티 스레드 환경에서 하나의 스레드가 CPU를 독점하는 상황과 다른 스레드가 실행되지 못하고 무한정 기다리는 '기아' 현상을 막기 위해 각 스레드에 적절한 CPU 사용 시간을 부여하여 모든 스레드가 순환적으로 실행되도록 하기 위함 ([**참고**](https://woo-dev.tistory.com/163))
- 컴퓨터에 존재하는 메모리들의 액세스 속도를 설명 하면? 레지스터는 프로세서에 위치한 고속 메모리로 프로세서가 바로 사용할 수 있는 데이터를 담고있다, 캐시는 레지스터 다음으로 빠른 메모리이며 CPU 내부에 존재한다 CPU와 주기억장치간의 속도 차이로 인한 성능 저하를 막기 위해 사용된다, 주기억장치는 CPU가 처리하고 있는 내용이 가져와지는 곳을 말한다, 보조기억장치는 주기억장치보다는 느리지만 많은 양의 데이터를 전원이 꺼져도 사라지지 않고 영구적으로 보관할 수 있는 장치이다 ([**참고**](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=cjsksk3113&logNo=222246966805))
- context switching에 대해 설명하면? 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, CPU가 PCB를 교환하는 작업을 말한다, 한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생한다 ( 내 블로그 참고 )
- PCB에 대해서 설명하면? 운영체제에서 프로세스에 대한 메타데이터를 저장한‘데이터’를 말하며 프로세스 스케줄링 상태, 프로세스 ID 등의 정보로 이루어져 있다 ( 내 블로그 참고 )
- 스레드 프로그래밍에서 중요한건? 스레드 마다 별도로 주어지는 공간 (스택), 모든 스레드가 공유하는 공간 (힙, 정적 데이터 영역) 등에 대해 파악하고 코드를 작성해야 한다 ([**참고**](https://elky.tistory.com/285))
- blocking vs non-blocking에 대해서 설명하면? blocking은 A 함수가 B 함수를 호출 할 때, B 함수가 자신의 작업이 종료되기 전까지 A 함수에게 제어권을 돌려주지 않는 것 non-blocking은 A 함수가 B 함수를 호출 할 때, B 함수가 제어권을 바로 A 함수에게 넘겨주면서, A 함수가 다른 일을 할 수 있도록 하는 것 ([**참고**](https://jh-7.tistory.com/25))
- 프로세스와 스레드의 차이는? 프로세스는 메모리 상에서 실행중인 프로그램을 말하며, 스레드는 이 프로세스 안에서 실행되는 흐름 단위를 말한다 ([**참고**](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Interview/Interview%20List.md#%EC%96%B8%EC%96%B4))
- 멀티 프로세스로 처리 가능한걸 굳이 멀티 스레드로 하는 이유는? 프로세스를 생성하여 자원을 할당하는 시스템 콜이 감소함으로써 자원의 효율적 관리가 가능하며, 프로세스 간의 통신(IPC)보다 스레드 간의 통신 비용이 적어 작업들 간 부담이 감소함, 대신 동기화에 신경을 써야한다 ([**참고**](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Interview/Interview%20List.md#%EC%96%B8%EC%96%B4))
- 교착상태가 무엇이며 4가지 조건은? 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태이며 상호배제, 점유대기, 비선점, 순환대기 이 4가지 조건 중 하나라도 만족하지 않으면 교착상태는 발생하지 않는다 ([**참고**](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Interview/Interview%20List.md#%EC%96%B8%EC%96%B4)), ([**참고**](https://velog.io/@dl_edge/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-4%EA%B0%80%EC%A7%80-%EC%A1%B0%EA%B1%B4))
- 교착상태를 해결하는 방법은? 예방, 탐지, 회피, 무시 ([**참고**](https://hoyeonkim795.github.io/posts/%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/))
- 메모리 할당 알고리즘 3가지는? First fit은 메모리의 첨부터 검사해서 크기가 충분한 첫 번째 메모리에 할당, Next fit은 마지막으로 참조한 메모리 공간에서부터 탐색을 시작해 공간을 찾아 할당, Best fit은 모든 메모리 공간을 검사해서 내부 단편화를 최소화하는 공간에 할당 ([**참고**](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Interview/Interview%20List.md#%EC%96%B8%EC%96%B4))
- 페이지 폴트란 무엇인가? CPU가 프로그램을 실행하면서 필요한 페이지가 물리적 메모리에 없는 경우도 생기게 되는데 이것을 페이지 폴트(Page Fault)라고 한다 ([**참고**](https://velog.io/@jiseong/OS-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%80%ED%8F%B4%ED%8A%B8-gyq8tftz))
- 페이지 폴트 발생시 물리적 메모리에 비어있는 프레임이 존재하지 않는 경우에 사용하는 알고리즘과 해당 알고리즘에 대해 설명하면? 페이지 교체 알고리즘을 사용하며, OPT는 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체 ( 실현 가능성 없음 ), FIFO는 메모리가 할당된 순서대로 페이지를 교체, LRU는 가장 오랫동안 사용되지 않은 페이지 교체, LFU는 사용 빈도가 가장 적은 페이지를 교체, NUR은 최근에 사용하지 않은 페이지를 교체 ([**참고**](https://velog.io/@jiseong/OS-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%80%ED%8F%B4%ED%8A%B8-gyq8tftz))
- 내부 단편화와 외부 단편화를 설명하면? 내부 단편화는 메모리를 나눈 크기보다 프로그램이 작아서 사용하지 못하는 공간이 많이 발생하는 현상이다, 외부 단편화란 남아있는 총 메모리 공간이 요청한 메모리 공간보다 크지만, 남아있는 공간이 연속적(contiguous)이지 않아 발생하는 현상이다 ([**참고**](https://code-lab1.tistory.com/54))
- 가상메모리란? 실제로 프로그램 수행에 필요한 부분만 메모리에 올려놓음으로써 주기억장치의 용량보다 큰 프로세스라도 사용자가 메모리에 올려놓을 수 있게 하는 기법이다 ([**참고**](https://luv-n-interest.tistory.com/1005))
- 페이징의 정의와 작동하는 원리를 설명하면? 페이징은 virtual memory를 page로 나누는 기법을 말하며, 주기억장치의 데이터 공간, 보조기억장치의 데이터를 모두 동일한 크기로 나눈뒤, 데이터 접근이 일어날 때, 보조기억장치에서 필요한 페이지들을 꺼내 주기억장치의 영역(프레임)에 적재시킨다 ([**참고**](https://velog.io/@dd9s2/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EA%B8%B0%EC%96%B5-%EC%9E%A5%EC%B9%98%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%95-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98-Virtual-Memory-Paging-Segmentation))
- 세그먼테이션에 대해 설명하면? 메모리를 서로 크기가 다른 논리적인 블록 단위인 '세그먼트(segment)'로 분할하고 메모리를 할당하여 물리 주소를 논리 주소로 변환하는 것을 말한다 ( 미리 분할하지 않고 메모리를 사용할 시점에 할당된다는 것이 중요하다 )
- 세마포어, 뮤텍스의 정의와 차이점을 설명하면? 세마포어는 멀티프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법이며, 뮤텍스는 임계 구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술이다 차이점은 뮤텍스는 동기화 대상이 오직 1개일 때 사용하며, 세마포어는 동기화 대상이 1개 이상일 때 사용한다 ([**참고**](https://gyoogle.dev/blog/computer-science/operating-system/Semaphore%20&%20Mutex.html)), ([**참고**](https://heeonii.tistory.com/14))
- 사용자 수준 스레드의 정의와 장단점을 설명하면? 사용자 스레드는 커널 영역의 상위에서 지원되며 일반적으로 사용자 레벨의 라이브러리를 통해 구현된다 라이브러리는 스레드의 생성 및 스케줄링 등에 관한 관리 기능을 제공한다 장점은 스케줄링과 동기화를 위해 System Call(커널 호출) 하지 않기 때문에 오버헤드 적다는 것이고(Context Switching을 프로세스 내부에서 진행하면 됨) 단점은 하나의 스레드가 System Call(커널 호출)하면 해당 프로세스 내 모든 스레드가 중단된다는 것이다(커널이 스레드의 존재를 알지 못하기 때문에) ([**참고**](https://kspsd.tistory.com/50))
- 커널 수준 스레드의 정의와 장단점을 설명하면? 커널 스레드는 운영체제가 지원하는 스레드 기능으로 구현되며, 커널이 스레드의 생성 및 스케줄링 등을 관리한다 장점은 커널이 각 스레드를 개별적으로 관리할 수 있다는 것이고 단점은 유저 모드와 커널 모드 간 전환이 빈번하여 성능 저하된다는 것이다 ([**참고**](https://kspsd.tistory.com/50))
- Race Condition에 대해서 설명하면? Race Condition이란 두 개 이상의 cocurrent한 프로세스(혹은 스레드)들이 하나의 자원(리소스)에 접근하기 위해 경쟁하는 상태를 말합니다, 여기서 cocurrent하다는 말은 동시성(병행성)을 가진다는 말이다 ([**참고**](https://seamless.tistory.com/42))

### 01-6 네트워크 ( 중요도 하 )
- 소켓 프로그래밍이란 무엇인가? 보통 OSI 7 Layer(Open System Interconnection 7 Layer)의 네 번째 계층인 TCP(Transport Control Protocol) 상에서 동작하는 소켓을 주로 사용하는데, 이를 "TCP 소켓" 또는 "TCP/IP 소켓"이라고 부른다 ([**참고**](https://tyrionlife.tistory.com/781))

### 01-7 데이터 베이스 ( 중요도 하 )
- 

### 01-8 디자인 패턴 ( 중요도 하 )
- 컴포넌트 패턴에 대해 설명하면? 한 객체가 여러 분야를 서로 커플링(결합도) 없이 다룰 수 있게 한다 ([**참고**](https://boycoding.tistory.com/118))

<br>

## 참고한 블로그 주소들

### 목록
- https://woo-dev.tistory.com/163
- https://iwannabethesenior.blogspot.com/2019/10/blog-post.html
- https://m.blog.naver.com/nds888/221380832707
- https://github.com/gyoogle/tech-interview-for-developer
- https://cclient.tistory.com/m/11

<br>

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}