---
title:  "CS면접 준비" 

categories:
  - Interview
tags:
  - []

comments: true

toc: true
toc_sticky: true

date: 2022-09-05
last_modified_at: 2022-10-30
---

## 면접 질문

### 01-1 C++ 프로그래밍 언어 ( 중요도 최상 )
- 컴파일 이란 무엇인가? 인간이 이해할 수 있는 언어로 작성된 소스 코드(고수준 언어 : C, C++, Java 등)를 CPU가 이해할 수 있는 언어(저수준 언어 : 기계어)로 번역(변환)하는 작업을 말한다 ([**참고**](https://bradbury.tistory.com/226))
- 컴파일 과정에 대해 설명하면? 전처리된 소스 코드 파일(.i)을 컴파일러(Compiler)를 통해 어셈블리어 파일(.s)로 변환하는 과정이다 ([**참고**](https://bradbury.tistory.com/226))
- 빌드 과정이란? 전처리 과정 - 컴파일 과정 - 어셈블리 과정 - 링킹 과정을 묶어서 빌드 과정이라고 한다 ([**참고**](https://bradbury.tistory.com/226))
- 전처리 과정이란? 전처리기(Preprocessor)를 통해 소스 코드 파일(.c)을 전처리된 소스 코드 파일(.i)로 변환하는 과정이다 ([**참고**](https://bradbury.tistory.com/226))
- 어셈블리(Assembly) 과정에 대해서 설명하면? 어셈블리어 파일(.s)을 어셈블러(Assembler)를 통해 오브젝트 파일(.o)로 변환하는 과정이다 ([**참고**](https://bradbury.tistory.com/226))
- 링킹(Linking) 과정에 대해서 설명하면? 오브젝트 파일(.o)들을 링커(Linker)를 통해 묶어 실행 파일로 만드는 과정이다 ([**참고**](https://bradbury.tistory.com/226))
- rvalue와 lvalue에 대해 설명하면? lvalue는 표현식 이후에도 사라지지 않는 값 즉 이름을 지니는 변수이다 rvalue, 표현식 이후에는 사라지는 값 즉 임시 변수이다 ([**참고**](https://m.blog.naver.com/luku756/221808884092))
- 추상 클래스와 인터페이스의 차이점은? 인터페이스는 상태나 구현을 가질 수 없다, 인터페이스를 구현하는 클래스는 해당 인터페이스의 모든 메소드를 구현해야 한다, 추상 클래스는 상태(data members) 및/또는 구현(method)을 포함할 수 있다, 추상 클래스는 추상 메소드를 구현하지 않고 상속될 수 있다 이때 유도 클래스 역시 추상 클래스가 된다 ([**참고**](https://velog.io/@hyongti/C%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs.-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%ED%81%B4%EB%9E%98%EC%8A%A4))
- 구조체와 클래스의 차이는? 구조체는 접근 제어 지시자를 따로 선언하지 않으면 모든 변수와 함수가 public으로 선언되고, class의 경우 접근제어 지시자를 따로 선언하지 않으면 모든 변수와 함수가 private로 선언된다 ([**참고**](https://k96-ozon.tistory.com/31))
- 객체직렬화(Object Serialization)에 대해 설명하면? 객체의 메모리를 연속적인 바이트로 만들고, 만들어진 연속적인 바이트를 원래의 객체로 복원하는 작업을 말한다 ([**참고**](https://www.ikpil.com/1053))
- 객체지향(C++)의 특징에 대해 설명하면? 첫번째는 다형성(Polymorphism)으로 하나의 객체가 여러 가지 타입을 가질 수 있는 것을 말한다 두번째는 캡슐화로 비슷한 속성과 메소드를 하나의 클래스로 묶는것을 말한다 세번째는 상속으로 부모 클래스의 메소드와 필드를 자식 클래스에서 그대로 물려 받는 것을 말한다 네번째는 추상화로 어떤 실체들에서 관심이 있는 공통적인 특성을 뽑아내어 하나의 분류로 만드는 것을 말한다 ([**참고**](https://cclient.tistory.com/m/11))
- 다형성의 예시에 대해서 설명하면? 연산자 오버로드, 함수 오버로드, 함수 템플릿, 가상함수가 있다 ([**참고**](https://younggwan.tistory.com/50))
- C++과 C언어의 차이는? 속도적인 차이에 대한 이유에 대해서 말씀드리겠습니다 C++이 C언어보다 상대적으로 느립니다 그 이유는 템플릿이나 객체 지향 언어가 제공하는 기능에서 발생합니다. 객체지향 언어의 특성상 데이터 타입 변환이나 다형성의 기능을 지원하기 위해 다수의 메모리 테이블을 추가합니다 결과적으로 더 많은 메모리가 필요하며, 또한 메모리 관리하는 기능들이 추가되다 보니 전반적으로 느려지게 됩니다 그리고 객체를 이용한 출력, 함수를 이용한 출력이 다르고 C++은 namespace 개념을 사용개념을 사용합니다 ([**참고**](https://cclient.tistory.com/m/11))
- 추상클래스란 무엇인가? C++에서는 하나 이상의 순수 가상 함수를 포함하는 클래스를 추상 클래스(abstract class)라고 한다 ([**참고**](http://www.tcpschool.com/cpp/cpp_polymorphism_abstract))
- 인터페이스란 무엇인가? 인터페이스는 구현이 없다 즉, 인터페이스 클래스에는 가상 소멸자와 순수 가상함수만 포함된다 ([**참고**](https://velog.io/@hyongti/C%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs.-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%ED%81%B4%EB%9E%98%EC%8A%A4))
- 생성자는 왜 가상함수가 될 수 없는가? 객체를 만들려면 완전한 정보가 필요합니다 특히 생성하려는 정확한 유형을 알아야 합니다 결과적으로 "생성자 호출"은 가상이 될 수 없습니다 ([**참고**](https://stackoverflow.com/questions/733360/why-do-we-not-have-a-virtual-constructor-in-c))
- 가상함수와 순수 가상 함수에 대해서 설명하면? 순수 가상 함수는 인터페이스(Interface)를 자식 클래스에게 전달하기 위해 사용하는 함수이고, 일반(단순) 가상 함수는 인터페이스(Interface) + 함수의 선언(내부 구현) 까지 자식 클래스에게 전달하기 위해 사용하는 함수입니다 ([**참고**](https://blockdmask.tistory.com/277))
- volatile 키워드에 대해서 설명하면? volatile 키워드는 해당 변수의 컴파일러 최적화를 제한하는 용도로 사용합니다 ([**참고**](https://psychoria.tistory.com/592)) ([**참고**](https://geekhub.tistory.com/68))
- malloc, new에 대해서 차이점을 설명하면? 4가지 중요한 차이점이 있다 첫째, new를 이용해 객체를 생성하면 생성자가 호출된다 즉 초기값을 줄 수 있다, malloc은 생성자 호출 기능이 없다 즉 초기값을 줄 수 없다 두번째, malloc은 해당 포인터의 타입을 모르기 때문에 리턴 값의 자료형이 void* 이고 new는 해당 객체에 맞는 포인터을 리턴값으로 반환한다 세번째, new를 통해 객체생성시 에러가 발생하면 예외처리를 하지만 malloc은 예외처리 없이 NULL값을 반환하게 됩니다 네번째, malloc은 realloc으로 할당된 메모리 크기를 재조정이 가능하다 하지만 new는 할당된 크기에 대한 메모리 재조정이 불가능하다 ([**참고**](https://hwan-shell.tistory.com/12))
- 언제 malloc을 사용하고 new를 사용해야 하는가? 재할당이 빈번하게 일어나는 경우 realloc이 가능한 malloc을 사용하는 것이 옳다고 할 수 있고, 생성자 호출이 필요하다면 new를 사용하는 것이 옳다할 수 있다 ([**참고**](https://cclient.tistory.com/m/11))
- null과 nullptr의 차이점? NULL은 상수 0이고, nullptr은 포인터이다 그래서 포인터 변수를 초기화해줄 때 nullptr를 사용해줘야 한다 ([**참고**](https://velog.io/@t1won/C-%EB%84%90-%ED%8F%AC%EC%9D%B8%ED%84%B0-NULL%EA%B3%BC-nullptr))
- inline함수는 무엇인가? 인라인이라는 의미는 코드가 라인 안으로 들어간다는 뜻이다 즉, 함수의 내용을 호출을 통해서 실행시키는 것이 아니라, 호출하는 코드 자체가 함수 내용의 코드가 된다 함수 호출없이 삽입된 함수 코드를 그 자리에서 처리하므로 해당 함수를 수행하기 위해 프로그램이 다른 주소로 점프했다가 되돌아올 필요가 없어 속도면에서 유리합니다 ([**참고**](https://thinkpro.tistory.com/140))
- C++ 상속에서 부모 클래스 소멸자에 virtual(가상 키워드)를 사용해야 하는 이유는? 부모 클래스의 포인터로 자식 클래스를 호출할때 가상 함수로 정의되지 않은 자식 클래스의 함수를 호출하면 부모 클래스의 멤버 함수가 호출된다 소멸자도 자식 클래스의 소멸자가아닌 부모클래스의 소멸자가 호출이된다 즉 가상 함수로 소멸자가 사용되었다면 자식 클래스에서 재정의 될 수 있음을 명시하기 때문에 자식 클래스의 소멸자부터 차례대로 부모 클래스의 소멸자가 호출된다 ([**참고**](https://younggwan.tistory.com/45))
- 하이딩, 오버로딩, 오버라이딩의 차이는? 하이딩은 슈퍼클레스에 정의된 이름과 동일한 이름을 서브클레스에서 정의해서 사용하게 되면, 서브클래스 내에서는 슈퍼클레스의 이름이 모두 가려지게 되는것을 의미한다, 오버로딩은 같은 이름의 함수에 매개변수만 다르게 사용하여 매개변수에 따라 다른 함수가 실행되는 것을 의미한다 오버라이딩은 상속받을 때 부모클래스의 함수를 자식클래스에서 재정의하여 사용하는 것을 의미한다 ([**참고**](https://spikez.tistory.com/173)), ([**참고**](https://cosyp.tistory.com/228))
- static_cast와 dynamic_cast의 차이는? static_cast는 컴파일타임에 형변환이 가능한지 검사한다, 기본 자료형간의 형변환이 가능하다, 부모클래스와 자식클래스 양방향으로 형변환을 허용한다 dynamic_cast는 런타임타임에서 안정성을 검사한다, 기본 자료형간의 형변환이 불가능하다, 자식 클래스에서 부모 클래스로 형변환이 가능한것은 static_cast와 같지만 부모 클래스에서 자식 클래스로의 형변환은 하나 이상의 가상함수를 가진 다형성 클래스에 한해서만 가능하다 ([**참고**](https://mynameisdabin.tistory.com/20))
- call by value와 call by reference의 차이는? call by value의 경우 데이터 값을 복사해서 함수로 전달하기 때문에 원본 데이터가 변경될 가능성이 없습니다 call by reference의 경우 데이터 주소를 복사해서 함수로 전달하기 때문에 참조한 데이터를 변경시 원본 데이터 값이 변경 됩니다 ([**참고**](https://cclient.tistory.com/m/11))
- auto 키워드에 대해서 설명하면? auto 키워드는 선언된 변수의 초기화 식을 사용하여 해당 형식을 추론하도록 컴파일러에 지시한다, 해당 키워드를 사용할 때의 주의점은 선언만하고 초기화를 하지않으면 사용이 불가능하다 이유는 초기화 식을 기준으로 자료형을 선택하기 때문이다  ([**참고**](https://xn--vj5b11biyw.kr/80))
- 스마트 포인터에 대해서 설명하면? C++에서 메모리 누수(memory leak)로부터 프로그램의 안전성을 보장하기 위해 스마트 포인터를 제공하고 있다 포인터처럼 동작하는 클래스 템플렛으로 사용이 끝난 메모리를 자동으로 해제해준다 종류별로 설명하면 shared_ptr은 어떤 하나의 객체를 참조하는 스마트 포인터의 개수를 참조하는 스마트 포인터이다, unique_ptr은 하나의 스마트 포인터만이 객체를 가리킬수 있도록 한다, weak_ptr은 하나 이상의 shared_ptr이 가리키는 객체를 참조할수 있지만 reference count를 늘리지않는 스마트 포인터이다 ([**참고**](https://min-zero.tistory.com/entry/C-STL-1-3-%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%8A%A4%EB%A7%88%ED%8A%B8-%ED%8F%AC%EC%9D%B8%ED%84%B0smart-pointer))
- const 키워드를 자료형 앞에 사용했을때와 변수명 앞에 사용했을때 차이를 설명하면? const int* c 에서 c가 가리키는 대상은 변경이 가능하지만 가리키는 값은 변경할 수 없다 int* const c = &a; 에서 c가 가리키는 대상은 변경할 수 없지만 가리키는값은 변경이 가능하다 ([**참고**](https://cclient.tistory.com/m/11))
- 정적 바인딩에 대해서 설명하면? 어떤 함수가 호출될지 컴파일시 결정된다 ([**참고**](https://byunggni.tistory.com/20))
- 동적 바인딩에 대해서 설명하면? 어떤 함수가 호출될지 런타임 중에 결정된다 ([**참고**](https://byunggni.tistory.com/20))
- 템플릿 메타프로그래밍 이란? 템플릿을 사용하는 프로그래밍 기법으로 컴파일러에게 프로그램 코드를 생성하도록 하는 방식이다 이러한 기법은 컴파일 시점에 많은 것을 결정하도록 하여, 실행 시점 계산을 줄여줍니다 ([**참고**](https://cclient.tistory.com/m/11))
- 클로져와 람다에 대해서 설명하면? 클로져는 런타임에서만 존재하는 객체이고, 람다는 이름 없는 함수 즉, 익명 함수이다 람다와 클로져의 관계는 클래스(람다)를 정의하고 클래스의 객체(클로져)를 만드는 것과 같다 ([**참고**](https://lunchballer.com/archives/284))
- 람다란? 쉽게 말해 이름 없는 함수입니다. 반환형, 인자, 몸통, 캡쳐로 구성되어 있으며 런타임 시 이름은 없지만, 메모리 상에 임시적으로 존재하는 클로져 객체가 생성됩니다 ([**참고**](https://lunchballer.com/archives/284))
- explicit 키워드에 대해서 설명하면? 묵시적 형변환을 할 수 없게 만들고 명시적인 형변환만 가능하도록 만드는 것 ([**참고**](https://psyhm.tistory.com/13))
- 전위 연산과 후위 연산의 차이는? 전위 연산자는 증감된 값을 참조형으로 반환하지만 후위 연산자는 값은 증가시키지만 증감 전의 값을 임시 객체로 만들어서 반환한다 Debug모드에서의 후위연산자는 증감 전의 값을 임시객체로 만들어 리턴하기 때문에 전위연산보다 느리지만 release 모드에서는 컴파일러의 최적화로 둘의 성능은 같다고 한다 ([**참고**](https://spenshi.tistory.com/entry/%EC%A6%9D%EA%B0%90-%EC%97%B0%EC%82%B0%EC%9E%90-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9))
- 오버로딩의 조건에 대해서 설명하면? 함수의 오버로딩이 가능 하려면 매개변수의 선언이 달라야 한다 반환형은 함수호출 시, 호출되는 함수를 구분하는 기준이 될 수 없다 ([**참고**](https://better-tomorrow.tistory.com/entry/C%EC%96%B8%EC%96%B4-%EA%B8%B0%EB%B0%98%EC%9D%98-C01-2-%ED%95%A8%EC%88%98-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9Function-Overloading))
- 오버라이딩 개념에서 리턴 타입이 같아야 되나? 부모 클래스에서 정의한 함수를 자식 클래스에서 오버라이딩할 때, 오버라이딩 하려는 함수의 리턴 타입을 자식 클래스 타입으로 하면 오버라이딩 함수의 리턴 타입을 다르게 해도 오버라이딩이 가능하다 ([**참고**](https://welikecse.tistory.com/75))
- 객체끼리 비교할 때 어떻게 같은 객체인지 아는지? RTTI를 지원하는 요소중 typeid 연산자를 활용해 두 객체가 동일한지 여부를 결정할 수 있습니다 ([**참고**](https://www.techiedelight.com/ko/compare-two-objects-in-cpp/))
- virtual 키워드에 대해서 설명하면? virtual 키워드는 함수에 붙일 수 있다 이 키워드를 붙이면 가상 테이블(virtual table)이 생성된다 이를 통해서 오버라이딩이 가능해진다 ([**참고**](https://genesis8.tistory.com/105))
- C++ 가상함수의 동작 원리에 대해서 설명하면? 클래스에 한 개 이상의 가상 함수가 있을 경우, 컴파일러는 실제 호출되어야할 함수의 위치 정보를 가지고 있는 가상 함수 테이블을 만들고, 클래스 객체에는 가상 함수 테이블을 위한 포인터를 추가합니다 일반적으로 가상 함수가 있는 객체는 가상 함수 테이블에 있는 함수만을 호출하는 원칙을 가지고 있습니다 ([**참고**](https://xzio.tistory.com/1152))
- 객체지향과 절차지향의 차이는? 절차지향은 실행순서, 절차가 중점이 된다 객체지향은 필요한 객체들의 종류와 속성 등이 중점이 된다 ([**참고**](https://usefultoknow.tistory.com/entry/%EC%A0%88%EC%B0%A8%EC%A7%80%ED%96%A5Procedural-Programming-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5Object-Oriented-Programming-%EC%9E%A5%EB%8B%A8%EC%A0%90-%EB%B0%8F-%EC%B0%A8%EC%9D%B4%EC%A0%90))
- C++ 가상함수 테이블에 대해 설명하면? 컴파일 시 가상함수가 정의된 클래스가 있다면 가상함수테이블(Virtual function table)이 만들어지고, 해당 클래스로 만들어진 객체의 함수가 호출될 때 만들어진 가상함수 테이블이 참조되어 함수가 호출된다 ([**참고**](https://cosyp.tistory.com/228))
- 소멸자란 무엇인가? 객체를 더이상 사용하지 않을 때 객체를 제거하기 위해 호출되는 함수이다 ([**참고**](https://se-jung-h.tistory.com/entry/C-C-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8))
- 디폴트 생성자란 무엇인가? 생성자가 없는 경우 컴파일러에 의해 자동으로 생성되는 생성자를 디폴트 생성자라고 한다 ([**참고**](https://se-jung-h.tistory.com/entry/C-C-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8))
- 역슬레시n과 endl의 차이는 무엇인가? endl은 출력 버퍼를 비워주는 과정(flush)이 들어가 있어서 역슬레시n보다 느리다 ([**참고**](https://se-jung-h.tistory.com/entry/C-C-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8))
- 입출력 실행속도 높이는 방법은? ios::sync_with_stdio(false); 코드를 추가해 높일수 있다, 이는 C++의 iostream과 stdio와의 동기화를 끄는 기능인데, iostream과 stdio의 버퍼를 모두 사용하면 딜레이가 발생되기 때문에 이를 끊어 실행 속도를 높일수 있는 것이다 ([**참고**](https://se-jung-h.tistory.com/entry/C-C-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8))
- 업캐스팅과 다운 캐스팅의 차이는? 업캐스팅은 클래스 상속구조에서 자식타입에서 부모타입으로의 타입변환을 말하고, 다운캐스팅은 부모타입에서 자식타입으로의 변환을 말합니다 ([**참고**](https://sshoreng.tistory.com/109?category=712983))
- GetMessage()와 PeekMessage() 차이는? GetMessage 함수는 메시지가 도착하여야지만 리턴되는데 반해(동기, Synchronous), PeekMessage 함수는 메시지 큐에 도착한 메시지가 없어도 리턴한다(비동기, Asynchronous) ([**참고**](https://professorleejaeman.tistory.com/entry/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%95%A8%EC%88%98))
- 객체 지향의 5대 원칙에 대해 설명하면? (1) 개방폐쇄의 원칙, 요구사항의 변경이나 추가사항의 발생하더라도 기존 구성요소는 수정이 일어나지 말아야하며 쉽게 확장이 가능하여 재사용할 수 있어야 한다 (2) 인터페이스 분리의 원칙, 꼭 필요한 인터페이스만 상속하자는 의미 (3) 의존성 역전의 원칙, 구체적인 클래스에 의존하지 말고 최대한 추상화한 클래스에 의존하라는 뜻 (4) 리스코브 치환의 원칙, 부모 클래스를 카리키는 포인터에 해당 클래스를 상속하는 자식 클래스를 할당하더라도 모든 기능이 정상적으로 작동해야 하며 자식 클래스의 상세 내부를 부모 클래스는 알 필요가 없다는 뜻 (5) 단일 책임의 원칙, 모든 클래스는 각각 하나의 기능만 가진다는 뜻 ([**참고**](https://jaeyeong951.medium.com/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-5%EC%9B%90%EC%B9%99-solid-ac7d4d660f4d))
- 복사생성자에 대해서 설명하면? 자신과 같은 클래스 타입의 다른 객체에 대한 참조(reference)를 인수로 전달 받아, 그 참조를 가지고 자신을 초기화 하는 방법 입니다 ([**참고**](https://uncertainty-momo.tistory.com/46))
- 얕은 복사, 깊은 복사에 대해 설명하면? 얕은 복사는 메모리 자체를 복사하지 않고 주소만 복사한다 깊은 복사는 메모리 자체의 복사본을 만든다 ([**참고**](https://uncertainty-momo.tistory.com/46))
- static 메소드에 대해 설명하면? static 메소드 안에서 멤버변수에 접근 불가능하다 오직 static 멤버만 접근가능하다 static 멤버메소드 안에 멤버변수가 있다면 있지도 않은 메모리에 접근해야되기 때문에 오류가 발생하기 때문이다 설령 객체가 있다 하더라도 어떤 객체의 변수에 접근해야할지 모르기 때문에 접근자체를 막아버렸다 ([**참고**](https://velog.io/@ddongg00/C-static))
- static 클래스에 대해 설명하면? static 클래스는 모든 멤버가 static 멤버로 되어 있으며, 인스턴스화 하지 않는 클래스 이기 때문에 객체 생성이 불가능 합니다 ([**참고**](https://uncertainty-momo.tistory.com/46?category=0))
- 다중 상속의 문제점은? 가장 큰 문제점은 모호함 즉 A, B라는 클래스에 Init()이라는 가상 함수가 있고 이를 상속받은 C라는 클래스가 있다고 가정 했을 때 무엇이 호출 될지 모르는 문제점이 있습니다 ([**참고**](https://hakyoug.tistory.com/80?category=851272))
- dynamic_cast가 업, 다운 캐스팅 가능성을 검사하는 원리는? 가상함수 테이블을 이용하여 캐스팅이 가능한 자료인지 검사합니다 ([**참고**](https://hakyoug.tistory.com/80?category=851272))
- 바이트 패딩(Byte Padding) 이란? 클래스(구조체)에 바이트를 추가해 CPU 접근에 부하를 덜어주는 기법입니다 ([**참고**](https://sanghun219.tistory.com/49))
- RAII에 대해 설명하면? 자원을 안전하게 사용하기 위해 객체가 쓰이는 스코프를 벗어나면 자원을 해제해주는 기법이다 ([**참고**](https://overface.tistory.com/564))
- C++ 11의 새로운 점은? auto 키워드가 처음 등장했으며 해당 키워드는 변수의 자료형을 컴파일 시간에 자동으로 추론해줍니다, lvalue, rvalue, 이동생성자 ([**참고**](https://openmynotepad.tistory.com/20))
- 객체란 무엇인가? 데이터와 데이터를 처리하는 함수를 묶어 놓은(캡슐화한) 하나의 소프트웨어 모듈입니다 ([**참고**](https://coding-factory.tistory.com/327))
- static의 의미를 상황별로 설명하면? 전역변수에 선언된 static은 선언된 파일 내에서만 참조를 허용한다는 의미 입니다 함수 내에 선언된 static은 지역변수와 달리 함수를 빠져나가도 소멸되지 않음을 의미합니다 ([**참고**](https://blog.naver.com/PostView.nhn?blogId=sonicheroes1&logNo=220752545904))
- 상속과 포함을 결정하는데 있어 본인의 기준은 무엇인가? 상속은 is-a 관계가 확실할때 사용하는 것이 좋습니다 포함은 has-a 관계 즉 하나의 객체가 다른 객체를 파트로써 갖는 경우 사용하는 것이 좋습니다 ([**참고**](https://minusi.tistory.com/entry/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5%EC%A0%81-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C%EC%9D%98-has-a%EC%99%80-is-a-%EC%B0%A8%EC%9D%B4%EC%A0%90))
- C++에서 public 상속과 protected 상속의 차이점은? public 상속은 다른 객체에서 접근이 가능하다 하지만 protected 상속은 다른 객체에서 접근이 불가능하다 ([**참고**](https://computer-science-student.tistory.com/52)), ([**참고**](https://dev-woong.tistory.com/104))
- RTTI에 대해 설명하면? 객체 타입을 런타임중에 알아내는 매커니즘을 RTTI(Run Time Type Information)라고 한다 ([**참고**](https://ku-hug.tistory.com/70))
- 텅 빈 클래스 또는 구조체는 왜 0 사이즈가 아닐까? 클래스 또는 구조체가 사이즈 0이 될 경우 서로 다른 2개의 인스턴스가 같은 주소를 가질 수 있게 되므로, 텅 빈 클래스 또는 구조체라도 최소 1바이트 이상의 크기를 가진다 ([**참고**](https://zepeh.tistory.com/581))
- 생성자가 호출되기전에 멤버들을 초기화 시킬려면 어떻게 해야 하는가? 이니셜라이저를 활용한다 ([**참고**](https://velog.io/@jinh2352/%EC%83%9D%EC%84%B1%EC%9E%90%EC%99%80-%EC%86%8C%EB%A9%B8%EC%9E%90-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%A0%91%EA%B7%BC%EC%A7%80%EC%A0%95%EC%9E%90))
- Friend 클래스에 대해 설명하면? Friend 클래스를 사용하면 자신의 객체뿐만이 아닌 다른 타입의 객체를 접근하는 것이 가능해지기 때문에 코드의 확장이 수월하게 이루어집니다 단 이렇게 프렌드를 사용할 경우 개발자의 입장에서는 개발에 편리하겠지만 캡슐화 파괴의 주범이 되어 설계가 꼬여버리는 경우가 생길 수 있습니다 ([**참고**](https://coding-factory.tistory.com/698))
- stdcall과 cdecl의 차이를 설명하면? stdcall은 호출된 쪽(Callee)에서 직접 스택을 정리하고 가변 인자 사용이 불가능하다 cdecl은 함수를 호출한 쪽(Caller)에서 스택을 정리하고 가변 인자 사용이 가능하다 ([**참고**](https://awesomebit.tistory.com/72))
- new와 delete가 짝이 안맞으면 어떻게 될까요? 단일객체에 delete[]를 사용하면 앞쪽의 메모리 몇 바이트를 읽고 그것을 배열 크기라고 해석한다 이윽고 배열 크기에 해당하는 횟수만큼 소멸자를 호출하기 시작하지만 자신이 밟고 있는 메모리가 배열에 속해 있지 않으며 그 메모리에는 자신이 소멸시키려는 타입의 객체가 이미 들어 있지 않다는 사실에 도달한다 배열객체에 delete를 사용하면 소멸자 호출 횟수가 너무 적기 때문에 미정의 동작이 발생한다 ([**참고**](https://sexycoder.tistory.com/43))
- 스마트 포인터의 순환 참조를 해결하는 방법은? 서로를 참조하는 포인터 중 하나를 weak_ptr로 만드는 것이다 ([**참고**](https://woo-dev.tistory.com/113))
- 전방선언이 필요한 이유는? 불필요한 헤더 파일이 복잡하게 포함되는 것을 방지하며, 컴파일 속도를 향상시켜준다 ([**참고**](https://grayt.tistory.com/30))
- 포인터와 배열의 차이는? 포인터와 배열은 둘다 변수 자체는 메모리 번지를 뜻하지만, 배열은 포인터 상수여서 다른 번지를 가리킬 수 없고, 포인터는 변수이므로 대입이 가능합니다 배열은 상수이므로 증감 연산자를 사용할 수 없고, 포인터 변수는 증감 연산자를 사용할 수 있습니다 ([**참고**](https://velog.io/@mardi2020/C-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC))
- 정적 라이브러리(Static Link Library)와 동적 라이브러리(Dynamic Link Library)의 차이는? 정적 라이브러리는 필요한 함수를 프로그램 코드에 붙여 프로그램 자체에서 참조한다 동적 라이브러리는 프로그램 실행 시 필요시에만 외부 DLL 파일에서 함수를 참조한다 ([**참고**](https://luv-n-interest.tistory.com/1225))
- 정적 멤버 변수(static member variable)에 대해 설명하면? C++에서 정적 멤버란 클래스에는 속하지만, 객체 별로 할당되지 않고 클래스의 모든 객체가 공유하는 멤버를 의미합니다 ([**참고**](http://www.tcpschool.com/cpp/cpp_encapsulation_staticConst))
- 함수 객체란? 함수 객체는 함수처럼 객체가 동작한다 하여 함수 객체라고 할 수 있는데, 연산자 오버로딩에서 ()라는 연산자를 오버로딩하여 객체를 함수처럼 쓸 수 있습니다 ([**참고**](https://blog.hexabrain.net/267))
- 표현식이란 무엇인가? C++의 표현식은 값을 반환하는 모든 문장을 말한다 ([**참고**](https://digiconfactory.tistory.com/entry/C-%EB%AC%B8%EC%9E%A5Statement%EA%B3%BC-%ED%91%9C%ED%98%84%EC%8B%9DExpression-C-%EA%B3%BC-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%BC%ED%95%99))
- 람다식의 장점과 단점은? 장점은 함수를 인라인화 할 수 있다는 것이고 단점은 함수 재사용성이 낮다는 점이다 ([**참고**](https://gandis0713.github.io/2019/10/13/c-plus-lamda/)), ([**참고**](https://jjeongil.tistory.com/1044))
- 변환 생성자란? 매개변수가 하나뿐인 생성자를 변환 생성자라고 한다 묵시적 변환을 통해 임시 객체가 생성될 가능성을 가지고 있다 ([**참고**](https://snd-snd.tistory.com/74))
- 생성자 앞에 explicit 키워드를 붙여주면 어떻게 되는가? 변환 생성자의 무작위 호출을 막고 명확성을 높여준다 ([**참고**](https://ansohxxn.github.io/cpp/chapter9-11/))
- override 키워드에 대해 설명하면? override 키워드를 붙여주면 해당 함수가 상속 받아서 오버라이딩이 가능한 함수인지, 그 함수의 이름과 매개 변수등이 잘 맞는지를 컴파일러 보고 확인 하라고 떠넘길 수 있습니다 또한, 명확하게 이게 상속 받은 함수인지 눈으로 확인할 수 있습니다 ([**참고**](https://blockdmask.tistory.com/415))
- final 키워드에 대해 설명하면? 부모 클래스의 특정 멤버 함수를 자식 클래스에서 재정의 하지 못하도록 막을때 사용한다거나, 부모 클래스를 자식 클래스에서 상속 받을때 클래스 자체를 더이상 상속이 불가능하게 하려고 할 때 쓰입니다 ([**참고**](https://blockdmask.tistory.com/415))
- 전역 변수와 정적 변수의 차이는? 전역변수는 해당 프로그램(실행파일 기준)의 어느 함수, 어느 파일에서도 접근이 가능한 반면 정적변수는 변수가 선언된 파일이나 함수내에서만 접근이 가능하다 ([**참고**](https://pangate.com/541))
- 이동 생성자란? 호출된 인스턴스가 가지고있는 포인터변수의 주소값을 그대로 옮기는(이동)것이다 복사 생성자와 달리 메모리 재할당을 하지 않기 때문에 빠르다 ([**참고**](https://www.codechosun.com/296)), ([**참고**](https://modoocode.com/227)), ([**참고**](https://maxlevel-trace.tistory.com/24))
- 인터페이스, 추상 클래스, 다형성 클래스의 차이점은? 인터페이스는 구현이 없다 즉, 인터페이스 클래스에는 가상 소멸자와 순수 가상함수만 포함된다 C++에서는 하나 이상의 순수 가상 함수를 포함하는 클래스를 추상 클래스(abstract class)라고 한다 다형성 클래스는 하나 이상의 가상함수를 가진 클래스이다

### 01-2 자료구조, C++ STL ( 중요도 상 )
- vector와 list의 차이는? vector를 중간삽입시 원소를 밀어내지만 list는 노드를 연결만 하기 때문에, 삽입 삭제 부분에서 시간복잡도의 우위를 가진다 또한 vector는 메모리가 연속적이기 때문에 랜덤 접근이 가능하지만 list는 더블링크드리스트로 되어 있어 x[2]와 같은 랜덤 접근이 되지 않는다 즉 검색적인 측면에서는 vector가 우위에 있다 ([**참고**](https://chanheess.tistory.com/154))
- 단일 연결 리스트를 뒤집기 하려면? 전, 지금, 다음 포인터를 만든 뒤 지금 노드의 다음은 전 포인터를 가리킨다 전 포인터는 지금 포인터를 가리킨다 지금 포인터는 다음 포인터를 가리킨다 ([**참고**](https://www.fwantastic.com/2021/01/leetcode-206-reverse-linked-list.html)), ([**참고**](https://modernalchemist.tistory.com/43))
- Hash란 무엇인가? 데이터 삽입 및 삭제 시, 데이터와 연관된 고유한 숫자를 생성해 인덱스로 사용하는 방법 ([**참고**](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Interview/Interview%20List.md#%EC%96%B8%EC%96%B4))
- vector와 array의 차이점은? array의 크기는 고정이지만 vector는 동적으로 변하는 점이 vector와 array 자료구조의 가장 큰 차이점이다 ([**참고**](https://hanbit.co.kr/network/category/category_view.html?cms_code=CMS7393457320))
- 지역변수와 전역수가 메모리상에 어디에 어떻게 놓이나요? 지역변수는 stack 영역에, 전역변수는 data 영역에 놓인다 ([**참고**](https://snupi.tistory.com/9))
- 백터를 at(0)으로 접근 할때와 [0]으로 접근할 때의 차이는? at()은 범위를 체크하여 out_of_range 예외를 발생시킨다 [] 연산자 접근 방식은 범위를 체크하지 않는다 ([**참고**](https://kwaksh2319.tistory.com/406))
- 백터에 객체를 담는 것과 포인터를 담는 것의 차이는? 객체를 담을때는 복사생성자가 호출되고 clear을 통해 해당 원소를 제거할 수 있다 포인터를 담을때는 복사생성자가 호출되지 않고 해당 포인터가 가리키는 메모리를 직접해제 해줘야 한다 ([**참고**](https://www.wake-up-neo.net/ko/c%2B%2B/%EA%B0%9D%EC%B2%B4-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EB%B2%A1%ED%84%B0%EC%97%90%EC%84%9C-vector-erase-%EA%B0%80-%EA%B0%9D%EC%B2%B4-%EC%9E%90%EC%B2%B4%EB%A5%BC-%ED%8C%8C%EA%B4%B4%ED%95%A9%EB%8B%88%EA%B9%8C/972514417/)), ([**참고**](https://sb-story.tistory.com/9))
- 백터의 공간이 가득 찼을 때 어떻게 되는가? 현재 할당된 크기의 2배로 재할당된다, 벡터 생성시 reserve로 공간을 크게 할당해 놓으면 성능을 향상할 수 있다 ([**참고**](https://sb-story.tistory.com/9))
- unordered_map과 비교하여 map의 장점에 대해 설명하면? unordered_map은 key를 이용하여 정렬을 할 수 없고, map은 key를 이용하여 정렬을 할 수 있다 ([**참고**](https://astrid-dm.tistory.com/504))
- 부스트 라이브러리란? 단위 테스트, 이미지 처리, 멀티 스레딩, 의사 난수 생성, 선형 대수 및 정규 표현식과 같은 여러 작업 및 구조를 지원하는 라이브러리이다 ([**참고**](https://ko.theastrologypage.com/boost-libraries))
- STL이란 무엇인가? 표준 라이브러리중 하나로 프로그램에 필요한 자료구조와 알고리즘을 템플릿으로 제공합니다 ([**참고**](https://sshoreng.tistory.com/112?category=712983))
- 이진탐색트리(Binary Search Tree)이란? 다음과 같은 특징을 갖는 이진트리를 말한다 (1) 각 노드에 중복되지 않는 키가 있다 (2) 루트노드의 왼쪽 서브 트리는 해당 노드의 키보다 작은 키를 갖는 노드들로 이루어져 있다 (3) 루트노드의 오른쪽 서브 트리는 해당 노드의 키보다 큰 키를 갖는 노드들로 이루어져 있다 (4) 좌우 서브 트리도 모두 이진 탐색 트리여야 한다 ([**참고**](https://code-lab1.tistory.com/10))
- 스택과 큐의 차이는? 스택은 후입선출로 가장 마지막에 삽입된 자료부터 순서대로 꺼내지는 것이고, 큐는 선입선출로 먼저들어온 순서부터 먼저 꺼내지는 것입니다 ([**참고**](https://sshoreng.tistory.com/80?category=712983))
- map 자료구조는 어떤 형태로 되어있는가? 레드블랙이진트리의 형태로 되어 있는데, 레드블랙이진트리의 규칙은 다음과 같습니다 (1) 모든 노드는 블랙, 아니면 레드입니다 (2) 루트 노드는 블랙 노드입니다 (3) 리프 노드는 블랙 노드입니다 (4) 레드 노드의 두 자식은 모두 블랙 노드입니다 (5) 루트 노드에서 임의의 한 리프노드까지의 블랙 노드의 갯수는 모두 동일합니다 이러한 규칙을 지키는 이유는 균형잡힌 이진트리를 만들기 위함입니다 ([**참고**](https://playground10.tistory.com/204))
- 정렬 알고리즘에는 어떤 것들이 있는가? 많이 사용되는 알고리즘으로 계수정렬, 선택정렬, 삽입정렬, 퀵정렬이 있다 ([**참고**](https://velog.io/@cha-suyeon/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A0%ACSorting-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC%EC%84%A0%ED%83%9D-%EC%82%BD%EC%9E%85-%ED%80%B5-%EA%B3%84%EC%88%98%EC%A0%95%EB%A0%AC))
- 힙 자료구조란? 우선순위 큐를 위해 고안된 완전이진트리 형태의 자료구조이다 여러 개의 값 중 최댓값 또는 최솟값을 찾아내는 연산이 빠르다는 특징이 있다 ([**참고**](https://suyeon96.tistory.com/31))
- 우선순위 큐란? 우선순위가 높은 데이터가 먼저 나가는 형태의 자료구조이다 일반적으로 힙(Heap)을 이용하여 구현한다 ([**참고**](https://suyeon96.tistory.com/31))
- 해싱의 충돌 해결책에 대해 설명하면? 키에 해당하는 데이터들을 연결하는 방식인 체이닝 기법과 재해싱을 통해 다른 버킷에 데이터를 저장하는 개방주소법이 있다 ([**참고**](https://javannspring.tistory.com/238))
- stl vector에서 push_back과 emplace_back의 차이에 대해 설명하면? push_back은 삽입할 객체를 받아 임시 객체를 만들고 push_back 내부에서 복사가 일어난 뒤 vector에 추가를 한다 emplace_back은 삽입할 객체의 생성자를 위한 인자들을 받아 std::vector 내에서 직접 객체를 생성하여 삽입하므로 임시 객체의 생성과 파괴, 복사(혹은 move)를 하지 않아도 되어 성능상 push_back에 비해 유리하다 ([**참고**](https://sonagi87174.tistory.com/14))
- map 컨테이너에 대해 설명하면? key와 value로 이루어져 있으며 이는 pair 객체 형태로 저장된다 ([**참고**](https://uncertainty-momo.tistory.com/46))
- map의 장점은? Key 값으로 자동 정렬이 된다는 점과 이 Key를 통해 인자에 접근이 가능하다는 점이 장점이다 ([**참고**](https://underwatch.tistory.com/12))
- 시퀀스 컨테이너란? 자료를 입력한 순서대로 저장하기 때문에 저장 검색 알고리즘이라고 불리며 vector, list, deque등이 이에 해당합니다 ([**참고**](https://cclient.tistory.com/m/12))
- 연관 컨테이너란? 일정한 규칙에 따라 자료를 조직화하여 저장하는 것을 말하며 대표적으로 map, set이 이에 해당합니다 ([**참고**](https://cclient.tistory.com/m/12))
- 어댑터 컨테이너란? 시퀀스 컨테이너를 변형시켜 스택, 큐, 우선순위 큐 형태로 저장하는 것을 말합니다 ([**참고**](https://cclient.tistory.com/m/12))
- 컨테이너란? 같은 타입의 여러 객체를 저장하는 일종의 집합이라고 할 수 있습니다 ([**참고**](https://cclient.tistory.com/m/12))
- 이터레이터(반복자)란? 이터레이터는 컨테이너에 저장된 원소를 순회하고 접근하는 일반화된 방법을 제공합니다 또한 컨테이너와 알고리즘이 하나로 동작하게 묶어주는 인터페이스 역할을 합니다 ([**참고**](https://cclient.tistory.com/m/12))
- 트리에 대해 설명하면? 계층적인 자료를 표현하는데 이용되는 자료구조이다 관련 용어로 루트노드는 부모가 없는 최상위 노드를 뜻하며 리프노드는 자식이 없는 노드를 뜻한다 depth(깊이)는 루트 노드로부터의 거리를 뜻하고 height(높이)는 depth(깊이) 중 최댓값을 뜻한다 ([**참고**](https://jud00.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%8A%B8%EB%A6%ACTree%EB%9E%80))
- 재귀함수와 반복문의 차이는? 재귀함수는 함수 자체를 재귀적으로 호출하기 때문에 스택 프레임이 쌓여 실행 속도가 느리다 하지만 가독성이 좋다 반복문은 명령을 반복적으로 실행해 실행 속도가 빠르다 하지만 코드 길이가 길어지고 변수가 많아져 가독성이 떨어진다 ([**참고**](https://velog.io/@gillog/Algorithm-%EC%9E%AC%EA%B7%80%EC%99%80-%EB%B0%98%EB%B3%B5%EB%AC%B8))
- 해시테이블(Hash Table)과 이진탐색트리(Binary Search Tree)의 장단점 및 쓰이는 곳을 설명하면? 이진탐색트리는 딱 필요한 원소 만큼의 공간만을 할당하는 반면, 해시테이블은 해시 적중률을 높이기 위해 원소의 개수 이상의 메모리를 유지해야한다 그러므로 메모리 측면에서는 이진탐색트리가 유리하다 하지만 이진탐색트리는 노드 기반 자료구조로 메모리 파편화가 진행되어 캐시 적중률이 떨어지게 된다 반면, 해시 테이블은 배열 기반 자료구조로 연속된 메모리를 유지하기 때문에 캐시 적중률이 상당히 높다 때문에 성능이 중요한 경우 해시테이블을 사용하고 정렬이 필요한 경우 이진탐색트리를 사용한다 ([**참고**](https://algorfati.tistory.com/123))
- STL에서 erase와 remove의 차이점은? erase는 데이터 공간까지 지우기 때문에 capacity가 감소한다 remove는 지워야 할 원소의 뒤에 원소들을 하나씩 앞으로 당겨 덮어 씌움으로써 지워진 것처럼 보이게 하기 때문에 capacity가 그대로이다 ([**참고**](https://novemberfirst.tistory.com/m/111))
- List 클래스의 추가/삭제 함수를 손코딩 하면? ([**참고**](https://geundung.dev/49))
- 시간복잡도란 무엇인가? 시간 복잡도는 문제를 해결하는데 걸리는 시간과 입력의 함수 관계를 가리킨다 ([**참고**](https://ko.wikipedia.org/wiki/%EC%8B%9C%EA%B0%84_%EB%B3%B5%EC%9E%A1%EB%8F%84))
- 벡터와 일반 배열의 메모리 구조의 차이는 뭘까요? 벡터는 Heap 메모리를 사용하고, 배열은 Stack 메모리를 사용한다 ([**참고**](https://dobby-the-house-elf.tistory.com/104))
- 그래프를 정의한다면? 노드(N, node)와 그 노드를 연결하는 간선(E, edge)을 하나로 모아 놓은 자료 구조 ([**참고**](https://gmlwjd9405.github.io/2018/08/13/data-structure-graph.html))
- 해싱이란? 통상적인 반복 비교를 통하지 않고, 특정 계산 만으로 바로 자료 저장 위치를 알아내는 탐색 방법 ([**참고**](http://www.ktword.co.kr/test/view/view.php?m_temp1=5389))
- List와 Set의 차이점은? List는 중복을 허용하고 Set은 중복을 허용하지 않는다 ([**참고**](https://velog.io/@esun1903/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-List-Map-Set%EC%9D%98-%ED%8A%B9%EC%A7%95%EA%B3%BC-%EC%B0%A8%EC%9D%B4%EC%A0%90))
- 우선순위 큐의 동작 원리는? (1) 삽입할 원소는 완전 이진트리를 유지하는 형태로 순차적으로 삽입된다 (2) 삽입 이후에는 루트 노드까지 거슬러 올라가면서 최대 힙을 구성(상향식) ([**참고**](https://velog.io/@april_5/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90Priority-Queue))
- 이진트리와 이진탐색트리 차이는? 이진탐색트리는 이진트리의 특성 외에 왼쪽 자식 노드는 부모보다 작고, 오른쪽 자식 노드는 부모보다 크다는 특성을 갖고있다 ([**참고**](https://velog.io/@main_door/%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC%EC%99%80-%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC))
- 우선순위큐(PriorityQueue)의 동작원리는? 부모 노드와 자식 노드를 비교해 최대힙은 키 값이 큰 노드가 위로가게 자리를 바꾸고 최소힙은 키 값이 작은 노드가 위로가게 자리를 바꾼다 ([**참고**](https://chanhuiseok.github.io/posts/ds-4/))
- 전위 순회, 중위 순회, 후위 순회를 각각 설명하면? 전위 순회는 뿌리->왼쪽 자식->오른쪽 자식 순으로 방문한다 중위 순회는 왼쪽자식-> 뿌리-> 오른쪽 자식 순으로 방문한다 후위 순회는 왼쪽자식->오른쪽 자식-> 뿌리 순으로 방문한다 ([**참고**](https://m.blog.naver.com/rlakk11/60159303809))

### 01-3 알고리즘 ( 중요도 상 )
- QuickSort를 설명하면? 리스트 안에 있는 한 요소를 선택한다(이렇게 고른 원소를 pivot 이라고 한다) -> 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고 피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮겨진다 -> 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다 -> 부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다 ([**참고**](https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html))
- QuickSort에서 pivot을 선택하는 방법은? Median Of Three Pivot 이라는 방법이 있으며 3개의 원소를 후보로 두고 그 중간 값을 선택하는 방법이다 ([**참고**](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=ljy9378&logNo=221508655059))
- 다익스트라 알고리즘에 대해 설명하면? 특정한 노드에서 출발하여 다른 노드로 가는 최단 경로를 구해주는 알고리즘이다, 동작 원리는 ( 1 ) 출발 노드를 설정한다 -> ( 2 ) 최단 거리 테이블을 초기화한다 -> ( 3 ) 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다 -> ( 4 ) 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다 (5) 위 과정에서 3번과 4번을 반복한다 ([**참고**](https://amazelimi.tistory.com/27)), ([**참고**](https://yabmoons.tistory.com/364))
- DFS와 BFS 알고리즘의 차이는? DFS는 현재 노드에서 갈 수 있는 만큼 최대한 깊게 방문하고, 더이상 방문할 곳이 없으면 이전 노드로 돌아간다 너비우선탐색인 BFS는 같은 레벨의 인접 노드를 모두 방문한뒤 다음 레벨 인접 노드를 방문한다 ([**참고**](https://currygamedev.tistory.com/10))
- BFS와 다익스트라 알고리즘의 차이는? BFS는 간선을 이동하는 비용(가중치)을 고려하지 않고, 다익스트라 알고리즘은 해당 비용(가중치)을 고려한다 ([**참고**](https://medium.com/@pyeonjy97/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-dijkstra-algorithm-5d64a6cffced))
- 평소 자주 사용하는 정렬 알고리즘은 무엇인가? STL Sort 함수를 자주 사용하기 때문에, Quick Sort 알고리즘을 주로 사용한다고 할 수 있다 ([**참고**](https://blockdmask.tistory.com/178))
- 퀵소트와 버블 소트의 차이는? 퀵소트는 데이터가 불규칙하거나 규칙적인 것에 따라 비교 수가 변한다 버블 소트는 데이터가 불규칙하거나 규칙적인 것에 따라 비교 수가 변하지는 않는다 ([**참고**](https://studyfield.tistory.com/154))
- 병합정렬(Merge Sort) 구현 방법은? 주어진 배열을 원소가 하나 밖에 남지 않을 때까지 계속 둘로 쪼갠 후에 다시 크기 순으로 재배열 하면서 원래 크기의 배열로 합친다 ([**참고**](https://www.daleseo.com/sort-merge/))
- 퀵소트의 시간 복잡도가 O(n^2)인 경우 즉 최악의 경우는 어떻게 발생할 수 있는가? 배열이 오름차순 정렬되어있거나 내림차순 정렬되어있는 경우에 재귀 호출의 깊이 곱하기 각 재귀 호출 단계의 비교 연산 = n^2 이라는 최악의 시간복잡도를 갖는다 ([**참고**](https://gyoogle.dev/blog/algorithm/Quick%20Sort.html))
- 정렬된 원소를 가지고 있는 배열에서 원하는 원소를 찾는 방법에는 어떤 것이 있는가? 이진탐색(Binary Search)과 파라메트릭서치(Parametric Search)가 있습니다 이진 탐색은 중간값을 선택하여 찾으려는 값과 비교해 찾으려는 값이 더 클 경우 선택했던 중간값을 최솟값으로, 작을 경우 중간값을 최댓값으로 하여 원하는 값을 찾을 때까지 이 과정을 반복하는 알고리즘입니다 파라메트릭서치는 조건을 만족하는 최소/최댓값을 구하는 문제( 최적화 문제 )를 결정 문제 로 변환해 이분탐색을 수행하는 방법입니다 ([**참고**](https://velog.io/@nimok97/c-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%9C%EB%85%90-%EB%B3%B5%EC%8A%B5%ED%95%98%EA%B8%B0-18-%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89-Parametric-Search)), ([**참고**](https://loosie.tistory.com/518))
- 신장트리란(Spanning Tree)? 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프를 의미한다 ([**참고**](https://gmlwjd9405.github.io/2018/08/28/algorithm-mst.html))
- 크루스칼 알고리즘에 대해 설명하면? 크루스칼 알고리즘은 신장 트리 중에서 최소 비용으로 만들 수 있는 신장트리를 찾는 알고리즘인 최소 신장 트리 알고리즘의 대표적인 예이다 ( 내 블로그 참조 )
- 프림 알고리즘이란? 무향 연결 그래프가 주어질 때, 최소 스패닝 트리 라고 부르는 서브 그래프를 찾는 알고리즘입니다 ([**참고**](https://www.weeklyps.com/entry/%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Prims-algorithm))
- MST(Minimum Spanning Tree) 대해 설명하면? Spanning Tree 중에서 사용된 간선들의 가중치 합이 최소인 트리 ([**참고**](https://gmlwjd9405.github.io/2018/08/28/algorithm-mst.html))
- 벨만 포드 알고리즘과 다익스트라 알고리즘 차이점은? 두 알고리즘의 차이점은 간선의 가중치에 음수가 있느냐(벨만-포드) 없느냐(다익스트라)이다 ([**참고**](https://shyeon.tistory.com/2))

### 01-4 그래픽스 ( 중요도 상 )
- 벡터의 내적 외적에 대해 설명하면? 내적은 두 벡터의 각 성분끼리의 곱의 합이다, 외적은 두 벡터의 수직인 벡터를 구하는 방법이다 ([**참고**](https://math-development-geometry.tistory.com/45))
- 짐벌락에 대해 설명하면? 짐벌락은 같은 방향으로 오브젝트의 두 회전 축이 겹치는 현상을 말한다 쿼터니언은 세개의 축이 동시에 업데이트 되기 때문에 짐벌락을 해결하는 방법이 될 수 있다 ([**참고**](https://chonjay.tistory.com/entry/%EC%98%A4%EC%9D%BC%EB%9F%AC%EA%B0%81-gimbal-lock-%EB%AC%B8%EC%A0%9C%EC%BF%BC%ED%84%B0%EB%8B%88%EC%96%B8%EC%9C%BC%EB%A1%9C-%ED%95%B4%EA%B2%B0-%EA%B0%80%EB%8A%A5))
- 랜더링 파이프라인에 대해 설명하면? 입력 조립기 - 버텍스 셰이더 - 테셀레이션 - 지오메트리 셰이더 - 레스터라이저 - 픽셀 셰이더 - 출력 병합기 순으로 3차원의 가상 세계를 2차원의 이미지로 생성한다 ([**참고**](https://doobudubu.tistory.com/m/243))
- AABB, OBB 충돌 판별에 대해 설명하고 코드로 구현하면? ([**참고**](https://kareus.tistory.com/m/15)), ([**참고**](https://justicehui.github.io/other-algorithm/2018/06/23/OBB/))
- 행렬 법칙에 대해 설명하면? 행렬은 덧셈의 교환법칙, 덧셈의 결합법칙, 곱셈의 결합법칙이 성립한다  ([**참고**](http://matrix.skku.ac.kr/sglee/linear/ocu/20103.html))
- 포워드 랜더링과 디퍼드 랜더링의 차이에 대해서 설명하면? 포워드 랜더링은 3D공간에서 존재하는 폴리곤을 픽셀화하여 그 픽셀 마다 쉐이딩과 라이팅 연산을 더하는 방식입니다 해상도가 올라가도 요구하는 메모리가 디퍼드보다 적지만 라이팅 연산이 느립니다 디퍼드 렌더링은 한 화면에 수많은 라이팅 효과를 넣고 싶어서 만든 렌더링 기법입니다 실시간으로 라이팅에 반응 하는 쉐이더를 쓰는 게임은 기본적으로 디퍼드 렌더링입니다 구현방식은 폴리곤을 픽셀화하여 포토샵의 레이어처럼 정보를 나누어 비디오 메모리에 저장합니다 여기에서 각종 쉐이더와 라이팅효과를 거처 화면에 보여줍니다 ([**참고**](https://cclient.tistory.com/m/13))
- 소프트웨어 렌더러가 삼각형을 그리는 원리에 대해 설명하면? 스캔 라인 알고리즘으로 그리면 된다 삼각형을 세로로 한 줄씩 나누고 가로 일직선으로 분해한 후 그 선분을 위에서부터 차례대로 그리는 것이다 ([**참고**](https://domaindeveloper.tistory.com/38))
- 컬링 기법들을 아는대로 나열하고 설명하면? 컬링의 종류는 백페이스 컬링(BackFace Culling), 오클루전 컬링(Occlusion Culling), 프러스텀 컬링(ViewFrustum Culling)이 있다 백페이스 컬링은 물체의 뒷면을 렌더링에서 제외하는 것이다 오클루전 컬링은 다른 오브젝트에 가려진 오브젝트들은 렌더링하지 않는 것이다 프러스텀 컬링은 카메라의 뷰 프러스텀(View Frustum) 영역 밖의 오브젝트들은 렌더링하지 않는 것이다 ([**참고**](https://rito15.github.io/posts/unity-opt-occlusion-culling/))
- DirectX 9과 DirectX 11의 차이점은? 렌더링 파이프라인에서 차이가 있다 DirectX 9은 3D 좌표를 2D로 표현하기 위해 로컬 정점 -> 월드 스페이스 -> 뷰 스페이스 -> 조명 연산 -> 컬링 연산 -＞ 투영 연산 -> 클리핑 -> 뷰 포트 -> 레스터라이즈 과정을 거친다 DirectX 11은 입력 조립기 - 버텍스 셰이더 - 테셀레이션 - 지오메트리 셰이더 - 레스터라이저 - 픽셀 셰이더 - 출력 병합기 과정을 거친다 ([**참고**](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=minizang99&logNo=220963722023))
- DirectX 에서 w 나누기를 하는 이유는? 투영을 할때 동차좌표 개념을 도입해 각점을 해당 z값으로 나누기 위함이다 ([**참고**](https://www.gpgstudy.com/forum/viewtopic.php?t=6396))
- 더블 버퍼링과 스왑 체인에 대해 설명하면? 프레임 버퍼가 갱신되는 과정에서 스크린에 깜빡거림(Flickering)이 생길 수 있다 이 현상을 방지하기 위해서 전면 버퍼(front buffer)외에 화면 밖(off screen)의 후면 버퍼(back buffer)를 추가적으로 두는데, 이 방식을 이중 버퍼링 이라고 하고 한다 또한 후면 버퍼에 그리기가 완료되면 전면 버퍼와 후면 버퍼를 교환하는데 이때 비디오 컨트롤러는 전면 버퍼 만을 참조해 스크린을 갱신한다 이 방식을 스왑체인 이라고 한다 ([**참고**](https://handhp1.tistory.com/10))

### 01-5 운영체제 ( 중요도 중 )
- 운영체제가 사용하는 메모리 영역에 대해 설명하면? OS 메모리 구조는 2가지 영역으로 나누는데 바로 유저 영역, 커널 영역이다 유저영역 메모리는 4가지로 나눠지는데 데이터영역, 힙영역, 코드영역, 스택 영역으로 구분이 된다 그리고 커널 영역은 시스템 운영에 필요한 메모리로 운영체제가 올려져 있다 ([**참고**](https://webstone.tistory.com/96))
- 스레드란 무엇인가? 프로세스가 할당받은 자원을 이용하는 실행 단위다 ([**참고**](https://becomeweasel.me/process-and-thread/))
- 프로세스가 사용하는 메모리 영역과 스레드가 사용하는 메모리 영역의 차이점은? 프로세스는 각자 본인이 사용하는 메모리 영역과 레지스터 값을 가지며 프로세스의 메모리 영역은 데이터, 힙, 코드, 스택 영역으로 구성된다 그리고 스레드는 각자의 레지스터와 스택을 가지지만, 나머지 영역은 가지지 않는다. 대신에 데이터, 힙, 코드 영역을 공유해서 병렬적인 수행이 가능하다. ([**참고**](https://becomeweasel.me/process-and-thread/))
- 라운드 로빈 알고리즘에 대해서 설명(사용하는 이유, 멀티 스레드 환경에서의 필요성)하면? 라운드 로빈(RR) 스케쥴링 알고리즘은 시간 할당량 또는 타임슬라이스 라고 하는 작은 단위의 시간을 정의하고 CPU 스케쥴러는 준비 큐를 돌면서 한 번에 한 프로세스에 정의된 시간 할당량 동안 CPU를 할당한다 사용하는 이유와 필요성은 멀티 스레드 환경에서 하나의 스레드가 CPU를 독점하는 상황과 다른 스레드가 실행되지 못하고 무한정 기다리는 '기아' 현상을 막기 위해 각 스레드에 적절한 CPU 사용 시간을 부여하여 모든 스레드가 순환적으로 실행되도록 하기 위함 ([**참고**](https://woo-dev.tistory.com/163))
- 컴퓨터에 존재하는 메모리들의 액세스 속도를 설명 하면? 레지스터는 프로세서에 위치한 고속 메모리로 프로세서가 바로 사용할 수 있는 데이터를 담고있다, 캐시는 레지스터 다음으로 빠른 메모리이며 CPU 내부에 존재한다 CPU와 주기억장치간의 속도 차이로 인한 성능 저하를 막기 위해 사용된다, 주기억장치는 CPU가 처리하고 있는 내용이 가져와지는 곳을 말한다, 보조기억장치는 주기억장치보다는 느리지만 많은 양의 데이터를 전원이 꺼져도 사라지지 않고 영구적으로 보관할 수 있는 장치이다 ([**참고**](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=cjsksk3113&logNo=222246966805))
- context switching에 대해 설명하면? 현재 진행하고 있는 Task(Process, Thread)의 상태를 저장하고 다음 진행할 Task의 상태 값(PCB)을 읽어 적용하는 과정을 말합니다 ([**참고**](https://nesoy.github.io/articles/2018-11/Context-Switching))
- PCB에 대해서 설명하면? 운영체제에서 프로세스에 대한 메타데이터(대량의 정보 가운데에서 확인하고자 하는 정보를 효율적으로 검색하기 위해 원시데이터)를 저장한‘데이터’를 말하며 프로세스 스케줄링 상태, 프로세스 ID 등의 정보로 이루어져 있다 ( 내 블로그 참고 )
- 스레드 프로그래밍에서 중요한건? 스레드 마다 별도로 주어지는 공간(스택), 모든 스레드가 공유하는 공간(힙, 데이터 영역)에 대해 파악하고 코드를 작성해야 한다 ([**참고**](https://elky.tistory.com/285))
- 블로킹(blocking) vs 논블로킹(non-blocking)에 대해서 설명하면? blocking은 A 함수가 B 함수를 호출 할 때, B 함수가 자신의 작업이 종료되기 전까지 A 함수에게 제어권을 돌려주지 않는 것 non-blocking은 A 함수가 B 함수를 호출 할 때, B 함수가 제어권을 바로 A 함수에게 넘겨주면서, A 함수가 다른 일을 할 수 있도록 하는 것 ([**참고**](https://jh-7.tistory.com/25))
- 프로세스와 스레드의 차이는? 프로세스는 메모리 상에서 실행중인 프로그램을 말하며, 스레드는 이 프로세스 안에서 실행되는 흐름 단위를 말한다 ([**참고**](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Interview/Interview%20List.md#%EC%96%B8%EC%96%B4))
- 멀티 프로세스로 처리 가능한걸 굳이 멀티 스레드로 하는 이유는? 프로세스를 생성하여 자원을 할당하는 시스템 콜이 감소함으로써 자원의 효율적 관리가 가능하며, 프로세스 간의 통신(IPC)보다 스레드 간의 통신 비용이 적어 작업들 간 부담이 감소함, 대신 동기화에 신경을 써야한다 ([**참고**](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Interview/Interview%20List.md#%EC%96%B8%EC%96%B4))
- 교착상태(데드락)가 무엇이며 4가지 조건은? 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태이며 상호배제, 점유대기, 비선점, 순환대기 이 4가지 조건 중 하나라도 만족하지 않으면 교착상태는 발생하지 않는다 ([**참고**](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Interview/Interview%20List.md#%EC%96%B8%EC%96%B4)), ([**참고**](https://velog.io/@dl_edge/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-4%EA%B0%80%EC%A7%80-%EC%A1%B0%EA%B1%B4))
- 교착상태를 해결하는 방법은? 예방, 탐지, 회피, 무시 ([**참고**](https://hoyeonkim795.github.io/posts/%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/))
- 메모리 할당 알고리즘 3가지는? First fit은 메모리의 첨부터 검사해서 크기가 충분한 첫 번째 메모리에 할당, Next fit은 마지막으로 참조한 메모리 공간에서부터 탐색을 시작해 공간을 찾아 할당, Best fit은 모든 메모리 공간을 검사해서 내부 단편화를 최소화하는 공간에 할당 ([**참고**](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Interview/Interview%20List.md#%EC%96%B8%EC%96%B4))
- 페이지 폴트란 무엇인가? CPU가 프로그램을 실행하면서 필요한 페이지가 물리적 메모리에 없는 경우도 생기게 되는데 이것을 페이지 폴트(Page Fault)라고 한다 ([**참고**](https://velog.io/@jiseong/OS-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%80%ED%8F%B4%ED%8A%B8-gyq8tftz))
- 페이지 폴트 발생시 사용하는 알고리즘과 해당 알고리즘에 대해 설명하면? 페이지 교체 알고리즘을 사용하며, OPT는 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체 ( 실현 가능성 없음 ), FIFO는 메모리가 할당된 순서대로 페이지를 교체, LRU는 가장 오랫동안 사용되지 않은 페이지 교체, LFU는 사용 빈도가 가장 적은 페이지를 교체, NUR은 최근에 사용하지 않은 페이지를 교체 ([**참고**](https://velog.io/@jiseong/OS-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%80%ED%8F%B4%ED%8A%B8-gyq8tftz))
- 내부 단편화와 외부 단편화를 설명하면? 내부 단편화는 메모리를 나눈 크기보다 프로그램이 작아서 사용하지 못하는 공간이 많이 발생하는 현상이다, 외부 단편화란 남아있는 총 메모리 공간이 요청한 메모리 공간보다 크지만, 남아있는 공간이 연속적(contiguous)이지 않아 사용하지 못하는 공간이 발생하는 현상이다 ([**참고**](https://code-lab1.tistory.com/54))
- 가상메모리란? 실제로 프로그램 수행에 필요한 부분만 메모리에 올려놓음으로써 주기억장치의 용량보다 큰 프로세스라도 사용자가 메모리에 올려놓을 수 있게 하는 기법이다 ([**참고**](https://luv-n-interest.tistory.com/1005))
- 페이징의 정의와 작동하는 원리를 설명하면? 페이징은 virtual memory를 page로 나누는 기법을 말하며 주기억장치와 보조기억장치의 데이터 공간을 모두 동일한 크기로 나눈뒤 데이터 접근이 일어날 때, 보조기억장치에서 필요한 페이지들을 꺼내 주기억장치의 영역(프레임)에 적재시킨다 ([**참고**](https://velog.io/@dd9s2/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EA%B8%B0%EC%96%B5-%EC%9E%A5%EC%B9%98%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%95-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98-Virtual-Memory-Paging-Segmentation))
- 세그먼테이션에 대해 설명하면? 메모리를 서로 크기가 다른 논리적인 블록 단위인 '세그먼트(segment)'로 분할하고 메모리를 할당하여 물리 주소를 논리 주소로 변환하는 것을 말한다 ( 미리 분할하지 않고 메모리를 사용할 시점에 할당된다는 것이 중요하다 ) ([**참고**](https://plummmm.tistory.com/356))
- 세마포어, 뮤텍스의 정의와 차이점을 설명하면? 세마포어는 공유 자원에 대한 접근을 제한하는 방법이며, 뮤텍스는 임계 구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술이다 차이점은 뮤텍스는 동기화 대상이 오직 1개일 때 사용하며, 세마포어는 동기화 대상이 1개 이상일 때 사용한다 ([**참고**](https://gyoogle.dev/blog/computer-science/operating-system/Semaphore%20&%20Mutex.html)), ([**참고**](https://heeonii.tistory.com/14))
- 사용자 수준 스레드의 정의와 장단점을 설명하면? 사용자 스레드는 커널 영역의 상위에서 지원되며 일반적으로 사용자 레벨의 라이브러리를 통해 구현된다 라이브러리는 스레드의 생성 및 스케줄링 등에 관한 관리 기능을 제공한다 장점은 스케줄링과 동기화를 위해 System Call(커널 호출) 하지 않기 때문에 오버헤드 적다는 것이고(Context Switching을 프로세스 내부에서 진행하면 됨) 단점은 하나의 스레드가 System Call(커널 호출)하면 해당 프로세스 내 모든 스레드가 중단된다는 것이다 ([**참고**](https://kspsd.tistory.com/50))
- 커널 수준 스레드의 정의와 장단점을 설명하면? 커널 스레드는 운영체제가 지원하는 스레드 기능으로 구현되며, 커널이 스레드의 생성 및 스케줄링 등을 관리한다 장점은 커널이 각 스레드를 개별적으로 관리할 수 있다는 것이고 단점은 유저 모드와 커널 모드 간 전환이 빈번하여 성능 저하된다는 것이다 ([**참고**](https://kspsd.tistory.com/50))
- Race Condition에 대해서 설명하면? Race Condition이란 두 개 이상의 cocurrent한 프로세스(혹은 스레드)들이 하나의 자원(리소스)에 접근하기 위해 경쟁하는 상태를 말합니다, 여기서 cocurrent하다는 말은 동시성(병행성)을 가진다는 말이다 ([**참고**](https://zangzangs.tistory.com/115)), ([**참고**](https://seamless.tistory.com/42))
- 동기(Synchronous) vs 비동기(Asynchronous)에 대해서 설명하면? 함수 A가 함수 B를 호출한 뒤, 함수 B의 리턴값을 계속 확인하면서 신경쓰는 것이 동기이다 비동기는 함수 A가 함수 B를 호출한 뒤, 함수 B의 리턴값이 반환 되었는지 신경쓰지 않는다 ([**참고**](https://velog.io/@nittre/%EB%B8%94%EB%A1%9C%ED%82%B9-Vs.-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8F%99%EA%B8%B0-Vs.-%EB%B9%84%EB%8F%99%EA%B8%B0))
- 메모리 구조에서 스택과 큐의 역할은? 메모리에서 스택은 지역변수와 매개변수 데이터 값이 저장되는 공간이며, 메소드 호출시 매모리에 할당되고 종료되면 메모리가 해제된다 큐는 heap의 FIFO 성질을 구현하기위해 사용된다 ([**참고**](https://velog.io/@kingyong9169/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0))
- context switching의 오버헤드의 주원인은? context switching 때 해당 CPU는 아무런 일을 하지 못한다, 따라서 컨텍스트 스위칭이 잦아지면 오히려 오버헤드가 발생해 효율(성능)이 떨어진다 ([**참고**](https://landwhale2.github.io/cs/106/))
- 메모리 단편화와 해결책에 대해서 설명하면? 사용가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태를 보고 메모리 단편화가 발생했다고 한다 해결책에는 세그먼테이션(내부단편화), 페이징(외부단편화), 메모리풀(모두해결), 통합(모두해결), 압축(모두해결)과 같은 기법들이 있다 ([**참고**](https://gguljaem.tistory.com/entry/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94Fragmentation%EC%97%90-%EB%8C%80%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95))
- 시스템 콜이란? 프로세스가 운영체제(system)에게 운영체제 기능을 요청(call)하는 것입니다 ([**참고**](https://dolphinsarah.tistory.com/54))
- 좀비 프로세스에 대해서 설명하면? 실행이 종료되었지만 아직 삭제되지 않은 프로세스를 말한다 ([**참고**](https://www.joinc.co.kr/w/Site/system_programing/process/Zombie))
- 고아 프로세스에 대해서 설명하면? 부모프로세스가 필요에 의해서 먼저 종료 되기도 하는데, 이때 자식프로세스만 남게 되는경우 이 자식프로세스를 고아프로세스라고 한다 ([**참고**](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=icecds&logNo=40053269520))
- 데몬 프로세스에 대해서 설명하면? 백그라운드로 사용자 모르게 동작하는 프로세스를 말한다 ([**참고**](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=icecds&logNo=40053269520))
- 메모리풀의 정의와 장단점을 설명하면? 메모리풀은 메모리를 미리 할당 받아놓고, 사용자가 필요할 때 메모리를 제공하는 것을 말합니다 장점은 메모리 단편화가 줄어듭니다 단점은 메모리 사용 효율성이 떨어질 수 있습니다 ([**참고**](https://linkmemo.tistory.com/183))
- 메모리 구조에 대해 설명하면? 실행할 프로그램의 코드가 저장되어 프로그램이 종료되어야 소멸되는 코드영역, 전역변수와 정적변수가 저장되고 프로그램이 종료되어야 소멸되는 데이터 영역, 함수의 호출과 관계되는 지역변수와 매개변수가 저장되며 함수의 호출과 함께 할당되고 함수의 호출이 완료되면 소멸하는 스택영역, 사용자가 직접 관리할 수 있고 사용자에 의해 메모리 공간이 동적으로 할당되고 해제되는 힙영역이 있습니다 ([**참고**](https://sshoreng.tistory.com/80?category=712983))
- 멀티프로세스와 멀티쓰레드의 차이는? 멀티프로세스는 여러개의 일을 복수의 프로세스가 처리하는 하며 프로세스간 통신 코스트가 크다는 특징이 있습니다 멀티쓰레드는 한개의 일을 복수의 쓰레드가 처리하는 것인데, 공유 메모리를 써서 메모리를 적게 사용하며 하나의 일처리를 분산할 수 있지만, 쓰레드간의 간섭이 있어 잘 예상하고 구현해야합니다 ([**참고**](https://sshoreng.tistory.com/80?category=712983))
- 싱글스레드와 멀티스레드의 효율성을 비교하면? 단순히 CPU만을 사용하는 계산작업이 주로 일어나는 경우 멀티 스레드보다 오히려 싱글 스레드를 이용하는 것이 효율적이다 멀티 스레드는 context switching이 일어나는 시간이 추가로 걸리기 때문이다 CPU 이외의 자원을 사용하는 작업의 경우 싱글 스레드보다 멀티 스레드로 하는 것이 효율적이다 예를 들어 사용자에게 입력받는 작업과 출력하는 작업 두 가지를 해야한다면, 싱글 스레드의 경우 사용자가 입력을 다할 때 까지 출력은 하지 못하고 기다리고만 있어야 한다 하지만 여러개의 쓰레드를 이용한다면 사용자가 입력하는 걸 기다리는 동안 출력이라는 작업으로 context switching 하여 해당 작업을 수행할 수 있으므로 좀 더 효율적으로 동작하게 된다 ([**참고**](https://excited-hyun.tistory.com/255))
- 임계 영역(크리티컬 섹션)의 두가지 의미에 대해서 설명하면? (1) 둘 이상의 쓰레드가 동시에 실행될 경우 접근 문제를 발생시킬 수 있는 코드 블록을 임계 영역이라고 한다 (2) 임계 영역에 대한 문제를 해결하는 동기화 기법을 의미하기도 한다, 특정 임계 영역에 대한 키를 가져야만 해당 영역에 접근할 수 있도록 하는 기법이다 ([**참고**](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=cmw1728&logNo=220479810666))
- 멀티 쓰레드란? 하나의 프로세스 내에서 둘 이상의 스레드가 동시에 작업을 수행하는 것을 의미합니다 ([**참고**](http://www.tcpschool.com/java/java_thread_multi))
- 힙영역에 대해 설명하면? 힙영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제되는 영역입니다 ([**참고**](https://velog.io/@tonic523/%ED%9E%99-%EC%98%81%EC%97%AD-vs-%EC%8A%A4%ED%83%9D-%EC%98%81%EC%97%AD))
- 스택영역에 대해 설명하면? 스택영역은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역입니다 ([**참고**](https://velog.io/@tonic523/%ED%9E%99-%EC%98%81%EC%97%AD-vs-%EC%8A%A4%ED%83%9D-%EC%98%81%EC%97%AD))
- 크리티컬 섹션과 뮤텍스의 차이는? 크리티컬 섹션은 한 프로세스 내의 쓰레드 사이에서만 동기화가 가능한 반면, 뮤텍스는 여러 프로세스의 스레드 사이에서 동기화가 가능하다 뮤텍스를 가장 흔히 사용하는 예가 프로세스 다중 실행을 막을 때이다 ([**참고**](https://genesis8.tistory.com/154))
- 캐시에 대해 설명하면? 데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치의 속도 차이에 따른 병목 현상을 줄이기 위한 메모리를 말한다 ([**참고**](https://gyoogle.dev/blog/computer-science/computer-architecture/%EC%BA%90%EC%8B%9C%20%EB%A9%94%EB%AA%A8%EB%A6%AC.html))
- 시간적 지역성과 공간적 지역성에 대해 설명하면? 시간적 지역성은 최근 액세스 된 기억 장소가 가까운 미래에 다시 액세스 될 가능성 높다는 의미이다 공간적 지역성은 액세스된 기억장소와 인접한 기억장소가 액세스될 가능성 높다는 의미이다 ([**참고**](http://blog.skby.net/%EC%A7%80%EC%97%AD%EC%84%B1-locality/))
- data영역과 bss영역을 구분하는 이유는? 초기화되지 않은 변수는 프로그램이 실행될 때 영역만 잡아주면 되고 그 값을 프로그램에 저장하고 있을 필요는 없으나(bss 영역) 초기화가 되는 변수는 그 값도 프로그램에 저장하고 있어야 하기 때문이다(data 영역) ([**참고**](https://velog.io/@tkddn2075/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84))
- Heap Overflow와 Stack Overflow에 대해 설명하면? Heap Overflow는 heap이 위에서부터 주소값을 채우며 내려오다가 stack영역을 침범하는 경우이다 Stack Overflow는 밑에서 부터 주소값을 채우며 올라가다가 heap 영역을 침범하는 경우이다 ([**참고**](https://namoeye.tistory.com/entry/%EB%A9%B4%EC%A0%91%EB%8C%80%EB%B9%84-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC))
- 스택을 스레드마다 독립적으로 할당하는 이유는? 스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가되는 것이다 따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당한다 ([**참고**](https://jungeun960.tistory.com/100))
- 스레드가 프로세스보다 콘텍스트 스위칭이 빠른 이유는? 스레드는 콘텍스트 스위칭될 때 스택(Stack)을 제외한 코드(Code), 데이터(Data), 힙(Heap) 영역은 프로세스의 것이기 때문에 자신의 TCB에는 스택 및 간단한 정보만 저장해서 프로세스 콘텍스트 스위칭보다 빠르다 반면에 프로세스는 공유하는 데이터가 없으므로 임시 저장소인 캐시 메모리가 지금껏 쌓아놓은 데이터들을 지우고 새로 데이터를 쌓아야 한다 ([**참고**](https://beststar-1.tistory.com/26#%EC%8A%A4%EB%A0%88%EB%93%9C%EC%99%80_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%A4%91_%EC%BD%98%ED%85%8D%EC%8A%A4%ED%8A%B8_%EC%8A%A4%EC%9C%84%EC%B9%AD%EC%9D%B4_%EB%B9%A0%EB%A5%B8_%EA%B2%83%EC%9D%80?_-_%EC%8A%A4%EB%A0%88%EB%93%9C)), ([**참고**](https://vicente-blog.com/blog/68/))
- 동기화란 무엇인가? 프로세스 또는 스레드들이 수행되는 시점을 조절하여 서로가 알고 있는 정보가 일치하는 것을 의미합니다 ([**참고**](https://ooeunz.tistory.com/94))
- 유저모드 동기화 커널모드 동기화에 대해서 설명하면? 유저모드 동기화란 커널의 힘을 빌리지 않는(커널 코드가 실행되지 않는) 동기화 기법 이며 크리티컬 섹션 기반 동기화와 인터락 함수 기반 동기화가 있다 커널 모드 동기화는 커널에서 제공하는 동기화 기능을 활용하는 방법이며 뮤텍스 기반의 동기화, 세마포어 기반의 동기화가 있다 ([**참고**](https://namoeye.tistory.com/entry/%EB%A9%B4%EC%A0%91%EB%8C%80%EB%B9%84-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC))
- 스핀락이란? 스핀락(spinlock)은 임계 구역(critical section)에 진입이 불가능할 때 진입이 가능할 때까지 루프를 돌면서 재시도하는 방식으로 구현된 락을 가리킨다 ([**참고**](https://ko.wikipedia.org/wiki/%EC%8A%A4%ED%95%80%EB%9D%BD))
- 인터럽트란 무엇인가? 프로그램을 실행하는 도중에 예기치 않은 상황이 발생한 경우, 현재 실행중인 작업을 즉시 중단하고, 발생된 상황을 우선 처리한 후 실행중이던 작업으로 복귀하여 계속 처리하는 것이다 ([**참고**](https://luv-n-interest.tistory.com/1168))
- C/C++ free/delete 없이 프로그램을 종료한다면? 현대의 Operating System은 Process 종료 시 Process가 사용중인 메모리를 모두 자동으로 반환 시킨다 ([**참고**](https://yhwanp.github.io/2019/12/14/c-delete-free-when-process-exit/))

### 01-6 네트워크 ( 중요도 하 )
- 소켓 프로그래밍이란 무엇인가? 보통 OSI 7 Layer(Open System Interconnection 7 Layer)의 네 번째 계층인 TCP(Transport Control Protocol) 상에서 동작하는 소켓을 주로 사용하는데, 이를 "TCP 소켓" 또는 "TCP/IP 소켓"이라고 부른며 이를 기반으로 네트워크 통신 기능을 프로그래밍 하는 것 입니다 ([**참고**](https://tyrionlife.tistory.com/781))
- HTTP, TCP, UDP에 대해 설명하면? HTTP는 클라이언트와 서버 간 데이터를 주고 받기 위한 규칙(프로토콜)이다 여기서 데이터는 텍스트, 이미지, 동영상 등 모든 종류를 말한다 HTTP 종류에는 TCP 와 UDP 방식이 있으며 80번 포트를 사용한다 TCP는 1:1 연결을 지향하며 신뢰할 수 있는 통신을 제공한다, 여기서 1:1은 각각 클라이언트와 서버를 의미한다, 양 단에 연결을 수립한 뒤 데이터를 전송한다 UDP는 1:1 혹은 1:N 비연결을 지향하며 신뢰할 수 없는 통신을 제공한다, 여기서 '비연결' 이라는 말은 말 그대로 서버와 클라이언트가 연결되어 있지 않다는 뜻이다, TCP 와 달리 연결 설정 과정이 필요 없고 단지 소켓의 생성과 데이터 송수신 과정만 존재한다 ([**참고**](https://doozi0316.tistory.com/entry/HTTPHTTPS%EB%9E%80-TCP-UDP-HandShake-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC))
- TCP와 UDP의 차이에 대해 설명하면? TCP는 전송 순서를 보장하며 가상 회선 방식을 사용하고 연결형 서비스이며 1:1 통신만 가능하다 UDP는 전송 순서를 보장하지 않으며 데이터그램 방식을 사용하고 비 연결형 서비스이며 N:N 통신이 가능하다 ([**참고**](https://coding-factory.tistory.com/614))
- TCP의 Nagle 알고리즘에 대해 설명하면? 네트워크 전송 횟수는 줄이고 작은 데이터를 여러번 전송하기보단 데이터를 묶어서 한 번에 보내는 방식을 사용한다 ([**참고**](https://devjh.tistory.com/106))
- 3-way handshake 과정에서 통신이 안되면 어떤일이 벌어질지 설명하면? 타임아웃(Timeout)이 발생하고, 해당 네트워크는 연결되지 않는 것으로 처리한다 ([**참고**](https://hyoje420.tistory.com/4))
- 4-way handshake(종료과정)을 설명하면? (1) 먼저 통신을 종료하고자 하는 클라이언트는 서버에게 FIN 플래그를 세팅한 패킷을 보내고 자신은 FIN_WAIT_1 상태가 된다 (2) FIN 을 수신한 서버는 ACK를 클라이언트에게 전송하고 소켓의 상태를 CLOSE_WAIT로 변경한다 (3) ACK를 수신한 클라이언트는 서버가 FIN을 잘 받았다고 판단하고 FIN_WAIT_2로 소켓의 상태를 변경한 뒤 다시 FIN 패킷을 기다린다 (4) FIN을 클라이언트에게 전송한 서버는 다시 FIN 패킷을 클라이언트로 전송한 뒤 소켓을 LAST_ACK 상태로 변경한다 (5) FIN을 수신한 클라이언트는 서버에게 ACK를 전송한 뒤 소켓의 상태를 TIME_WAIT 상태로 변경한다 (6) 클라이언트로부터 마지막 ACK를 수신한 서버는 소켓을 CLOSED 한다 ([**참고**](https://blogger.pe.kr/390))
- TCP, UDP에서 checksum의 특징 및 차이에 대해 설명하면? TCP는 checksum이 필수이고 udp는 선택이다 ([**참고**](https://poododang.tistory.com/entry/TCPUDP))
- TCP/IP란 무엇인가? TCP/IP(Transmission Control Protocol/Internet Protocol)는 데이터가 의도된 목적지에 도착할 수 있도록 보장해주는 통신 규약입니다 ([**참고**](https://coding-factory.tistory.com/613))
- TCP Flag 종류에 대해 설명하면? SYN(연결 요청 플래그) ACK(응답 플래그) FIN(연결 종료 플래그) 등이 있다 ([**참고**](https://hongpossible.tistory.com/entry/TCP-Flag%EB%9E%80))
- OSI 7계층을 왜 나눴는지 설명하면? 통신이 일어나는 과정을 단계 별로 파악할 수 있기 때문이다 흐름을 한 눈에 알아보기 쉽고, 사람들이 이해하기 쉽고, 7단계 중 특정한 곳에 이상이 생기면 다른 단계의 장비 및 소프트웨어를 건드리지 않고도 이상이 생긴 단계만 고칠 수 있다 ([**참고**](https://steady-coding.tistory.com/504))
- http와 https의 차이에 대해 설명하면? HTTP는 암호화가 추가되지 않았기 때문에 보안에 취약한 반면, HTTPS는 안전하게 데이터를 주고받을 수 있다 하지만 HTTPS를 이용하면 암호화/복호화의 과정이 필요하기 때문에 HTTP보다 속도가 느리다 ([**참고**](https://mangkyu.tistory.com/98))
- OSI 7계층에 대해 설명하면? 1계층 - 물리계층(Physical Layer), 인터넷 케이블, 라우터 스위치 등의 전기적 신호가 물리적인 장치에 의해 왔다 갔다(통신) 하는 계층이다 2계층 - 데이터 링크계층(DataLink Layer), 물리계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 안전한 정보의 전달을 수행할 수 있도록 도와주는 역할을 한다 3계층 - 네트워크 계층(Network Layer), 경로를 선택하고 주소를 정하고 경로에 따라 패킷을 전달해주는 것이 이 계층의 주 역할이다 4계층 - 전송 계층(Transport Layer), 이 계층은 통신을 활성화하기 위한 계층이며 보통 TCP 프로토콜을 이용하며, 포트를 열어서 응용프로그램들이 전송을 할 수 있게 한다 5계층 - 세션 계층(Session Layer), 양 끝단의 응용 프로세스가 통신을 관리하는 방법을 제공하는 계층이다 6계층 - 표현 계층(Presentation Layer), 코드 간 번역을 담당하는 계층이다 7계층 - 응용 계층(Application Layer), 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행하는 계층이다 ([**참고**](https://onecoin-life.com/19))
- 3-way handshake 과정에 대해 설명하면? (1) 클라이언트는 서버와 커넥션을 연결하기 위해 SYN을 보낸다 (2) 서버가 SYN을 받고, 클라이언트로 받았다는 신호인 ACK와 SYN 패킷을 보냄 (3) 클라이언트는 서버의 응답인 ACK와 SYN 패킷을 받고, ACK를 서버로 보냄 ([**참고**](https://velog.io/@averycode/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-TCPUDP%EC%99%80-3-Way-Handshake4-Way-Handshake))
- HTTP 프로토콜이란? 서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜입니다 ([**참고**](https://mangkyu.tistory.com/91))
- 라우터와 스위치의 차이는? 스위치는 데이터 링크 계층에, 라우터는 네트워크 계층에 속한다 그래서 스위치는 MAC 주소를 기반으로 작동하고, 라우터는 IP주소를 기반으로 작동한다 ( 내 블로그 참고 )
- DNS란? 국제적 단위로 웹사이트의 IP 주소와 도메인 주소를 이어주는 환경/시스템이다 ([**참고**](https://gentlysallim.com/dns%EB%9E%80-%EB%AD%90%EA%B3%A0-%EB%84%A4%EC%9E%84%EC%84%9C%EB%B2%84%EB%9E%80-%EB%AD%94%EC%A7%80-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC/))
- LAN이란? Local Area Network의 줄인 말로 근거리 통신망입니다 ([**참고**](https://enlqn1010.tistory.com/13))
- WAN이란? Wide  Area Network의 줄인 말로 LAN보다 범위가 넓은 광대역 통신망입니다 ([**참고**](https://enlqn1010.tistory.com/13))

### 01-7 데이터 베이스 ( 중요도 하 )
- JOIN의 정의와 종류에 대해 설명하면? 테이블별로 분리되어 있는 데이터를 연결하여 하나의 결과 데이터 셋으로 출력해야 할 때가 반드시 존재합니다 이럴때 사용하는 것이 조인(Join)이다 종류는 Inner join, Left outer join, Right outer join, Full outer join이 있다 ([**참고**](https://sparkdia.tistory.com/17))
- 클러스터링 인덱스와 넌클러스터링 인덱스의 차이점는? 클러스터드 인덱스는 물리적으로 행을 재배열하고, 넌클러스터드 인덱스는 물리적으로 재배열 하지 않는다 ([**참고**](https://m.blog.naver.com/islove8587/220431192221))
- DB Index의 정의와 사용하는 이유를 설명하면? 인덱스는 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료 구조라고 한다 사용하는 이유는 데이터들을 정렬하기 위함이다 ([**참고**](https://choicode.tistory.com/27))
- DB Index의 트리 구조를 설명하면? Root(기준) / Branch(중간) / Leaf(말단) Node로 구성되며 계층적 구조를 갖고 있다 ([**참고**](https://choicode.tistory.com/27))
- 클러스터링 인덱스란? 프라이머리 키값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라 한다 ([**참고**](https://dev-ppyong.tistory.com/11))
- DB collision에 대해 설명하고 해결방법을 제시하면? Collision(충돌 현상)은 서로 다른 두 개 이상의 레코드가 같은 주소를 갖는 현상이다 해결법에는 개방 주소법(Open Addressing)이 있다 ([**참고**](https://developer-rooney.tistory.com/67))
- DB Isolation에 대해 설명하면? 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것 ([**참고**](https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation))
- Nosql과 RDBMS의 차이는? RDBMS는 정해진 스키마에 따라 데이터를 저장하여야 하므로 명확한 데이터 구조를 보장한다 NoSQL은 스키마가 없기 때문에 유연하며 자유로운 데이터 구조를 가질 수 있다 ([**참고**](https://pythontoomuchinformation.tistory.com/528))
- 정규화 개념과 각 단계를 설명하면? 관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스를 정규화(Normalization)라고 한다 제1 정규화란 테이블의 컬럼이 원자값(Atomic Value, 하나의 값)을 갖도록 테이블을 분해하는 것이다 제2 정규화란 제1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것이다 제3 정규화란 제2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것이다 BCNF 정규화란 제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것이다 ([**참고**](https://mangkyu.tistory.com/110))
- 비관적 락과 낙관적 락에 대해 설명하면? 비관적 락은 자원 요청에 따른 동시성문제가 발생할것이라고 예상하고 락을 걸어버리는 방법론입니다 낙관적 락은 자원에 락을 걸어서 선점하지말고, 동시성 문제가 발생하면 그때 가서 처리 하자는 방법론입니다 ([**참고**](https://unluckyjung.github.io/db/2022/03/07/Optimistic-vs-Pessimistic-Lock/))

### 01-8 디자인 패턴 ( 중요도 하 )
- 디자인 패턴이란? 자주 사용하는 설계 형태를 정형화해서 형식을 만들어 두는 것 입니다 ([**참고**](https://sshoreng.tistory.com/112?category=712983))
- 컴포넌트 패턴에 대해 설명하면? 한 객체가 여러 분야를 서로 커플링(결합도) 없이 다룰 수 있게 한다 ([**참고**](https://boycoding.tistory.com/118))

<br>

## 참고한 블로그 주소들

### 목록
- https://github.com/jobhope/TechnicalNote/blob/master/InterviewQuestions.md
- https://github.com/JaeYeopHan/Interview_Question_for_Beginner
- https://woo-dev.tistory.com/163
- https://iwannabethesenior.blogspot.com/2019/10/blog-post.html
- https://m.blog.naver.com/nds888/221380832707
- https://github.com/gyoogle/tech-interview-for-developer
- https://cclient.tistory.com/m/category/pinko/career
- https://hmjo.tistory.com/264
- https://makefortune2.tistory.com/category/Computer%20Science/C%2B%2B
- https://velog.io/@kkanyo/%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-C-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC-%EA%B3%84%EC%86%8D-%EC%88%98%EC%A0%95
- https://se-jung-h.tistory.com/entry/C-C-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8
- https://91ms.tistory.com/category/%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91
- https://sshoreng.tistory.com/80?category=712983
- https://geekhub.tistory.com/category/%EB%A9%B4%EC%A0%91%20%EC%A4%80%EB%B9%84
- https://uncertainty-momo.tistory.com/46
- https://hakyoug.tistory.com/73
- https://sb-story.tistory.com/2
- https://throwbug.com/80/%EB%A9%B4%EC%A0%91%EB%95%8C-%EC%96%B4%EB%96%A4%EA%B1%B0-%EB%AC%BC%EC%96%B4%EB%B3%B4%EB%8A%94%EC%A7%80-%EA%B3%B5%EC%9C%A0%ED%95%B4%EB%B3%B4%EC%95%84%EC%9A%94
- http://www.gamejob.co.kr/Community/Talk/Detail?talk_Stat=13&idx=9149
- https://namoeye.tistory.com/entry/%EB%A9%B4%EC%A0%91%EB%8C%80%EB%B9%84-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC?category=678025
- http://kingpark0304.blogspot.com/2014/11/blog-post.html
- https://velog.io/@mardi2020/C-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC
- https://j2hworld.tistory.com/55
- https://luv-n-interest.tistory.com/1168

<br>

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}