---
title:  "CS면접 준비" 

categories:
  - Interview
tags:
  - []

comments: true

toc: true
toc_sticky: true

date: 2022-09-05
last_modified_at: 2022-10-30
---

## 면접 질문

### 01-1 C++ 프로그래밍 언어 ( 중요도 최상 )
- 컴파일 이란 무엇인가? 인간이 이해할 수 있는 언어로 작성된 소스 코드(고수준 언어 : C, C++, Java 등)를 CPU가 이해할 수 있는 언어(저수준 언어 : 기계어)로 번역(변환)하는 작업을 말한다 ([**참고**](https://bradbury.tistory.com/226))
- 컴파일 과정에 대해 설명하면? 전처리된 소스 코드 파일(.i)을 컴파일러(Compiler)를 통해 어셈블리어 파일(.s)로 변환하는 과정이다 ([**참고**](https://bradbury.tistory.com/226))
- 빌드 과정이란? 전처리 과정 - 컴파일 과정 - 어셈블리 과정 - 링킹 과정을 묶어서 빌드 과정이라고 한다 ([**참고**](https://bradbury.tistory.com/226))
- 전처리 과정이란? 전처리기(Preprocessor)를 통해 소스 코드 파일(.c)을 전처리된 소스 코드 파일(.i)로 변환하는 과정이다 ([**참고**](https://bradbury.tistory.com/226))
- 어셈블리(Assembly) 과정에 대해서 설명하면? 어셈블리어 파일(.s)을 어셈블러(Assembler)를 통해 오브젝트 파일(.o)로 변환하는 과정이다 ([**참고**](https://bradbury.tistory.com/226))
- 링킹(Linking) 과정에 대해서 설명하면? 오브젝트 파일(.o)들을 링커(Linker)를 통해 묶어 실행 파일로 만드는 과정이다 ([**참고**](https://bradbury.tistory.com/226))
- rvalue와 lvalue에 대해 설명하면? lvalue는 표현식 이후에도 사라지지 않는 값 즉 이름을 지니는 변수이다 rvalue, 표현식 이후에는 사라지는 값 즉 임시 변수이다 ([**참고**](https://m.blog.naver.com/luku756/221808884092))
- 추상 클래스와 인터페이스의 차이점은? 인터페이스는 상태나 구현을 가질 수 없다, 인터페이스를 구현하는 클래스는 해당 인터페이스의 모든 메소드를 구현해야 한다, 추상 클래스는 상태(data members) 및/또는 구현(method)을 포함할 수 있다, 추상 클래스는 추상 메소드를 구현하지 않고 상속될 수 있다 이때 유도 클래스 역시 추상 클래스가 된다 ([**참고**](https://velog.io/@hyongti/C%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs.-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%ED%81%B4%EB%9E%98%EC%8A%A4))
- 구조체와 클래스의 차이는? 구조체는 접근 제어 지시자를 따로 선언하지 않으면 모든 변수와 함수가 public으로 선언되고, class의 경우 접근제어 지시자를 따로 선언하지 않으면 모든 변수와 함수가 private로 선언된다 ([**참고**](https://k96-ozon.tistory.com/31))
- 객체직렬화(Object Serialization)에 대해 설명하면? 객체의 메모리를 연속적인 바이트로 만들고, 만들어진 연속적인 바이트를 원래의 객체로 복원하는 작업을 말한다 ([**참고**](https://www.ikpil.com/1053))
- 객체지향(C++)의 특징에 대해 설명하면? 첫번째는 상속으로 부모 클래스의 메소드와 필드를 자식 클래스에서 그대로 물려 받는 것을 말한다 두번째는 추상화로 어떤 실체들에서 관심이 있는 공통적인 특성을 뽑아내어 하나의 분류로 만드는 것을 말한다 세번째는 다형성(Polymorphism)으로 하나의 객체가 여러 가지 타입을 가질 수 있는 것을 말한다 네번째는 캡슐화로 관련있는 속성과 메소드를 하나의 클래스로 묶는것을 말한다 ([**참고**](https://cclient.tistory.com/m/11))
- 다형성의 예시에 대해서 설명하면? 연산자 오버로드, 함수 오버로드, 함수 템플릿, 가상함수가 있다 ([**참고**](https://younggwan.tistory.com/50))
- C++과 C언어의 차이는? 객체를 이용한 출력, 함수를 이용한 출력이 다르고 C++은 namespace 개념을 사용개념을 사용합니다 ([**참고**](https://cclient.tistory.com/m/11))
- 추상클래스란 무엇인가? C++에서는 하나 이상의 순수 가상 함수를 포함하는 클래스를 추상 클래스(abstract class)라고 한다 ([**참고**](http://www.tcpschool.com/cpp/cpp_polymorphism_abstract))
- 인터페이스란 무엇인가? 인터페이스는 구현이 없다 즉, 인터페이스 클래스에는 가상 소멸자와 순수 가상함수만 포함된다 ([**참고**](https://velog.io/@hyongti/C%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-vs.-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%ED%81%B4%EB%9E%98%EC%8A%A4))
- 생성자는 왜 가상함수가 될 수 없는가? 객체를 만들려면 완전한 정보가 필요합니다 특히 생성하려는 정확한 유형을 알아야 합니다 결과적으로 "생성자 호출"은 가상이 될 수 없습니다 ([**참고**](https://stackoverflow.com/questions/733360/why-do-we-not-have-a-virtual-constructor-in-c))
- 가상함수와 순수 가상 함수에 대해서 설명하면? 순수 가상 함수는 인터페이스(Interface)를 자식 클래스에게 전달하기 위해 사용하는 함수이고, 일반(단순) 가상 함수는 인터페이스(Interface) + 함수의 선언(내부 구현) 까지 자식 클래스에게 전달하기 위해 사용하는 함수입니다 ([**참고**](https://blockdmask.tistory.com/277))
- volatile 키워드에 대해서 설명하면? volatile 키워드는 해당 변수의 컴파일러 최적화를 제한하는 용도로 사용합니다 ([**참고**](https://psychoria.tistory.com/592)) ([**참고**](https://geekhub.tistory.com/68))
- malloc, new에 대해서 차이점을 설명하면? 4가지 중요한 차이점이 있다 첫째, new를 이용해 객체를 생성하면 생성자가 호출된다 즉 초기값을 줄 수 있다, malloc은 생성자 호출 기능이 없다 즉 초기값을 줄 수 없다 두번째, malloc은 해당 포인터의 타입을 모르기 때문에 리턴 값의 자료형이 void* 이고 new는 해당 객체에 맞는 포인터을 리턴값으로 반환한다 세번째, new를 통해 객체생성시 에러가 발생하면 예외처리를 하지만 malloc은 예외처리 없이 NULL값을 반환하게 됩니다 네번째, malloc은 realloc으로 할당된 메모리 크기를 재조정이 가능하다 하지만 new는 할당된 크기에 대한 메모리 재조정이 불가능하다 ([**참고**](https://hwan-shell.tistory.com/12))
- 언제 malloc을 사용하고 new를 사용해야 하는가? 재할당이 빈번하게 일어나는 경우 realloc이 가능한 malloc을 사용하는 것이 옳다고 할 수 있고, 생성자 호출이 필요하다면 new를 사용하는 것이 옳다할 수 있다 ([**참고**](https://cclient.tistory.com/m/11))
- null과 nullptr의 차이점? NULL은 상수 0이고, nullptr은 포인터이다 그래서 포인터 변수를 초기화해줄 때 nullptr를 사용해줘야 한다 ([**참고**](https://velog.io/@t1won/C-%EB%84%90-%ED%8F%AC%EC%9D%B8%ED%84%B0-NULL%EA%B3%BC-nullptr))
- inline함수는 무엇인가? 인라인이라는 의미는 코드가 라인 안으로 들어간다는 뜻이다 즉, 함수의 내용을 호출을 통해서 실행시키는 것이 아니라, 호출하는 코드 자체가 함수 내용의 코드가 된다 함수 호출없이 삽입된 함수 코드를 그 자리에서 처리하므로 해당 함수를 수행하기 위해 프로그램이 다른 주소로 점프했다가 되돌아올 필요가 없어 속도면에서 유리합니다 ([**참고**](https://thinkpro.tistory.com/140))
- C++ 상속에서 부모 클래스 소멸자에 virtual(가상 키워드)를 사용해야 하는 이유는? 부모 클래스의 포인터로 자식 클래스를 호출할때 가상 함수로 정의되지 않은 자식 클래스의 함수를 호출하면 부모 클래스의 멤버 함수가 호출된다 소멸자도 자식 클래스의 소멸자가아닌 부모클래스의 소멸자가 호출이된다 즉 가상 함수로 소멸자가 사용되었다면 자식 클래스에서 재정의 될 수 있음을 명시하기 때문에 자식 클래스의 소멸자부터 차례대로 부모 클래스의 소멸자가 호출된다 ([**참고**](https://younggwan.tistory.com/45)), ([**참고**](https://zoosso.tistory.com/959))
- 하이딩, 오버로딩, 오버라이딩의 차이는? 하이딩은 슈퍼클레스에 정의된 이름과 동일한 이름을 서브클레스에서 정의해서 사용하게 되면, 서브클래스 내에서는 슈퍼클레스의 이름이 모두 가려지게 되는것을 의미한다, 오버로딩은 같은 이름의 함수에 매개변수만 다르게 사용하여 매개변수에 따라 다른 함수가 실행되는 것을 의미한다 오버라이딩은 상속받을 때 부모클래스의 함수를 자식클래스에서 재정의하여 사용하는 것을 의미한다 ([**참고**](https://spikez.tistory.com/173)), ([**참고**](https://cosyp.tistory.com/228))
- static_cast와 dynamic_cast의 차이는? static_cast는 컴파일타임에 형변환이 가능한지 검사한다, 기본 자료형간의 형변환이 가능하다, 부모클래스와 자식클래스 양방향으로 형변환을 허용한다 dynamic_cast는 런타임타임에 안정성을 검사한다, 기본 자료형간의 형변환이 불가능하다, 자식 클래스에서 부모 클래스로 형변환이 가능한것은 static_cast와 같지만 부모 클래스에서 자식 클래스로의 형변환은 하나 이상의 가상함수를 가진 다형성 클래스에 한해서만 가능하다 ([**참고**](https://mynameisdabin.tistory.com/20))
- call by value와 call by reference의 차이는? call by value의 경우 데이터 값을 복사해서 함수로 전달하기 때문에 원본 데이터가 변경될 가능성이 없습니다 call by reference의 경우 데이터 주소를 복사해서 함수로 전달하기 때문에 참조한 데이터를 변경시 원본 데이터 값이 변경 됩니다 ([**참고**](https://cclient.tistory.com/m/11))
- auto 키워드에 대해서 설명하면? auto 키워드는 선언된 변수의 초기화 식을 사용하여 해당 형식을 추론하도록 컴파일러에 지시한다, 해당 키워드를 사용할 때의 주의점은 선언만하고 초기화를 하지않으면 사용이 불가능하다 이유는 초기화 식을 기준으로 자료형을 선택하기 때문이다  ([**참고**](https://xn--vj5b11biyw.kr/80))
- 스마트 포인터에 대해서 설명하면? C++에서 메모리 누수(memory leak)로부터 프로그램의 안전성을 보장하기 위해 스마트 포인터를 제공하고 있다 포인터처럼 동작하는 클래스 템플렛으로 사용이 끝난 메모리를 자동으로 해제해준다 종류별로 설명하면 shared_ptr은 어떤 하나의 객체를 참조하는 스마트 포인터의 개수를 참조하는 스마트 포인터이다, unique_ptr은 하나의 스마트 포인터만이 객체를 가리킬수 있도록 한다, weak_ptr은 하나 이상의 shared_ptr이 가리키는 객체를 참조할수 있지만 reference count를 늘리지않는 스마트 포인터이다 ([**참고**](https://min-zero.tistory.com/entry/C-STL-1-3-%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%8A%A4%EB%A7%88%ED%8A%B8-%ED%8F%AC%EC%9D%B8%ED%84%B0smart-pointer))
- const 키워드를 자료형 앞에 사용했을때와 변수명 앞에 사용했을때 차이를 설명하면? const int* c 에서 c가 가리키는 대상은 변경이 가능하지만 가리키는 값은 변경할 수 없다 int* const c = &a; 에서 c가 가리키는 대상은 변경할 수 없지만 가리키는값은 변경이 가능하다 ([**참고**](https://cclient.tistory.com/m/11))
- 정적 바인딩에 대해서 설명하면? 어떤 함수가 호출될지 컴파일시 결정된다 ([**참고**](https://byunggni.tistory.com/20))
- 동적 바인딩에 대해서 설명하면? 어떤 함수가 호출될지 런타임 중에 결정된다 ([**참고**](https://byunggni.tistory.com/20))
- 템플릿 메타프로그래밍 이란? 컴파일 도중에 실행되는 템플릿 기반의 프로그램을 작성하는 것 C++ 컴파일이 진행되는 동안에 실행되기 때문에, 기존 작업을 런타임 영역에서 컴파일 타임 영역으로 전환할 수 있다는 것이 장점이다 문법이 비 직관적이고 개발도구의 지원도 아주 미약하다(디버깅 불가능)는 것이 단점이다 ([**참고**](https://hubring.tistory.com/73)), ([**참고**](https://cclient.tistory.com/m/11))
- 클로져와 람다에 대해서 설명하면? 런타임시 이름은 없지만, 메모리 상에 임시적으로 존재하는 객체를 클로져(Closure)라고 한다 람다는 이름 없는 함수 즉, 익명 함수이다 람다와 클로져의 관계는 클래스(람다)를 정의하고 클래스의 객체(클로져)를 만드는 것과 같다 ([**참고**](https://3dmpengines.tistory.com/1593))
- 람다란? 쉽게 말해 이름 없는 함수입니다. 반환형, 인자, 몸통, 캡쳐로 구성되어 있으며 런타임 시 이름은 없지만, 메모리 상에 임시적으로 존재하는 클로져 객체가 생성됩니다 ([**참고**](https://lunchballer.com/archives/284))
- explicit 키워드에 대해서 설명하면? 묵시적 형변환을 할 수 없게 만들고 명시적인 형변환만 가능하도록 만드는 것 ([**참고**](https://psyhm.tistory.com/13))
- 전위 연산과 후위 연산의 차이는? 전위 연산자는 증감된 값을 참조형으로 반환하지만 후위 연산자는 값은 증가시키지만 증감 전의 값을 임시 객체로 만들어서 반환한다 Debug모드에서의 후위연산자는 증감 전의 값을 임시객체로 만들어 리턴하기 때문에 전위연산보다 느리지만 release 모드에서는 컴파일러의 최적화로 둘의 성능은 같다고 한다 ([**참고**](https://spenshi.tistory.com/entry/%EC%A6%9D%EA%B0%90-%EC%97%B0%EC%82%B0%EC%9E%90-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9))
- 오버로딩의 조건에 대해서 설명하면? 함수의 오버로딩이 가능 하려면 매개변수의 선언이 달라야 한다 반환형은 함수호출 시, 호출되는 함수를 구분하는 기준이 될 수 없다 ([**참고**](https://better-tomorrow.tistory.com/entry/C%EC%96%B8%EC%96%B4-%EA%B8%B0%EB%B0%98%EC%9D%98-C01-2-%ED%95%A8%EC%88%98-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9Function-Overloading))
- 오버라이딩 개념에서 리턴 타입이 같아야 되나? 부모 클래스에서 정의한 함수를 자식 클래스에서 오버라이딩할 때, 오버라이딩 하려는 함수의 리턴 타입을 자식 클래스 타입으로 하면 오버라이딩 함수의 리턴 타입을 다르게 해도 오버라이딩이 가능하다 ([**참고**](https://welikecse.tistory.com/75))
- 두 객체의 데이터형 같은지 어떻게 알수 있는가? RTTI를 지원하는 요소중 typeid 연산자를 활용해 두 객체의 데이터 형이 동일한지 여부를 결정할 수 있습니다 ([**참고**](https://blog.plorence.dev/536)), ([**참고**](https://www.techiedelight.com/ko/compare-two-objects-in-cpp/))
- virtual 키워드에 대해서 설명하면? virtual 키워드는 함수에 붙일 수 있다 이 키워드를 붙이면 가상 테이블(virtual table)이 생성된다 이를 통해서 오버라이딩이 가능해진다 ([**참고**](https://genesis8.tistory.com/105))
- C++ 가상함수의 동작 원리에 대해서 설명하면? 클래스에 한 개 이상의 가상 함수가 있을 경우, 컴파일러는 실제 호출되어야할 함수의 위치 정보를 가지고 있는 가상 함수 테이블을 만들고, 클래스 객체에는 가상 함수 테이블을 위한 포인터를 추가합니다 일반적으로 가상 함수가 있는 객체는 가상 함수 테이블에 있는 함수만을 호출하는 원칙을 가지고 있습니다 ([**참고**](https://xzio.tistory.com/1152))
- 객체지향과 절차지향의 차이는? SW 개발에 있어 절차지향은 실행순서, 절차가 중점이 된다 객체지향은 필요한 객체들의 종류와 속성 등이 중점이 된다 ([**참고**](https://usefultoknow.tistory.com/entry/%EC%A0%88%EC%B0%A8%EC%A7%80%ED%96%A5Procedural-Programming-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5Object-Oriented-Programming-%EC%9E%A5%EB%8B%A8%EC%A0%90-%EB%B0%8F-%EC%B0%A8%EC%9D%B4%EC%A0%90))
- C++ 가상함수 테이블에 대해 설명하면? 컴파일 시 가상함수가 정의된 클래스가 있다면 가상함수테이블(Virtual function table)이 만들어지고, 해당 클래스로 만들어진 객체의 함수가 호출될 때 만들어진 가상함수 테이블이 참조되어 함수가 호출된다 ([**참고**](https://cosyp.tistory.com/228))
- 소멸자란 무엇인가? 객체를 더이상 사용하지 않을 때 객체를 제거하기 위해 호출되는 함수이다 ([**참고**](https://se-jung-h.tistory.com/entry/C-C-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8))
- 디폴트 생성자란 무엇인가? 생성자가 없는 경우 컴파일러에 의해 자동으로 생성되는 생성자를 디폴트 생성자라고 한다 ([**참고**](https://se-jung-h.tistory.com/entry/C-C-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8))
- 역슬레시n과 endl의 차이는 무엇인가? endl은 출력 버퍼를 비워주는 과정(flush)이 들어가 있어서 역슬레시n보다 느리다 ([**참고**](https://se-jung-h.tistory.com/entry/C-C-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8))
- 입출력 실행속도 높이는 방법은? ios::sync_with_stdio(false); 코드를 추가해 높일수 있다, 이는 C++의 iostream과 stdio와의 동기화를 끄는 기능인데, iostream과 stdio의 버퍼를 모두 사용하면 딜레이가 발생되기 때문에 이를 끊어 실행 속도를 높일수 있는 것이다 ([**참고**](https://se-jung-h.tistory.com/entry/C-C-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8))
- 업캐스팅과 다운 캐스팅의 차이는? 업캐스팅은 클래스 상속구조에서 자식타입에서 부모타입으로의 타입변환을 말하고, 다운캐스팅은 부모타입에서 자식타입으로의 변환을 말합니다 ([**참고**](https://sshoreng.tistory.com/109?category=712983))
- GetMessage()와 PeekMessage() 차이는? GetMessage 함수는 메시지가 도착하여야지만 리턴되는데 반해(동기, Synchronous), PeekMessage 함수는 메시지 큐에 도착한 메시지가 없어도 리턴한다(비동기, Asynchronous) ([**참고**](https://professorleejaeman.tistory.com/entry/%EB%A9%94%EC%8B%9C%EC%A7%80-%ED%95%A8%EC%88%98))
- 객체 지향의 5대 원칙에 대해 설명하면? (1) 개방폐쇄의 원칙, 요구사항의 변경이나 추가사항이 발생하더라도 기존 구성요소는 수정이 일어나지 말아야하며 쉽게 확장이 가능하여 재사용할 수 있어야 한다 (2) 인터페이스 분리의 원칙, 꼭 필요한 인터페이스만 상속하자는 의미 (3) 의존성 역전의 원칙, 구체적인 클래스에 의존하지 말고 최대한 추상화한 클래스에 의존하라는 뜻 (4) 리스코브 치환의 원칙, 부모 클래스를 카리키는 포인터에 해당 클래스를 상속하는 자식 클래스를 할당하더라도 모든 기능이 정상적으로 작동해야 하며 자식 클래스의 상세 내부를 부모 클래스는 알 필요가 없다는 뜻 (5) 단일 책임의 원칙, 모든 클래스는 각각 하나의 기능만 가진다는 뜻 ([**참고**](https://jaeyeong951.medium.com/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-5%EC%9B%90%EC%B9%99-solid-ac7d4d660f4d))
- 복사생성자에 대해서 설명하면? 자신과 같은 클래스 타입의 다른 객체에 대한 참조(reference)를 인수로 전달 받아, 그 참조를 가지고 자신을 초기화 하는 방법 입니다 ([**참고**](https://uncertainty-momo.tistory.com/46))
- 얕은 복사, 깊은 복사에 대해 설명하면? 얕은 복사는 메모리 자체를 복사하지 않고 주소만 복사한다 깊은 복사는 메모리 자체의 복사본을 만든다 ([**참고**](https://uncertainty-momo.tistory.com/46))
- static 멤버 메소드에 대해 설명하면? static 멤버 메소드 안에서는 일반 멤버변수 접근이 불가능하다 오직 static 멤버만 접근가능하다 ([**참고**](https://velog.io/@ddongg00/C-static))
- static 클래스에 대해 설명하면? static 클래스는 모든 멤버가 static 멤버로 되어 있으며, 인스턴스화 하지 않는 클래스 이기 때문에 객체 생성이 불가능 합니다 ([**참고**](https://uncertainty-momo.tistory.com/46?category=0))
- 다중 상속의 문제점은? 가장 큰 문제점은 모호함 이다 즉 둘 이상의 기본 클래스로부터 같은 이름의 함수등을 물려받을 가능성이 생긴다 ( Effective C++ 286 페이지 참조 ), ([**참고**](https://hakyoug.tistory.com/80?category=851272))
- dynamic_cast가 업, 다운 캐스팅 가능성을 검사하는 원리는? 가상함수 테이블을 이용하여 캐스팅이 가능한 자료인지 검사합니다 ([**참고**](https://hakyoug.tistory.com/80?category=851272))
- 바이트 패딩(Byte Padding) 이란? 클래스(구조체)에 바이트를 추가해 CPU 접근에 부하를 덜어주는 기법입니다 ([**참고**](https://sanghun219.tistory.com/49))
- RAII에 대해 설명하면? 자원을 안전하게 사용하기 위해 객체가 쓰이는 스코프를 벗어나면 자원을 해제해주는 기법이다 ([**참고**](https://overface.tistory.com/564))
- C++ 11의 새로운 점은? auto 키워드가 처음 등장했으며 해당 키워드는 변수의 자료형을 컴파일 시간에 자동으로 추론해줍니다, lvalue, rvalue, 이동생성자 ([**참고**](https://openmynotepad.tistory.com/20))
- 객체란 무엇인가? 데이터와 데이터를 처리하는 함수를 묶어 놓은(캡슐화한) 하나의 소프트웨어 모듈입니다 ([**참고**](https://coding-factory.tistory.com/327))
- static의 의미를 상황별로 설명하면? 전역변수에 선언된 static은 선언된 파일 내에서만 참조를 허용한다는 의미 입니다 함수 내에 선언된 static은 지역변수와 달리 함수를 빠져나가도 소멸되지 않음을 의미합니다 ([**참고**](https://blog.naver.com/PostView.nhn?blogId=sonicheroes1&logNo=220752545904))
- 상속과 포함을 결정하는데 있어 본인의 기준은 무엇인가? 상속은 is-a 관계가 확실할때 사용하는 것이 좋습니다 포함은 has-a 관계 즉 하나의 객체가 다른 객체를 파트로써 갖는 경우 사용하는 것이 좋습니다 ([**참고**](https://minusi.tistory.com/entry/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5%EC%A0%81-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C%EC%9D%98-has-a%EC%99%80-is-a-%EC%B0%A8%EC%9D%B4%EC%A0%90))
- C++에서 public 상속과 protected 상속의 차이점은? public 상속은 다른 객체에서 접근이 가능하다 하지만 protected 상속은 다른 객체에서 접근이 불가능하다 ([**참고**](https://computer-science-student.tistory.com/52)), ([**참고**](https://dev-woong.tistory.com/104))
- RTTI에 대해 설명하면? 객체 타입을 런타임중에 알아내는 매커니즘을 RTTI(Run Time Type Information)라고 한다 ([**참고**](https://ku-hug.tistory.com/70))
- 텅 빈 클래스 또는 구조체는 왜 0 사이즈가 아닐까? 클래스 또는 구조체가 사이즈 0이 될 경우 서로 다른 2개의 인스턴스가 같은 주소를 가질 수 있게 되므로, 텅 빈 클래스 또는 구조체라도 최소 1바이트 이상의 크기를 가진다 ([**참고**](https://zepeh.tistory.com/581))
- 생성자가 호출되기전에 멤버들을 초기화 시킬려면 어떻게 해야 하는가? 이니셜라이저를 활용한다 ([**참고**](https://velog.io/@jinh2352/%EC%83%9D%EC%84%B1%EC%9E%90%EC%99%80-%EC%86%8C%EB%A9%B8%EC%9E%90-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%A0%91%EA%B7%BC%EC%A7%80%EC%A0%95%EC%9E%90)), ([**참고**](https://blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=dd1587&logNo=221103760389))
- Friend 클래스에 대해 설명하면? 지정한 대상에 한해 해당 객체의 모든 멤버에 접근할 수 있는 권한을 부여해 줍니다 Friend 클래스를 사용하면 자신의 객체뿐만이 아닌 다른 타입의 객체를 접근하는 것이 가능해지기 때문에 코드의 확장이 수월하게 이루어집니다 단 이렇게 프렌드를 사용할 경우 개발자의 입장에서는 개발에 편리하겠지만 캡슐화 파괴의 주범이 되어 설계가 꼬여버리는 경우가 생길 수 있습니다 ([**참고**](http://www.tcpschool.com/cpp/cpp_encapsulation_friend)), ([**참고**](https://coding-factory.tistory.com/698))
- stdcall과 cdecl의 차이를 설명하면? stdcall은 호출된 쪽(Callee)에서 직접 스택을 정리하고 가변 인자 사용이 불가능하다 cdecl은 함수를 호출한 쪽(Caller)에서 스택을 정리하고 가변 인자 사용이 가능하다 ([**참고**](https://awesomebit.tistory.com/72))
- new와 delete가 짝이 안맞으면 어떻게 될까요? 단일객체에 delete[]를 사용하면 앞쪽의 메모리 몇 바이트를 읽고 그것을 배열 크기라고 해석한다 이윽고 배열 크기에 해당하는 횟수만큼 소멸자를 호출하기 시작하지만 자신이 밟고 있는 메모리가 배열에 속해 있지 않으며 그 메모리에는 자신이 소멸시키려는 타입의 객체가 이미 들어 있지 않다는 사실에 도달한다 배열객체에 delete를 사용하면 소멸자 호출 횟수가 너무 적기 때문에 미정의 동작이 발생한다 ([**참고**](https://sexycoder.tistory.com/43))
- 스마트 포인터의 순환 참조를 해결하는 방법은? 서로를 참조하는 포인터 중 하나를 weak_ptr로 만드는 것이다 ([**참고**](https://woo-dev.tistory.com/113))
- 전방선언이 필요한 이유는? 불필요한 헤더 파일이 복잡하게 포함되는 것을 방지하며, 컴파일 속도를 향상시켜준다 ([**참고**](https://grayt.tistory.com/30))
- 포인터와 배열의 차이는? 포인터와 배열은 둘다 변수 자체는 메모리 번지를 뜻하지만, 배열은 포인터 상수여서 다른 번지를 가리킬 수 없고, 포인터는 변수이므로 대입이 가능합니다 배열은 상수이므로 증감 연산자를 사용할 수 없고, 포인터 변수는 증감 연산자를 사용할 수 있습니다 ([**참고**](https://velog.io/@mardi2020/C-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC))
- 정적 라이브러리(Static Link Library)와 동적 라이브러리(Dynamic Link Library)의 차이는? 정적 라이브러리는 필요한 함수를 프로그램 코드에 붙여 프로그램 자체에서 참조한다 동적 라이브러리는 프로그램 실행 시 필요시에만 외부 DLL 파일에서 함수를 참조한다 ([**참고**](https://luv-n-interest.tistory.com/1225))
- 정적 멤버 변수(static member variable)에 대해 설명하면? C++에서 정적 멤버란 클래스에는 속하지만, 객체 별로 할당되지 않고 클래스의 모든 객체가 공유하는 멤버를 의미합니다 ([**참고**](http://www.tcpschool.com/cpp/cpp_encapsulation_staticConst))
- 함수 객체란? 함수 객체는 함수처럼 객체가 동작한다 하여 함수 객체라고 할 수 있는데, 연산자 오버로딩에서 ()라는 연산자를 오버로딩하여 객체를 함수처럼 쓸 수 있습니다 ([**참고**](https://blog.hexabrain.net/267))
- 표현식이란 무엇인가? C++의 표현식은 값을 반환하는 모든 문장을 말한다 ([**참고**](https://digiconfactory.tistory.com/entry/C-%EB%AC%B8%EC%9E%A5Statement%EA%B3%BC-%ED%91%9C%ED%98%84%EC%8B%9DExpression-C-%EA%B3%BC-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%BC%ED%95%99))
- 람다식의 장점과 단점은? 장점은 함수를 인라인화 할 수 있다는 것이고 단점은 함수 재사용성이 낮다는 점이다 ([**참고**](https://gandis0713.github.io/2019/10/13/c-plus-lamda/)), ([**참고**](https://jjeongil.tistory.com/1044))
- 변환 생성자란? 매개변수가 하나뿐인 생성자를 변환 생성자라고 한다 묵시적 변환을 통해 임시 객체가 생성될 가능성을 가지고 있다 ([**참고**](https://snd-snd.tistory.com/74))
- 생성자 앞에 explicit 키워드를 붙여주면 어떻게 되는가? 변환 생성자의 무작위 호출을 막고 명확성을 높여준다 ([**참고**](https://ansohxxn.github.io/cpp/chapter9-11/))
- override 키워드에 대해 설명하면? override 키워드를 붙여주면 해당 함수가 상속 받아서 오버라이딩이 가능한 함수인지, 그 함수의 이름과 매개 변수등이 잘 맞는지를 컴파일러가 확인해준다 또한, 명확하게 이게 상속 받은 함수인지 눈으로 확인할 수 있습니다 ([**참고**](https://blockdmask.tistory.com/415))
- final 키워드에 대해 설명하면? 부모 클래스의 특정 멤버 함수를 자식 클래스에서 재정의 하지 못하도록 막을때 사용한다거나, 부모 클래스를 자식 클래스에서 상속 받을때 클래스 자체를 더이상 상속이 불가능하게 하려고 할 때 쓰입니다 ([**참고**](https://blockdmask.tistory.com/415))
- 전역 변수와 정적 변수의 차이는? 전역변수는 해당 프로그램(실행파일 기준)의 어느 함수, 어느 파일에서도 접근이 가능한 반면 정적변수는 변수가 선언된 파일이나 함수내에서만 접근이 가능하다 ([**참고**](https://pangate.com/541))
- 이동 생성자란? 다른 객체 멤버 변수들의 소유권을 가져오는 개념이다 복사 생성자와 달리 메모리 재할당을 하지 않기 때문에 빠르다 ([**참고**](https://www.codechosun.com/296)), ([**참고**](https://modoocode.com/227)), ([**참고**](https://maxlevel-trace.tistory.com/24))
- 인터페이스, 추상 클래스, 다형성 클래스의 차이점은? 인터페이스는 구현이 없다 즉, 인터페이스 클래스에는 가상 소멸자와 순수 가상함수만 포함된다 C++에서는 하나 이상의 순수 가상 함수를 포함하는 클래스를 추상 클래스(abstract class)라고 한다 다형성 클래스는 하나 이상의 가상함수를 가진 클래스이다
- 순환 참조란? 서로가 상대를 참조하는 상황을 순환 참조(Circular Reference)라고 한다 ([**참고**](https://bbagwang.com/programming/cpp/%EC%8A%A4%EB%A7%88%ED%8A%B8-%ED%8F%AC%EC%9D%B8%ED%84%B0-smart-pointer/))
- 생성자 안에서 가상함수를 호출하면 어떻게 되는가? 부모클래스의 생성자 안에서 가상함수를 호출하면 개발자가 만들려는 객체가 자식클래스의 객체여도 자식 자식클래스의 생성자에서 호출하길 원했던 가상함수가 호출되지 않는다 ( Effective C++ 101 페이지 참조 )
- 소멸자 안에서 가상함수를 호출하면 어떻게 되는가? 파생 클래스의 소멸자가 호출되고 나면 파생 클래스의 멤버는 정의되지 않은 것으로 가정하기 때문에, 파생 클래스의 가상함수를 더이상 호출할 수 없다 ( Effective C++ 102 페이지 참조 )
- 포인터와 참조의 차이는? 포인터는 NULL 할당을 허용하지만 레퍼런스는 NULL 할당이 허용되지 않는다 포인터는 할당 할 때 참조 대상에 대해 앰퍼샌드 연산을 통해 주소값을 할당합니다 반면 레퍼런스에는 참조 대상을 직접 할당한다 따라서 선언과 동시에 초기화를 하지 않으면 컴파일 오류가 발생한다 ([**참고**](https://gracefulprograming.tistory.com/11))
- std::move에 대해 설명하면? 전달된 파라미터를 강제로 rvalue 참조로 캐스팅하여 리턴하는 함수입니다 ([**참고**](https://pppgod.tistory.com/44)), ([**참고**](https://jungwoong.tistory.com/53))
- std::forward에 대해 설명하면? 전달된 파라미터가 lvalue인지 rvalue인지에 따라 조건부 캐스팅을 진행한뒤 리턴한다 ([**참고**](https://pppgod.tistory.com/44)), ([**참고**](https://jungwoong.tistory.com/53))
- weak_ptr의 lock 함수에 대해 설명하면?  weak_ptr 가 가리키는 객체가 아직 메모리에서 살아 있다면 (참조 개수가 0이 아니라면) 해당 객체를 가리키는 shared_ptr 를 반환하고, 이미 해제가 되었다면 아무것도 가리키지 않는 shared_ptr 를 반환한다 ([**참고**](https://koreanfoodie.me/842))
- 보편 참조에 대해 설명하면? 보편 참조의 의미는 rvalue 참조이거나 lvalue 참조 중 하나라는 의미이다 ([**참고**](https://pppgod.tistory.com/45))
- float나 double 자료형을 비교할때 == 연산자를 사용하면 안되는 이유는? float나 double은 값을 도출할 수 있는 수식에 대한 정보를 저장하는 방식인 부동소수점 방식을 사용하기 때문에 범위를 표현할수 있는 연산자를 활용해야 한다 ([**참고**](https://pang2h.tistory.com/184)), ([**참고**](https://pang2h.tistory.com/293))

### 01-2 자료구조, C++ STL ( 중요도 상 )
- vector와 list의 차이는? vector를 중간삽입시 원소를 밀어내지만 list는 노드를 연결만 하기 때문에, 삽입 삭제 부분에서 시간복잡도의 우위를 가진다 그리고 vector는 메모리가 연속적이기 때문에 랜덤 접근이 가능하지만 list는 더블링크드리스트로 되어 있어 x[2]와 같은 랜덤 접근이 되지 않는다 즉 검색적인 측면에서는 vector가 우위에 있다 ([**참고**](https://chanheess.tistory.com/154))
- 단일 연결 리스트 뒤집기를 손코딩 하면? ([**참고**](https://www.fwantastic.com/2021/01/leetcode-206-reverse-linked-list.html)), ([**참고**](https://modernalchemist.tistory.com/43))
- Hash란 무엇인가? 데이터 삽입 및 삭제 시, 데이터와 연관된 고유한 숫자를 생성해 인덱스로 사용하는 방법 ([**참고**](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Interview/Interview%20List.md#%EC%96%B8%EC%96%B4))
- vector와 array의 차이점은? array의 크기는 고정이지만 vector는 동적으로 변하는 점이 vector와 array 자료구조의 가장 큰 차이점이다 ([**참고**](https://hanbit.co.kr/network/category/category_view.html?cms_code=CMS7393457320))
- 지역변수와 전역변수가 메모리상에 어디에 어떻게 놓이나요? 지역변수는 stack 영역에, 전역변수는 data 영역에 놓인다 ([**참고**](https://snupi.tistory.com/9))
- 백터를 at(0)으로 접근 할때와 [0]으로 접근할 때의 차이는? at()은 범위를 체크하여 out_of_range 예외를 발생시킨다 [] 연산자 접근 방식은 범위를 체크하지 않는다 ([**참고**](https://kwaksh2319.tistory.com/406))
- 백터에 객체를 담는 것과 포인터를 담는 것의 차이는? 객체를 담을때는 복사생성자가 호출되고 clear을 통해 해당 원소를 제거할 수 있다 포인터를 담을때는 복사생성자가 호출되지 않고 해당 포인터가 가리키는 메모리를 직접해제 해줘야 한다 ([**참고**](https://www.wake-up-neo.net/ko/c%2B%2B/%EA%B0%9D%EC%B2%B4-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EB%B2%A1%ED%84%B0%EC%97%90%EC%84%9C-vector-erase-%EA%B0%80-%EA%B0%9D%EC%B2%B4-%EC%9E%90%EC%B2%B4%EB%A5%BC-%ED%8C%8C%EA%B4%B4%ED%95%A9%EB%8B%88%EA%B9%8C/972514417/)), ([**참고**](https://sb-story.tistory.com/9))
- 백터의 공간이 가득 찼을 때 어떻게 되는가? 현재 할당된 크기의 2배로 재할당된다, 벡터 생성시 reserve로 공간을 크게 할당해 놓으면 성능을 향상할 수 있다 ([**참고**](https://sb-story.tistory.com/9))
- unordered_map과 비교하여 map의 장점에 대해 설명하면? unordered_map은 key를 이용하여 정렬을 할 수 없고, map은 key를 이용하여 정렬을 할 수 있다 ([**참고**](https://astrid-dm.tistory.com/504))
- 부스트 라이브러리란? 단위 테스트, 이미지 처리, 멀티 스레딩, 의사 난수 생성, 선형 대수 및 정규 표현식과 같은 여러 작업 및 구조를 지원하는 라이브러리이다 ([**참고**](https://ko.theastrologypage.com/boost-libraries))
- STL이란 무엇인가? 표준 라이브러리중 하나로 프로그램에 필요한 자료구조와 알고리즘을 템플릿으로 제공합니다 ([**참고**](https://sshoreng.tistory.com/112?category=712983))
- 이진탐색트리(Binary Search Tree)이란? 다음과 같은 특징을 갖는 이진트리를 말한다 (1) 각 노드에 중복되지 않는 키가 있다 (2) 루트노드의 왼쪽 서브 트리는 해당 노드의 키보다 작은 키를 갖는 노드들로 이루어져 있다 (3) 루트노드의 오른쪽 서브 트리는 해당 노드의 키보다 큰 키를 갖는 노드들로 이루어져 있다 (4) 좌우 서브 트리도 모두 이진 탐색 트리여야 한다 ([**참고**](https://code-lab1.tistory.com/10))
- 스택과 큐의 차이는? 스택은 후입선출로 가장 마지막에 삽입된 자료부터 순서대로 꺼내지는 것이고, 큐는 선입선출로 먼저들어온 순서부터 먼저 꺼내지는 것입니다 ([**참고**](https://sshoreng.tistory.com/80?category=712983))
- map 자료구조는 어떤 형태로 되어있는가? 레드블랙이진트리의 형태로 되어 있는데, 레드블랙이진트리의 규칙은 다음과 같습니다 (1) 모든 노드는 블랙, 아니면 레드입니다 (2) 루트 노드는 블랙 노드입니다 (3) 리프 노드는 블랙 노드입니다 (4) 레드 노드의 두 자식은 모두 블랙 노드입니다 (5) 루트 노드에서 임의의 한 리프노드까지의 블랙 노드의 갯수는 모두 동일합니다 이러한 규칙을 지키는 이유는 균형잡힌 이진트리를 만들기 위함입니다 ([**참고**](https://playground10.tistory.com/204))
- 정렬 알고리즘에는 어떤 것들이 있는가? 많이 사용되는 알고리즘으로 계수정렬, 선택정렬, 삽입정렬, 퀵정렬이 있다 ([**참고**](https://velog.io/@cha-suyeon/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A0%ACSorting-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC%EC%84%A0%ED%83%9D-%EC%82%BD%EC%9E%85-%ED%80%B5-%EA%B3%84%EC%88%98%EC%A0%95%EB%A0%AC))
- 힙 자료구조란? 우선순위 큐를 위해 고안된 완전이진트리 형태의 자료구조이다 여러 개의 값 중 최댓값 또는 최솟값을 찾아내는 연산이 빠르다는 특징이 있다 ([**참고**](https://suyeon96.tistory.com/31))
- 우선순위 큐란? 우선순위가 높은 데이터가 먼저 나가는 형태의 자료구조이다 일반적으로 힙(Heap)을 이용하여 구현한다 ([**참고**](https://suyeon96.tistory.com/31))
- 해싱의 충돌 해결책에 대해 설명하면? 키에 해당하는 데이터들을 연결하는 방식인 체이닝 기법과 재해싱을 통해 다른 버킷에 데이터를 저장하는 개방주소법이 있다 ([**참고**](https://javannspring.tistory.com/238))
- stl vector에서 push_back과 emplace_back의 차이에 대해 설명하면? push_back은 삽입할 객체를 받아 임시 객체를 만들고 push_back 내부에서 복사가 일어난 뒤 vector에 추가를 한다 emplace_back은 삽입할 객체의 생성자를 위한 인자들을 받아 std::vector 내에서 직접 객체를 생성하여 삽입하므로 임시 객체의 생성과 파괴, 복사(혹은 move)를 하지 않아도 되어 성능상 push_back에 비해 유리하다 ([**참고**](https://sonagi87174.tistory.com/14))
- map 컨테이너에 대해 설명하면? key와 value로 이루어져 있으며 이는 pair 객체 형태로 저장된다 ([**참고**](https://uncertainty-momo.tistory.com/46))
- map의 장점은? Key 값으로 자동 정렬이 된다는 점과 이 Key를 통해 인자에 접근이 가능하다는 점이 장점이다 ([**참고**](https://underwatch.tistory.com/12))
- 시퀀스 컨테이너란? 데이터를 선형으로 저장하는 자료구조 이며 vector, list, deque등이 이에 해당합니다 ([**참고**](https://cclient.tistory.com/m/12))
- 연관 컨테이너란? 일정한 규칙에 따라 자료를 조직화하여 저장하는 자료구조 이며 대표적으로 map, set이 이에 해당합니다 ([**참고**](https://cclient.tistory.com/m/12))
- 어댑터 컨테이너란? 시퀀스 컨테이너를 변형시켜 스택, 큐, 우선순위 큐 형태로 저장하는 것을 말합니다 ([**참고**](https://cclient.tistory.com/m/12))
- 컨테이너란? 같은 타입의 여러 객체를 저장하는 일종의 집합이라고 할 수 있습니다 ([**참고**](https://cclient.tistory.com/m/12))
- 이터레이터(반복자)란? 이터레이터는 컨테이너에 저장된 원소를 순회하고 접근하는 일반화된 방법을 제공합니다 또한 컨테이너와 알고리즘이 하나로 동작하게 묶어주는 인터페이스 역할을 합니다 ([**참고**](https://cclient.tistory.com/m/12))
- 트리에 대해 설명하면? 계층적인 자료를 표현하는데 이용되는 자료구조이다 관련 용어로 루트노드는 부모가 없는 최상위 노드를 뜻하며 리프노드는 자식이 없는 노드를 뜻한다 depth(깊이)는 루트 노드로부터의 거리를 뜻하고 height(높이)는 depth(깊이) 중 최댓값을 뜻한다 ([**참고**](https://jud00.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%8A%B8%EB%A6%ACTree%EB%9E%80))
- 재귀함수와 반복문의 차이는? 재귀함수는 함수 자체를 재귀적으로 호출하기 때문에 스택 프레임이 쌓여 실행 속도가 느리다 하지만 가독성이 좋다 반복문은 명령을 반복적으로 실행해 실행 속도가 빠르다 하지만 코드 길이가 길어지고 변수가 많아져 가독성이 떨어진다 ([**참고**](https://velog.io/@gillog/Algorithm-%EC%9E%AC%EA%B7%80%EC%99%80-%EB%B0%98%EB%B3%B5%EB%AC%B8))
- 해시테이블(Hash Table)과 이진탐색트리(Binary Search Tree)의 장단점을 설명하면? 이진탐색트리는 딱 필요한 원소 만큼의 공간만을 할당하는 반면, 해시테이블은 데이터가 저장되기 전에 미리 공간을 만들어놔야 하므로 공간 효율성이 떨어집니다 때문에 메모리 측면에서는 이진탐색트리가 유리하다 하지만 이진탐색트리는 노드 기반 자료구조로 메모리 파편화가 진행되어 캐시 적중률이 떨어지게 된다 반면, 해시 테이블은 배열 기반 자료구조로 연속된 메모리를 유지하기 때문에 캐시 적중률이 상당히 높다 그리고 이진탐색트리의 탐색속도는 O(LogN) 이고 해시 테이블은 O(1) 이다 ([**참고**](https://think0wise.tistory.com/66)), ([**참고**](https://algorfati.tistory.com/123))
- STL에서 erase와 remove의 차이점은? erase는 데이터 공간까지 지우기 때문에 capacity가 감소한다 remove는 지워야 할 원소의 뒤에 원소들을 하나씩 앞으로 당겨 덮어 씌움으로써 지워진 것처럼 보이게 하기 때문에 capacity가 그대로이다 ([**참고**](https://novemberfirst.tistory.com/m/111))
- List 클래스의 추가/삭제 함수를 손코딩 하면? ([**참고**](https://geundung.dev/49))
- 시간복잡도란 무엇인가? 시간 복잡도는 문제를 해결하는데 걸리는 시간과 입력의 함수 관계를 가리킨다 ([**참고**](https://ko.wikipedia.org/wiki/%EC%8B%9C%EA%B0%84_%EB%B3%B5%EC%9E%A1%EB%8F%84))
- 벡터와 일반 배열의 메모리 구조의 차이는 뭘까요? 벡터는 Heap 메모리를 사용하고, 배열은 Stack 메모리를 사용한다 ([**참고**](https://dobby-the-house-elf.tistory.com/104))
- 그래프를 정의한다면? 노드(N, node)와 그 노드를 연결하는 간선(E, edge)을 하나로 모아 놓은 자료구조 ([**참고**](https://gmlwjd9405.github.io/2018/08/13/data-structure-graph.html))
- 해싱이란? 통상적인 반복 비교를 통하지 않고, 특정 계산 만으로 바로 자료 저장 위치를 알아내는 탐색 방법 ([**참고**](http://www.ktword.co.kr/test/view/view.php?m_temp1=5389))
- 우선순위 큐의 동작 원리는? (1) 삽입할 원소는 완전 이진트리를 유지하는 형태로 순차적으로 삽입된다 (2) 삽입 이후에는 루트 노드까지 거슬러 올라가면서 최대 힙을 구성(상향식) ([**참고**](https://velog.io/@april_5/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90Priority-Queue))
- 이진트리와 이진탐색트리 차이는? 이진탐색트리는 이진트리의 특성 외에 왼쪽 자식 노드는 부모보다 작고, 오른쪽 자식 노드는 부모보다 크다는 특성을 갖고있다 ([**참고**](https://velog.io/@main_door/%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC%EC%99%80-%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC))
- 우선순위큐(PriorityQueue)의 동작원리는? 부모 노드와 자식 노드를 비교해 최대힙은 원소 값이 큰 노드가 위로가게 자리를 바꾸고 최소힙은 원소 값이 작은 노드가 위로가게 자리를 바꾼다 ([**참고**](https://chanhuiseok.github.io/posts/ds-4/))
- 전위 순회, 중위 순회, 후위 순회를 각각 설명하면? 전위 순회는 뿌리->왼쪽 자식->오른쪽 자식 순으로 방문한다 중위 순회는 왼쪽자식-> 뿌리-> 오른쪽 자식 순으로 방문한다 후위 순회는 왼쪽자식->오른쪽 자식-> 뿌리 순으로 방문한다 ([**참고**](https://m.blog.naver.com/rlakk11/60159303809))
- 우선순위큐와 힙의 차이는? 우선순위 큐는 추상적인 자료형이다 힙은 자료구조이다 ([**참고**](https://lin-ing-link.tistory.com/162))
- 해시 테이블에서 버킷과 슬롯에 대해 설명하면? 버킷은 여러개의 슬롯을 저장하는 자료구조이다 슬롯은 한 개의 데이터를 저장할 수 있는 공간이다 ([**참고**](https://velog.io/@fore0919/TIL-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%95%B4%EC%89%AC%ED%85%8C%EC%9D%B4%EB%B8%94Hash-Table))
- std::sort와 list.sort의 차이에 대해 설명하면? 구현 방식의 차이는 std::sort는 QuickSort 알고리즘을 사용하여 구현되고 list.sort는 MergeSort 알고리즘을 사용하여 구현된다 두 방식 모두 시간복잡도가 N(logN)인데 list는 메모리 상에서 연속된 공간을 사용하지 않으므로, std::sort보다는 약간 느릴 수 있다 std::sort는 객체의 swap() 함수를 사용하여 객체를 이동시키고, list.sort는 객체의 move() 함수를 사용하여 객체를 이동시키기 때문에 객체가 큰 경우에는 list.sort가 더 효율적일 수 있다
- stable_sort에 대해 설명하면? sort() 기존 순서를 보장하지 않고 stable_sort() 기존 순서를 보장한다 sort()는 퀵 정렬(QuickSort) 방식이며 stable_sort()는 합병 정렬(MergeSort) 방식이다 ([**참고**](https://zoosso.tistory.com/1085))

### 01-3 알고리즘 ( 중요도 상 )
- QuickSort를 설명하면? 리스트 안에 있는 한 요소를 선택한다 이렇게 고른 원소를 pivot 이라고 한다 -> 피벗 앞에는 피벗보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 리스트를 둘로 나눈다 이렇게 배열을 둘로 나누는 것을 분할(Divide) 이라고 한다 분할을 마친 뒤에 피벗은 더 이상 움직이지 않는다 -> 분할된 부분 리스트들에 대해 재귀(Recursion)적으로 이 과정을 반복한다 ([**참고**](https://gyoogle.dev/blog/algorithm/Quick%20Sort.html))
- QuickSort에서 pivot을 선택하는 방법은? Median Of Three Pivot 이라는 방법이 있으며 3개의 원소를 후보로 두고 그 중간 값을 선택하는 방법이다 ([**참고**](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=ljy9378&logNo=221508655059))
- 다익스트라 알고리즘에 대해 설명하면? 특정한 노드에서 출발하여 다른 노드로 가는 최단 경로를 구해주는 알고리즘이다, 동작 원리는 ( 1 ) 출발 노드를 설정한다 -> ( 2 ) 최단 거리 테이블을 초기화한다 -> ( 3 ) 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다 -> ( 4 ) 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다 (5) 위 과정에서 3번과 4번을 반복한다 ([**참고**](https://amazelimi.tistory.com/27)), ([**참고**](https://yabmoons.tistory.com/364))
- DFS와 BFS 알고리즘의 차이는? DFS는 현재 노드에서 갈 수 있는 만큼 최대한 깊게 방문하고, 더이상 방문할 곳이 없으면 이전 노드로 돌아간다 너비우선탐색인 BFS는 같은 레벨의 인접 노드를 모두 방문한뒤 다음 레벨 인접 노드를 방문한다 ([**참고**](https://currygamedev.tistory.com/10))
- BFS와 다익스트라 알고리즘의 차이는? BFS는 간선을 이동하는 비용(가중치)을 고려하지 않고, 다익스트라 알고리즘은 해당 비용(가중치)을 고려한다 ([**참고**](https://medium.com/@pyeonjy97/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-dijkstra-algorithm-5d64a6cffced))
- 평소 자주 사용하는 정렬 알고리즘은 무엇인가? STL Sort 함수를 자주 사용하기 때문에, QuickSort 알고리즘을 주로 사용한다고 할 수 있다 ([**참고**](https://blockdmask.tistory.com/178))
- 퀵소트와 버블 소트의 차이는? 퀵소트는 데이터가 불규칙하거나 규칙적인 것에 따라 비교 수가 변한다 버블 소트는 데이터가 불규칙하거나 규칙적인 것에 따라 비교 수가 변하지는 않는다 ([**참고**](https://studyfield.tistory.com/154))
- 병합정렬(Merge Sort) 구현 방법은? 주어진 배열을 원소가 하나 밖에 남지 않을 때까지 계속 둘로 쪼갠 후에 다시 크기 순으로 재배열 하면서 원래 크기의 배열로 합친다 ([**참고**](https://www.daleseo.com/sort-merge/))
- 퀵소트의 시간 복잡도가 O(n^2)인 경우 즉 최악의 경우는 어떻게 발생할 수 있는가? 배열이 오름차순 정렬되어있거나 내림차순 정렬되어있는 경우에 재귀 호출의 깊이 곱하기 각 재귀 호출 단계의 비교 연산 = n^2 이라는 최악의 시간복잡도를 갖는다 ([**참고**](https://gyoogle.dev/blog/algorithm/Quick%20Sort.html))
- 정렬된 원소를 가지고 있는 배열에서 원하는 원소를 찾는 방법에는 어떤 것이 있는가? 이진탐색(Binary Search)과 파라메트릭서치(Parametric Search)가 있습니다 이진 탐색은 중간값을 선택하여 찾으려는 값과 비교해 찾으려는 값이 더 클 경우 선택했던 중간값을 최솟값으로, 작을 경우 중간값을 최댓값으로 하여 원하는 값을 찾을 때까지 이 과정을 반복하는 알고리즘입니다 파라메트릭서치는 조건을 만족하는 최소/최댓값을 구하는 문제( 최적화 문제 )를 결정 문제 로 변환해 이분탐색을 수행하는 방법입니다 ([**참고**](https://velog.io/@nimok97/c-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%9C%EB%85%90-%EB%B3%B5%EC%8A%B5%ED%95%98%EA%B8%B0-18-%EC%9D%B4%EB%B6%84%ED%83%90%EC%83%89-Parametric-Search)), ([**참고**](https://loosie.tistory.com/518))
- 신장트리란(Spanning Tree)? 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프를 의미한다 ([**참고**](https://gmlwjd9405.github.io/2018/08/28/algorithm-mst.html))
- 크루스칼 알고리즘에 대해 설명하면? 크루스칼 알고리즘은 신장 트리 중에서 최소 비용으로 만들 수 있는 신장트리를 찾는 알고리즘인 최소 신장 트리 알고리즘의 대표적인 예이다 ( 내 블로그 참조 )
- 프림 알고리즘이란? 무향 연결 그래프가 주어질 때, 최소 스패닝 트리 라고 부르는 서브 그래프를 찾는 알고리즘입니다 ([**참고**](https://www.weeklyps.com/entry/%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Prims-algorithm))
- MST(Minimum Spanning Tree) 대해 설명하면? Spanning Tree 중에서 사용된 간선들의 가중치 합이 최소인 트리 ([**참고**](https://gmlwjd9405.github.io/2018/08/28/algorithm-mst.html))
- 벨만 포드 알고리즘과 다익스트라 알고리즘 차이점은? 두 알고리즘의 차이점은 간선의 가중치에 음수가 있느냐(벨만-포드) 없느냐(다익스트라)이다 ([**참고**](https://shyeon.tistory.com/2))
- 플로이드 워셜 알고리즘에 대해 설명하면? 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우에 사용할 수 있는 알고리즘이다 ( 내 블로그 참조 )
- DFS와 백트래킹의 차이는? DFS는 모든 경우의 수를 탐색하고 백트래킹은 불필요한 탐색을 하지 않는다 ([**참고**](https://veggie-garden.tistory.com/24))
- 슬라이딩 윈도우 알고리즘과 투 포인터 알고리즘의 차이는? 투 포인터 알고리즘은 부분 배열의 길이가 가변적이지만 슬라이딩 윈도우 알고리즘은 부분 배열의 길이가 고정적입니다 ([**참고**](https://velog.io/@codenmh0822/%ED%88%AC-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%94%A9-%EC%9C%88%EB%8F%84%EC%9A%B0-%EA%B5%AC%EA%B0%84-%ED%95%A9-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98))

### 01-4 그래픽스 ( 중요도 상 )
- 벡터의 내적 외적에 대해 설명하면? 내적은 두 벡터의 각 성분끼리의 곱의 합이다 내적은 두 개의 벡터가 있을때 한 벡터의 방향으로 나머지 하나를 projection(투영) 시킨 것과 다른 한 벡터의 크기의 곱이다 외적은 두 벡터의 수직인 벡터를 구하는 방법이다 참고로 투영이란 3차원 입체에서 2차원 평면, 2차원 평면에서 1차원 직선, 직선에서 다른 직선 등으로 주로 차원을 단순화시키며 도형을 변환시키는 것을 의미한다 ([**참고**](http://www.findmean.com/%EC%88%98%ED%95%99/%EB%B2%A1%ED%84%B0/%EB%B2%A1%ED%84%B0%EC%9D%98-%EB%82%B4%EC%A0%81/)), ([**참고**](https://www.youtube.com/watch?v=sOAgJmsHKLE)), ([**참고**](http://www.findmean.com/%EC%88%98%ED%95%99/%EB%B2%A1%ED%84%B0/%EB%B2%A1%ED%84%B0%EC%9D%98-%EC%99%B8%EC%A0%81/)), ([**참고**](https://www.youtube.com/watch?v=Muu6PLRQXZk)), ([**참고**](http://www.ktword.co.kr/test/view/view.php?m_temp1=4795))
- 짐벌락에 대해 설명하면? 짐벌락은 같은 방향으로 오브젝트의 두 회전 축이 겹치는 현상을 말한다 쿼터니언은 세개의 축이 동시에 업데이트 되기 때문에 짐벌락을 해결하는 방법이 될 수 있다 ([**참고**](https://chonjay.tistory.com/entry/%EC%98%A4%EC%9D%BC%EB%9F%AC%EA%B0%81-gimbal-lock-%EB%AC%B8%EC%A0%9C%EC%BF%BC%ED%84%B0%EB%8B%88%EC%96%B8%EC%9C%BC%EB%A1%9C-%ED%95%B4%EA%B2%B0-%EA%B0%80%EB%8A%A5))
- 쿼터니언에 대해 설명하면? 3차원 그래픽에서 회전을 표현할 때, 행렬 대신 사용하는 수학적 개념으로 4개의 값으로 이루어진 복소수(Complex Number) 체계이다 ([**참고**](https://showmiso.tistory.com/57))
- 랜더링 파이프라인에 대해 설명하면? 입력 조립기 - 버텍스 셰이더 - 테셀레이션 - 지오메트리 셰이더 - 레스터라이저 - 픽셀 셰이더 - 출력 병합기 순으로 3차원의 가상 세계를 2차원의 이미지로 생성한다 ([**참고**](https://doobudubu.tistory.com/m/243))
- AABB, OBB 충돌 판별에 대해 설명하고 코드로 구현하면? AABB는 좌상단 꼭짓점을 min, 우하단 꼭짓점을 max라고 했을 때 한쪽 사각형의 max가 다른 사각형의 min보다 작거나 한쪽 사각형의 min이 다른 사각형의 max보다 크면 두 사각형은 만나지 않는다에 기반을 둔 충돌 판별법이다 OBB는 두 블록을 분리할 수 있는 축이 있으면 두 블록은 만나지 않는다에 기반을 둔 충돌 판별법이다 분리 축이 존재한다면, 어느 직선에 도형을 투영시켰을 때 투영된 구간이 겹치지 않는 경우가 생긴다 ([**참고**](https://kareus.tistory.com/m/15)), ([**참고**](https://justicehui.github.io/other-algorithm/2018/06/23/OBB/))
- 행렬 법칙에 대해 설명하면? 행렬은 덧셈의 교환법칙, 덧셈의 결합법칙, 곱셈의 결합법칙이 성립한다  ([**참고**](http://matrix.skku.ac.kr/sglee/linear/ocu/20103.html))
- 포워드 랜더링과 디퍼드 랜더링의 차이에 대해서 설명하면? 포워드 랜더링은 3D공간에서 존재하는 폴리곤을 픽셀화하여 그 픽셀 마다 쉐이딩과 라이팅 연산을 더하는 방식입니다 해상도가 올라가도 요구하는 메모리가 디퍼드보다 적지만 라이팅 연산이 느립니다 디퍼드 렌더링은 한 화면에 수많은 라이팅 효과를 넣고 싶어서 만든 렌더링 기법입니다 실시간으로 라이팅에 반응 하는 쉐이더를 쓰는 게임은 기본적으로 디퍼드 렌더링입니다 구현방식은 폴리곤을 픽셀화하여 포토샵의 레이어처럼 정보를 나누어 비디오 메모리에 저장합니다 여기에서 각종 쉐이더와 라이팅효과를 거처 화면에 보여줍니다 ([**참고**](https://cclient.tistory.com/m/13))
- 소프트웨어 렌더러가 삼각형을 그리는 원리에 대해 설명하면? 스캔 라인 알고리즘으로 그리면 된다 삼각형을 세로로 한 줄씩 나누고 가로 일직선으로 분해한 후 그 선분을 위에서부터 차례대로 그리는 것이다 ([**참고**](https://domaindeveloper.tistory.com/38))
- 컬링 기법들을 아는대로 나열하고 설명하면? 컬링의 종류는 백페이스 컬링(BackFace Culling), 오클루전 컬링(Occlusion Culling), 프러스텀 컬링(ViewFrustum Culling)이 있다 백페이스 컬링은 물체의 뒷면을 렌더링에서 제외하는 것이다 오클루전 컬링은 다른 오브젝트에 가려진 오브젝트들은 렌더링하지 않는 것이다 프러스텀 컬링은 카메라의 뷰 프러스텀(View Frustum) 영역 밖의 오브젝트들은 렌더링하지 않는 것이다 ([**참고**](https://rito15.github.io/posts/unity-opt-occlusion-culling/))
- DirectX 9과 DirectX 11의 차이점은? 렌더링 파이프라인에서 차이가 있다 DirectX 9은 3D 좌표를 2D로 표현하기 위해 로컬 정점 -> 월드 스페이스 -> 뷰 스페이스 -> 조명 연산 -> 컬링 연산 -＞ 투영 연산 -> 클리핑 -> 뷰 포트 -> 레스터라이즈 과정을 거친다 DirectX 11은 입력 조립기 - 버텍스 셰이더 - 테셀레이션 - 지오메트리 셰이더 - 레스터라이저 - 픽셀 셰이더 - 출력 병합기 과정을 거친다 ([**참고**](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=minizang99&logNo=220963722023))
- DirectX 에서 w 나누기를 하는 이유는? 투영을 할때 동차좌표 개념을 도입해 각점을 해당 z값으로 나누기 위함이다 ([**참고**](https://www.gpgstudy.com/forum/viewtopic.php?t=6396))
- 더블 버퍼링과 스왑 체인에 대해 설명하면? 프레임 버퍼가 갱신되는 과정에서 스크린에 깜빡거림(Flickering)이 생길 수 있다 이 현상을 방지하기 위해서 전면 버퍼(front buffer)외에 화면 밖(off screen)의 후면 버퍼(back buffer)를 추가적으로 두는데, 이 방식을 이중 버퍼링 이라고 하고 한다 또한 후면 버퍼에 그리기가 완료되면 전면 버퍼와 후면 버퍼를 교환하는데 이때 비디오 컨트롤러는 전면 버퍼 만을 참조해 스크린을 갱신한다 이 방식을 스왑체인 이라고 한다 ([**참고**](https://handhp1.tistory.com/10))
- 알파블렌딩과 알파테스트의 차이는? 알파블렌드는 블랜딩 설정에 따라 색상이 혼합되는 것이고, 알파테스트는 설정값을 기준으로 해당되는 범위의 값을 제거 하는 것이다 ([**참고**](https://mgun.tistory.com/130))
- 알파소팅에 대해 설명하면? 알파가 없는 오브젝트들은 화면 앞의 오브젝트부터 뒤에 있는 오브젝트 순으로 렌더링하는게 빠르다 이유는 화면 앞의 오브젝트를 렌더링하면 그 뒤에 가려진 오브젝트는 렌더링하지 않아도 되기 때문에 속도가 빨라지는 원리입니다 반투명,투명 오브젝트는 반대로 뒤에서부터 그려야 합니다 그래야 앞에 반투명 오브젝트를 그리더라도, 먼저 그려진 뒤의 오브젝트가 비춰서 보이기 때문이다 이런 이유 때문에 게임에서는 알파가 없는것들 따로 그리고, 알파가 있는것들을 따로 그린다 이것을 알파 소팅 이라고 한다 ([**참고**](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=agebreak&logNo=60123549628))
- 인덱스 버퍼를 사용하는 이유는? 버텍스 버퍼는 각 폴리곤 마다 정점이 3개씩 존재하기 때문에 큰 도형일 경우 부하가 발생할 수 있다 하지만 인덱스 버퍼는 각 포인트 마다만 정점을 생성하고, 순서만 지정하면 되기 때문에 훨씬 가볍다 참고로 인덱스 순서는 컬링 모드를 사용하기 위해 되도록 시계방향으로 하자 ([**참고**](https://showmiso.tistory.com/142)), ([**참고**](https://carrotclub.tistory.com/16))
- 깊이버퍼란? 현재 프러스텀에서 모든 픽셀의 깊이값을 기록하는 데 사용합니다 같은 위치에 여러 픽셀이 자리하는 경우 깊이값을 이용하여 어느 픽셀을 사용할 지 고르게 됩니다 ([**참고**](https://blog.nullbus.net/80))
- 역행렬에 대해 설명하면? 어떤 행렬 A와 곱했을 때 곱셈에 대한 항등원인 단위행렬 E가 나오게 하는 행렬을 행렬 A의 역행렬 이라고 한다 ([**참고**](https://mathbang.net/567))

### 01-5 운영체제 ( 중요도 중 )
- 운영체제가 사용하는 메모리 영역에 대해 설명하면? OS 메모리 구조는 2가지 영역으로 나누는데 바로 유저 영역, 커널 영역이다 유저영역 메모리는 4가지로 나눠지는데 데이터영역, 힙영역, 코드영역, 스택 영역으로 구분이 된다 그리고 커널 영역은 시스템 운영에 필요한 메모리로 운영체제가 올려져 있다 ([**참고**](https://webstone.tistory.com/96))
- 스레드란 무엇인가? 프로세스가 할당받은 자원을 이용하는 실행 단위다 ([**참고**](https://becomeweasel.me/process-and-thread/))
- 프로세스가 사용하는 메모리 영역과 스레드가 사용하는 메모리 영역의 차이점은? 프로세스는 각자 본인이 사용하는 메모리 영역과 레지스터 값을 가지며 프로세스의 메모리 영역은 데이터, 힙, 코드, 스택 영역으로 구성된다 그리고 스레드는 각자의 레지스터와 스택을 가지지만, 나머지 영역은 가지지 않는다. 대신에 데이터, 힙, 코드 영역을 공유해서 병렬적인 수행이 가능하다. ([**참고**](https://becomeweasel.me/process-and-thread/))
- 라운드 로빈 알고리즘에 대해서 설명하면? 라운드 로빈(RR) 스케쥴링 알고리즘은 시간 할당량 또는 타임슬라이스 라고 하는 작은 단위의 시간을 정의하고 CPU 스케쥴러는 준비 큐를 돌면서 한 번에 한 프로세스에 정의된 시간 할당량 동안 CPU를 할당한다 ([**참고**](https://woo-dev.tistory.com/163))
- 컴퓨터에 존재하는 메모리들의 액세스 속도를 설명 하면? 레지스터는 프로세서에 위치한 고속 메모리로 프로세서가 바로 사용할 수 있는 데이터를 담고있다, 캐시는 레지스터 다음으로 빠른 메모리이며 CPU 내부에 존재한다 CPU가 필요로 하는 데이터가 레지스터에 없는 경우에 주기억장치로부터 데이터를 읽어오기 위해서는 상당히 긴 시간이 필요하다 때문에 자주 사용되는 데이터를 주기억장치에서 복사해와 CPU의 메모리 접근시간을 줄이기 위해 사용한다, 주기억장치는 CPU가 처리하고 있는 내용이 가져와지는 곳을 말한다, 보조기억장치는 주기억장치보다는 느리지만 많은 양의 데이터를 전원이 꺼져도 사라지지 않고 영구적으로 보관할 수 있는 장치이다 ([**참고**](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=cjsksk3113&logNo=222246966805))
- context switching에 대해 설명하면? 현재 진행하고 있는 Task(Process, Thread)의 상태를 저장하고 다음 진행할 Task의 상태 값(PCB)을 읽어 적용하는 과정을 말합니다 ([**참고**](https://nesoy.github.io/articles/2018-11/Context-Switching))
- PCB에 대해서 설명하면? 운영체제에서 프로세스에 대한 메타데이터(대량의 정보 가운데에서 확인하고자 하는 정보를 효율적으로 검색하기 위해 원시데이터)를 저장한‘데이터’를 말하며 프로세스 스케줄링 상태, 프로세스 ID 등의 정보로 이루어져 있다 ( 내 블로그 참고 )
- 스레드 프로그래밍에서 중요한건? 스레드 마다 별도로 주어지는 공간(스택), 모든 스레드가 공유하는 공간(힙, 데이터 영역)에 대해 파악하고 코드를 작성해야 한다 ([**참고**](https://elky.tistory.com/285))
- 블로킹(blocking) vs 논블로킹(non-blocking)에 대해서 설명하면? blocking은 A 함수가 B 함수를 호출 할 때, B 함수가 자신의 작업이 종료되기 전까지 A 함수에게 제어권을 돌려주지 않는 것 non-blocking은 A 함수가 B 함수를 호출 할 때, B 함수가 제어권을 바로 A 함수에게 넘겨주면서, A 함수가 다른 일을 할 수 있도록 하는 것 ([**참고**](https://jh-7.tistory.com/25))
- 프로세스와 스레드의 차이는? 프로세스는 메모리 상에서 실행중인 프로그램을 말하며, 스레드는 이 프로세스 안에서 동작하는 실행 단위다 ([**참고**](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Interview/Interview%20List.md#%EC%96%B8%EC%96%B4))
- 멀티 프로세스로 처리 가능한걸 굳이 멀티 스레드로 하는 이유는? 프로세스를 생성하여 자원을 할당하는 시스템 콜이 감소함으로써 자원의 효율적 관리가 가능하며, 프로세스 간의 통신(IPC)보다 스레드 간의 통신 비용이 적다, 대신 동기화에 신경을 써야한다 ([**참고**](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Interview/Interview%20List.md#%EC%96%B8%EC%96%B4))
- 교착상태(데드락)가 무엇이며 4가지 조건은? 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태이며 상호배제, 점유대기, 비선점, 순환대기 이 4가지 조건 중 하나라도 만족하지 않으면 교착상태는 발생하지 않는다 ([**참고**](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Interview/Interview%20List.md#%EC%96%B8%EC%96%B4)), ([**참고**](https://velog.io/@dl_edge/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-4%EA%B0%80%EC%A7%80-%EC%A1%B0%EA%B1%B4))
- 교착상태를 해결하는 방법은? 예방, 탐지, 회피, 무시 ([**참고**](https://hoyeonkim795.github.io/posts/%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95/))
- 메모리 할당 알고리즘 3가지는? First fit은 메모리의 처음부터 검사해서 크기가 충분한 첫 번째 메모리에 할당, Next fit은 마지막으로 참조한 메모리 공간에서부터 탐색을 시작해 공간을 찾아 할당, Best fit은 모든 메모리 공간을 검사해서 내부 단편화를 최소화하는 공간에 할당 ([**참고**](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Interview/Interview%20List.md#%EC%96%B8%EC%96%B4))
- 페이지 폴트란 무엇인가? CPU가 프로그램을 실행하면서 필요한 페이지가 물리적 메모리에 없는 경우도 생기게 되는데 이것을 페이지 폴트(Page Fault)라고 한다 ([**참고**](https://velog.io/@jiseong/OS-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%80%ED%8F%B4%ED%8A%B8-gyq8tftz))
- 페이지 폴트 발생시 사용하는 알고리즘과 해당 알고리즘에 대해 설명하면? 페이지 교체 알고리즘을 사용하며, OPT는 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체 ( 실현 가능성 없음 ), FIFO는 메모리가 할당된 순서대로 페이지를 교체, LRU는 가장 오랫동안 사용되지 않은 페이지 교체, LFU는 사용 빈도가 가장 적은 페이지를 교체, NUR은 최근에 사용하지 않은 페이지를 교체 ([**참고**](https://velog.io/@jiseong/OS-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%80%ED%8F%B4%ED%8A%B8-gyq8tftz))
- 내부 단편화와 외부 단편화를 설명하면? 내부 단편화는 메모리를 할당할 때 프로세스가 필요로 하는 크기보다 더 큰 메모리가 할당되어 프로세스에서 사용하는 메모리 공간이 낭비 되는 현상이다 외부 단편화란 남아있는 총 메모리 공간이 요청한 메모리 공간보다 크지만, 남아있는 공간이 연속적(contiguous)이지 않아 사용하지 못하는 공간이 발생하는 현상이다 ([**참고**](https://junghyun100.github.io/%EB%A9%94%EB%AA%A8%EB%A6%AC%EB%8B%A8%ED%8E%B8%ED%99%94/)), ([**참고**](https://code-lab1.tistory.com/54))
- 가상메모리란? 실제로 프로그램 수행에 필요한 부분만 메모리에 올려놓음으로써 주기억장치의 용량보다 큰 프로세스라도 사용자가 메모리에 올려놓을 수 있게 하는 기법이다 ([**참고**](https://luv-n-interest.tistory.com/1005))
- 페이징의 정의와 작동하는 원리를 설명하면? 페이징은 virtual memory를 page로 나누는 기법을 말하며 주기억장치와 보조기억장치의 데이터 공간을 모두 동일한 크기로 나눈뒤 데이터 접근이 일어날 때, 보조기억장치에서 필요한 페이지들을 꺼내 주기억장치의 영역(프레임)에 적재시킨다 ([**참고**](https://velog.io/@dd9s2/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EA%B8%B0%EC%96%B5-%EC%9E%A5%EC%B9%98%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%95-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98-Virtual-Memory-Paging-Segmentation))
- 세그먼테이션에 대해 설명하면? 메모리를 서로 크기가 다른 논리적인 블록 단위인 '세그먼트(segment)'로 분할하고 메모리를 할당하여 물리 주소를 논리 주소로 변환하는 것을 말한다 ( 미리 분할하지 않고 메모리를 사용할 시점에 할당된다는 것이 중요하다 ) ([**참고**](https://plummmm.tistory.com/356))
- 세마포어, 뮤텍스의 정의와 차이점을 설명하면? 세마포어는 공유 자원에 대한 접근을 제한하는 방법이며, 뮤텍스는 임계 구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술이다 차이점은 뮤텍스는 동기화 대상이 오직 1개일 때 사용하며, 세마포어는 동기화 대상이 1개 이상일 때 사용한다 ([**참고**](https://gyoogle.dev/blog/computer-science/operating-system/Semaphore%20&%20Mutex.html)), ([**참고**](https://heeonii.tistory.com/14))
- 사용자 수준 스레드의 정의와 장단점을 설명하면? 사용자 스레드는 커널 영역의 상위에서 지원되며 일반적으로 사용자 레벨의 라이브러리를 통해 구현된다 라이브러리는 스레드의 생성 및 스케줄링 등에 관한 관리 기능을 제공한다 장점은 스케줄링과 동기화를 위해 System Call(커널 호출) 하지 않기 때문에 오버헤드 적다는 것이고(Context Switching을 프로세스 내부에서 진행하면 됨) 단점은 하나의 스레드가 System Call(커널 호출)하면 해당 프로세스 내 모든 스레드가 중단된다는 것이다 ([**참고**](https://kspsd.tistory.com/50))
- 커널 수준 스레드의 정의와 장단점을 설명하면? 커널 스레드는 운영체제가 지원하는 스레드 기능으로 구현되며, 커널이 스레드의 생성 및 스케줄링 등을 관리한다 장점은 커널이 각 스레드를 개별적으로 관리할 수 있다는 것이고 단점은 유저 모드와 커널 모드 간 전환이 빈번하여 성능 저하된다는 것이다 ([**참고**](https://kspsd.tistory.com/50))
- Race Condition에 대해 프로세스 관점으로 설명하면? Race Condition이란 두 개 이상의 cocurrent한 프로세스들이 하나의 자원(리소스)에 접근하기 위해 경쟁하는 상태를 말합니다, 여기서 cocurrent하다는 말은 동시성(병행성)을 가진다는 말이다 ([**참고**](https://zangzangs.tistory.com/115)), ([**참고**](https://seamless.tistory.com/42)), ([**참고**](https://modoocode.com/270))
- Race Condition에 대해 쓰레드 관점으로 설명하면? 서로 다른 쓰레드들이 동일한 자원(메모리 등)을 사용할 때 발생하는 문제를 경쟁 상태(race condtion) 이라 부릅니다 ([**참고**](https://junstar92.tistory.com/184)), ([**참고**](https://modoocode.com/270))
- 동기(Synchronous) vs 비동기(Asynchronous)에 대해서 설명하면? 함수 A가 함수 B를 호출한 뒤, 함수 B의 리턴값을 계속 확인하면서 신경쓰는 것이 동기이다 비동기는 함수 A가 함수 B를 호출한 뒤, 함수 B의 리턴값이 반환 되었는지 신경쓰지 않는다 ([**참고**](https://velog.io/@nittre/%EB%B8%94%EB%A1%9C%ED%82%B9-Vs.-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8F%99%EA%B8%B0-Vs.-%EB%B9%84%EB%8F%99%EA%B8%B0))
- 메모리 구조에서 스택과 큐의 역할은? 메모리에서 스택은 지역변수와 매개변수 데이터 값이 저장되는 공간이며, 메소드 호출시 매모리에 할당되고 종료되면 메모리가 해제된다 큐는 heap의 FIFO 성질을 구현하기위해 사용된다 ([**참고**](https://velog.io/@kingyong9169/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0))
- context switching의 오버헤드의 주원인은? context switching 때 해당 CPU는 아무런 일을 하지 못한다, 따라서 컨텍스트 스위칭이 잦아지면 오버헤드가 발생해 효율(성능)이 떨어진다 ([**참고**](https://landwhale2.github.io/cs/106/))
- 메모리 단편화와 해결책에 대해서 설명하면? 사용가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태를 보고 메모리 단편화가 발생했다고 한다 해결책에는 세그먼테이션(내부단편화), 페이징(외부단편화), 메모리풀(모두해결), 통합(모두해결), 압축(모두해결)과 같은 기법들이 있다 ([**참고**](https://gguljaem.tistory.com/entry/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94Fragmentation%EC%97%90-%EB%8C%80%ED%95%9C-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95))
- 시스템 콜이란? 프로세스가 운영체제(system)에게 운영체제 기능을 요청(call)하는 것입니다 ([**참고**](https://dolphinsarah.tistory.com/54))
- 좀비 프로세스에 대해서 설명하면? 실행이 종료되었지만 아직 삭제되지 않은 프로세스를 말한다 ([**참고**](https://www.joinc.co.kr/w/Site/system_programing/process/Zombie))
- 고아 프로세스에 대해서 설명하면? 부모프로세스가 필요에 의해서 먼저 종료 되기도 하는데, 이때 자식프로세스만 남게 되는경우 이 자식프로세스를 고아프로세스라고 한다 ([**참고**](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=icecds&logNo=40053269520))
- 데몬 프로세스에 대해서 설명하면? 백그라운드로 사용자 모르게 동작하는 프로세스를 말한다 ([**참고**](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=icecds&logNo=40053269520))
- 메모리풀의 정의와 장단점을 설명하면? 메모리풀은 메모리를 미리 할당 받아놓고, 사용자가 필요할 때 메모리를 제공하는 것을 말합니다 장점은 메모리 단편화가 줄어듭니다 단점은 메모리 사용 효율성이 떨어질 수 있습니다 ([**참고**](https://linkmemo.tistory.com/183))
- 메모리 구조에 대해 설명하면? 실행할 프로그램의 코드가 저장되어 프로그램이 종료되어야 소멸되는 코드영역, 전역변수와 정적변수가 저장되고 프로그램이 종료되어야 소멸되는 데이터 영역, 함수의 호출과 관계되는 지역변수와 매개변수가 저장되며 함수의 호출과 함께 할당되고 함수의 호출이 완료되면 소멸하는 스택영역, 사용자가 직접 관리할 수 있고 사용자에 의해 메모리 공간이 동적으로 할당되고 해제되는 힙영역이 있습니다 ([**참고**](https://sshoreng.tistory.com/80?category=712983))
- 멀티프로세스와 멀티쓰레드의 차이는? 멀티프로세스는 여러개의 일을 복수의 프로세스가 처리하며 프로세스간 통신 코스트가 크다는 특징이 있습니다 멀티쓰레드는 한개의 일을 복수의 쓰레드가 처리하는 것인데, 공유 메모리를 써서 메모리를 적게 사용하며 하나의 일처리를 분산할 수 있지만, 쓰레드간의 간섭이 있어 잘 예상하고 구현해야합니다 ([**참고**](https://sshoreng.tistory.com/80?category=712983))
- 싱글스레드와 멀티스레드의 효율성을 비교하면? 단순히 CPU만을 사용하는 계산작업이 주로 일어나는 경우 멀티 스레드보다 오히려 싱글 스레드를 이용하는 것이 효율적이다 멀티 스레드는 context switching이 일어나는 시간이 추가로 걸리기 때문이다 CPU 이외의 자원을 사용하는 작업의 경우 싱글 스레드보다 멀티 스레드로 하는 것이 효율적이다 예를 들어 사용자에게 입력받는 작업과 출력하는 작업 두 가지를 해야한다면, 싱글 스레드의 경우 사용자가 입력을 다할 때 까지 출력은 하지 못하고 기다리고만 있어야 한다 하지만 여러개의 쓰레드를 이용한다면 사용자가 입력하는 걸 기다리는 동안 출력이라는 작업으로 context switching 하여 해당 작업을 수행할 수 있으므로 좀 더 효율적으로 동작하게 된다 ([**참고**](https://excited-hyun.tistory.com/255))
- 임계 영역(크리티컬 섹션)의 두가지 의미에 대해서 설명하면? (1) 둘 이상의 쓰레드가 동시에 실행될 경우 접근 문제를 발생시킬 수 있는 코드 블록을 임계 영역이라고 한다 (2) 임계 영역에 대한 문제를 해결하는 동기화 기법을 의미하기도 한다, 특정 임계 영역에 대한 키를 가져야만 해당 영역에 접근할 수 있도록 하는 기법이다 ([**참고**](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=cmw1728&logNo=220479810666))
- 멀티 쓰레드란? 하나의 프로세스 내에서 둘 이상의 스레드가 동시에 작업을 수행하는 것을 의미합니다 ([**참고**](http://www.tcpschool.com/java/java_thread_multi))
- 힙영역에 대해 설명하면? 힙영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제되는 영역입니다 ([**참고**](https://velog.io/@tonic523/%ED%9E%99-%EC%98%81%EC%97%AD-vs-%EC%8A%A4%ED%83%9D-%EC%98%81%EC%97%AD))
- 스택영역에 대해 설명하면? 스택영역은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역입니다 ([**참고**](https://velog.io/@tonic523/%ED%9E%99-%EC%98%81%EC%97%AD-vs-%EC%8A%A4%ED%83%9D-%EC%98%81%EC%97%AD))
- 크리티컬 섹션과 뮤텍스의 차이는? 크리티컬 섹션은 한 프로세스 내의 쓰레드 사이에서만 동기화가 가능한 반면, 뮤텍스는 여러 프로세스의 스레드 사이에서 동기화가 가능하다 뮤텍스를 가장 흔히 사용하는 예가 프로세스 다중 실행을 막을 때이다 ([**참고**](https://genesis8.tistory.com/154))
- 캐시에 대해 설명하면? 데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치의 속도 차이에 따른 병목 현상을 줄이기 위한 메모리를 말한다 ([**참고**](https://gyoogle.dev/blog/computer-science/computer-architecture/%EC%BA%90%EC%8B%9C%20%EB%A9%94%EB%AA%A8%EB%A6%AC.html))
- 시간적 지역성과 공간적 지역성에 대해 설명하면? 시간적 지역성은 최근 액세스 된 기억 장소가 가까운 미래에 다시 액세스 될 가능성 높다는 의미이다 공간적 지역성은 액세스된 기억장소와 인접한 기억장소가 액세스될 가능성 높다는 의미이다 ([**참고**](http://blog.skby.net/%EC%A7%80%EC%97%AD%EC%84%B1-locality/))
- data영역과 bss영역을 구분하는 이유는? 초기화되지 않은 변수는 프로그램이 실행될 때 영역만 잡아주면 되고 그 값을 프로그램에 저장하고 있을 필요는 없으나(bss 영역) 초기화가 되는 변수는 그 값도 프로그램에 저장하고 있어야 하기 때문이다(data 영역) ([**참고**](https://velog.io/@tkddn2075/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84))
- Heap Overflow와 Stack Overflow에 대해 설명하면? Heap Overflow는 heap이 위에서부터 주소값을 채우며 내려오다가 stack영역을 침범하는 경우이다 Stack Overflow는 밑에서 부터 주소값을 채우며 올라가다가 heap 영역을 침범하는 경우이다 ([**참고**](https://namoeye.tistory.com/entry/%EB%A9%B4%EC%A0%91%EB%8C%80%EB%B9%84-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC))
- 스택을 스레드마다 독립적으로 할당하는 이유는? 스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가되는 것이다 따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당한다 ([**참고**](https://jungeun960.tistory.com/100))
- 스레드가 프로세스보다 콘텍스트 스위칭이 빠른 이유는? 스레드는 콘텍스트 스위칭될 때 스택(Stack)을 제외한 코드(Code), 데이터(Data), 힙(Heap) 영역은 프로세스의 것이기 때문에 자신의 TCB에는 스택 및 간단한 정보만 저장해서 프로세스 콘텍스트 스위칭보다 빠르다 반면에 프로세스는 공유하는 데이터가 없으므로 임시 저장소인 캐시 메모리가 지금껏 쌓아놓은 데이터들을 지우고 새로 데이터를 쌓아야 한다 ([**참고**](https://beststar-1.tistory.com/26#%EC%8A%A4%EB%A0%88%EB%93%9C%EC%99%80_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%A4%91_%EC%BD%98%ED%85%8D%EC%8A%A4%ED%8A%B8_%EC%8A%A4%EC%9C%84%EC%B9%AD%EC%9D%B4_%EB%B9%A0%EB%A5%B8_%EA%B2%83%EC%9D%80?_-_%EC%8A%A4%EB%A0%88%EB%93%9C)), ([**참고**](https://vicente-blog.com/blog/68/))
- 동기화란 무엇인가? 프로세스 또는 스레드들이 수행되는 시점을 조절하여 서로가 알고 있는 정보가 일치하는 것을 의미합니다 ([**참고**](https://ooeunz.tistory.com/94))
- 유저모드 동기화 커널모드 동기화에 대해서 설명하면? 유저모드 동기화란 커널의 힘을 빌리지 않는(커널 코드가 실행되지 않는) 동기화 기법 이며 크리티컬 섹션 기반 동기화와 인터락 함수 기반 동기화가 있다 커널 모드 동기화는 커널에서 제공하는 동기화 기능을 활용하는 방법이며 뮤텍스 기반의 동기화, 세마포어 기반의 동기화가 있다 ([**참고**](https://namoeye.tistory.com/entry/%EB%A9%B4%EC%A0%91%EB%8C%80%EB%B9%84-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC))
- 스핀락이란? 스핀락(spinlock)은 임계 구역(critical section)에 진입이 불가능할 때 진입이 가능할 때까지 루프를 돌면서 재시도하는 방식으로 구현된 락을 가리킨다 ([**참고**](https://ko.wikipedia.org/wiki/%EC%8A%A4%ED%95%80%EB%9D%BD))
- 인터럽트란 무엇인가? 프로그램을 실행하는 도중에 예기치 않은 상황이 발생한 경우, 현재 실행중인 작업을 즉시 중단하고, 발생된 상황을 우선 처리한 후 실행중이던 작업으로 복귀하여 계속 처리하는 것이다 ([**참고**](https://luv-n-interest.tistory.com/1168))
- C/C++ free/delete 없이 프로그램을 종료한다면? 현대의 Operating System은 Process 종료 시 Process가 사용중인 메모리를 모두 자동으로 반환 시킨다 ([**참고**](https://yhwanp.github.io/2019/12/14/c-delete-free-when-process-exit/))
- CPU와 GPU의 차이는? 기존의 CPU가 순차적인 처리 방식에 특화되어 있었다면, GPU는 병렬적인(Parallel) 처리 방식에 특화되어 있으며 이로 인해 반복적이고 비슷한 대량의 연산을 수행하는 데에 있어서 속도가 빠릅니다 GPU는 작은 여러개의 코어로 구성된 프로세서입니다 여러 개의 코어가 함께 작동하므로, 여러 코어로 나누어 처리할 수 있는 작업의 경우 GPU가 엄청난 성능 이점을 제공합니다 기존의 CPU가 6-8개의 코어로 구성되어 있다면, GPU는 어떤 GPU인가에 따라 많이 상이하지만 적게는 수백개에서 많게는 수천개의 코어로 구성되어 있습니다 ([**참고**](https://velog.io/@euisuk-chung/CPU%EC%99%80-GPU))
- 멀티스레드에서 발생할 수 있는 두가지 문제는? 동기화 문제와 데드락 문제가 발생할 수 있다 동기화 문제는 크리티컬 섹션 혹은 뮤텍스로 해결할 수 있고 데드락 문제는 중첩된 Lock을 사용하는것을 피하거나 한 쓰레드에 우선권을 주는 방법으로 해결할 수 있다 데드락 문제를 해결하기 위해 다른 방법으로는 스레드가 자원을 요청할 때 타임아웃(Time-out) 값을 설정하는 방법이 있다 이 방법은 자원을 점유하고 있는 스레드가 다른 스레드에게 자원을 양보하지 않으면, 일정 시간이 지난 후 자동으로 자원을 반납하도록 하는 방법이다 또한, 데드락이 발생한 경우에는 데드락 탐지 알고리즘을 사용하여 데드락이 발생했음을 감지하고, 해당 스레드나 자원을 해제하여 문제를 해결할 수 있습니다 ([**참고**](https://junstar92.tistory.com/184)), ([**참고**](https://modoocode.com/270)), ([**참고**](https://www.ikpil.com/1348)), ([**참고**](https://kukuta.tistory.com/282))

### 01-6 언리얼 엔진 ( 중요도 중 )
- Pawn에 대해 설명하면? Pawn은 플레이어 컨트롤러에게 조정당하는 Actor이다 ([**참고**](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=tmddls90&logNo=221950517033))

### 01-7 네트워크 ( 중요도 하 )
- 소켓 프로그래밍이란 무엇인가? 보통 OSI 7 Layer(Open System Interconnection 7 Layer)의 네 번째 계층인 TCP(Transport Control Protocol) 상에서 동작하는 소켓을 주로 사용하는데, 이를 "TCP 소켓" 또는 "TCP/IP 소켓"이라고 부른며 이를 기반으로 네트워크 통신 기능을 프로그래밍 하는 것 입니다 ([**참고**](https://tyrionlife.tistory.com/781))
- HTTP, TCP, UDP에 대해 설명하면? HTTP는 클라이언트와 서버 간 데이터를 주고 받기 위한 규칙(프로토콜)이다 여기서 데이터는 텍스트, 이미지, 동영상 등 모든 종류를 말한다 HTTP 종류에는 TCP 와 UDP 방식이 있으며 80번 포트를 사용한다 TCP는 1:1 연결을 지향하며 신뢰할 수 있는 통신을 제공한다, 여기서 1:1은 각각 클라이언트와 서버를 의미한다, 양 단에 연결을 수립한 뒤 데이터를 전송한다 UDP는 1:1 혹은 1:N 비연결을 지향하며 신뢰할 수 없는 통신을 제공한다, 여기서 '비연결' 이라는 말은 말 그대로 서버와 클라이언트가 연결되어 있지 않다는 뜻이다, TCP 와 달리 연결 설정 과정이 필요 없고 단지 소켓의 생성과 데이터 송수신 과정만 존재한다 ([**참고**](https://doozi0316.tistory.com/entry/HTTPHTTPS%EB%9E%80-TCP-UDP-HandShake-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC))
- TCP와 UDP의 차이에 대해 설명하면? TCP는 전송 순서를 보장하며 가상 회선 방식을 사용하고 연결형 서비스이며 1:1 통신만 가능하다 UDP는 전송 순서를 보장하지 않으며 데이터그램 방식을 사용하고 비 연결형 서비스이며 N:N 통신이 가능하다 ([**참고**](https://coding-factory.tistory.com/614))
- TCP의 Nagle 알고리즘에 대해 설명하면? 네트워크 전송 횟수는 줄이고 작은 데이터를 여러번 전송하기보단 데이터를 묶어서 한 번에 보내는 방식을 사용한다 ([**참고**](https://devjh.tistory.com/106))
- 3-way handshake 과정에서 통신이 안되면 어떤일이 벌어질지 설명하면? 타임아웃(Timeout)이 발생하고, 해당 네트워크는 연결되지 않는 것으로 처리한다 ([**참고**](https://hyoje420.tistory.com/4))
- 4-way handshake(종료과정)을 설명하면? (1) 먼저 통신을 종료하고자 하는 클라이언트는 서버에게 FIN 플래그를 세팅한 패킷을 보내고 자신은 FIN_WAIT_1 상태가 된다 (2) FIN 을 수신한 서버는 ACK를 클라이언트에게 전송하고 소켓의 상태를 CLOSE_WAIT로 변경한다 (3) ACK를 수신한 클라이언트는 서버가 FIN을 잘 받았다고 판단하고 FIN_WAIT_2로 소켓의 상태를 변경한 뒤 다시 FIN 패킷을 기다린다 (4) 잠시뒤 서버는 FIN 패킷을 클라이언트로 전송하고 소켓을 LAST_ACK 상태로 변경한다 (5) FIN을 수신한 클라이언트는 서버에게 ACK를 전송한 뒤 소켓의 상태를 TIME_WAIT 상태로 변경한다 (6) 클라이언트로부터 마지막 ACK를 수신한 서버는 소켓을 CLOSED 한다 ([**참고**](https://blogger.pe.kr/390))
- checksum에 대해 설명하면? 네트워크를 통해 전달된 값이 변경되었는지를 검사하는 값으로 무결성을 제공한다 TCP는 checksum이 필수이고 udp는 선택이다 ([**참고**](https://galid1.tistory.com/310)), ([**참고**](https://poododang.tistory.com/entry/TCPUDP))
- TCP/IP란 무엇인가? TCP/IP(Transmission Control Protocol/Internet Protocol)는 데이터가 의도된 목적지에 도착할 수 있도록 보장해주는 통신 규약입니다 ([**참고**](https://coding-factory.tistory.com/613))
- TCP Flag 종류에 대해 설명하면? SYN(연결 요청 플래그) ACK(응답 플래그) FIN(연결 종료 플래그) 등이 있다 ([**참고**](https://hongpossible.tistory.com/entry/TCP-Flag%EB%9E%80))
- OSI 7계층을 왜 나눴는지 설명하면? 통신이 일어나는 과정을 단계 별로 파악할 수 있기 때문이다 사람들이 이해하기 쉽고, 흐름을 한 눈에 알아보기 쉽고, 7단계 중 특정한 곳에 이상이 생기면 해당 단계만 고칠 수 있다 ([**참고**](https://steady-coding.tistory.com/504))
- http와 https의 차이에 대해 설명하면? HTTP는 암호화가 추가되지 않았기 때문에 보안에 취약한 반면, HTTPS는 암호화가 추가되기 때문에 안전하게 데이터를 주고받을 수 있다 하지만 HTTPS를 이용하면 암호화/복호화의 과정이 필요하기 때문에 HTTP보다 속도가 느리다 ([**참고**](https://mangkyu.tistory.com/98))
- OSI 7계층에 대해 설명하면? 1계층 - 물리계층(Physical Layer), 인터넷 케이블, 라우터 스위치 등의 전기적 신호가 물리적인 장치에 의해 왔다 갔다(통신) 하는 계층이다 2계층 - 데이터 링크계층(DataLink Layer), 물리계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 안전한 정보의 전달을 수행할 수 있도록 도와주는 역할을 한다 3계층 - 네트워크 계층(Network Layer), 경로를 선택하고 주소를 정하고 경로에 따라 패킷을 전달해주는 것이 이 계층의 주 역할이다 4계층 - 전송 계층(Transport Layer), 이 계층은 통신을 활성화하기 위한 계층이며 보통 TCP 프로토콜을 이용하며, 포트를 열어서 응용프로그램들이 전송을 할 수 있게 한다 5계층 - 세션 계층(Session Layer), 양 끝단의 응용 프로세스가 통신을 관리하는 방법을 제공하는 계층이다 6계층 - 표현 계층(Presentation Layer), 코드 간 번역을 담당하는 계층이다 7계층 - 응용 계층(Application Layer), 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행하는 계층이다 ([**참고**](https://onecoin-life.com/19))
- 3-way handshake 과정에 대해 설명하면? (1) 클라이언트는 서버와 커넥션을 연결하기 위해 SYN을 보낸다 (2) 서버가 SYN을 받고, 클라이언트로 받았다는 신호인 ACK와 SYN 패킷을 보냄 (3) 클라이언트는 서버의 응답인 ACK와 SYN 패킷을 받고, ACK를 서버로 보냄 ([**참고**](https://velog.io/@averycode/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-TCPUDP%EC%99%80-3-Way-Handshake4-Way-Handshake))
- HTTP 프로토콜이란? 서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜입니다 ([**참고**](https://mangkyu.tistory.com/91))
- 라우터와 스위치의 차이는? 스위치는 데이터 링크 계층에, 라우터는 네트워크 계층에 속한다 그래서 스위치는 MAC 주소를 기반으로 작동하고, 라우터는 IP주소를 기반으로 작동한다 ( 내 블로그 참고 )
- DNS란? 국제적 단위로 웹사이트의 IP 주소와 도메인 주소를 이어주는 환경/시스템이다 ([**참고**](https://gentlysallim.com/dns%EB%9E%80-%EB%AD%90%EA%B3%A0-%EB%84%A4%EC%9E%84%EC%84%9C%EB%B2%84%EB%9E%80-%EB%AD%94%EC%A7%80-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC/))
- LAN이란? Local Area Network의 줄인 말로 근거리 통신망입니다 ([**참고**](https://enlqn1010.tistory.com/13))
- WAN이란? Wide  Area Network의 줄인 말로 LAN보다 범위가 넓은 광대역 통신망입니다 ([**참고**](https://enlqn1010.tistory.com/13))
- 4-way handshake(종료과정)에서 TIME_WAIT 과정이 필요한 이유는? IP 프로토콜은 순서를 보장하지 않기 때문에 포트를 못쓰게 잠궈두는 상태인 TIME_WAIT가 필요하다 ([**참고**](https://popcorntree.tistory.com/112))
- 가상회선 방식과 데이터그램 방식의 차이는? 데이터그램 방식은 패킷마다 라우터가 경로를 선택하지만, 가상회선 방식은 경로를 설정할 때 한 번만 수행한다 ([**참고**](https://gotwo.tistory.com/107))

### 01-8 데이터 베이스 ( 중요도 하 )
- JOIN의 정의에 대해 설명하면? 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것을 말한다 ([**참고**](https://sparkdia.tistory.com/17))
- JOIN의 종류에 대해 설명하면? Inner join은 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기한다, Left outer join은 왼쪽 테이블의 모든 행이 결과 테이블에 표기된다, Right outer join은 오른쪽 테이블의 모든 행이 결과 테이블에 표기된다, Full outer join은 양쪽 테이블에 공통적으로 존재하는 데이터와 한쪽 테이블에만 존재하는 데이터도 모두 결과 테이블에 표기된다 ([**참고**](https://sparkdia.tistory.com/17))
- DB Index의 정의와 사용하는 이유를 설명하면? 인덱스는 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료구조이다 ([**참고**](https://rebro.kr/167))
- DB Index의 자료구조중 B-Tree 구조를 설명하면? Root(기준) / Branch(중간) / Leaf(말단) Node로 구성되며 균형잡힌 트리이다 ([**참고**](https://junhyunny.github.io/information/data-structure/db-index-data-structure/))
- 클러스터링 인덱스에 대해 설명하면? 연속된 키 값의 레코드를 묶어서 같은 블록에 저장하는 방법이다 ([**참고**](https://ltk3934.tistory.com/106)), ([**참고**](https://dev-ppyong.tistory.com/11)), ([**참고**](https://enterone.tistory.com/230))
- 넌클러스터링 인덱스에 대해 설명하면? 인덱스의 리프노드에 실제 데이터 값이 아닌 테이블상의 데이터 위치를 지정하는 포인터를 저장한다 ([**참고**](https://ltk3934.tistory.com/106))
- 클러스터링 인덱스와 넌클러스터링 인덱스의 차이점는? 클러스터드 인덱스는 물리적으로 행을 재배열하고, 넌클러스터드 인덱스는 물리적으로 행을 재배열 하지 않는다 ([**참고**](https://m.blog.naver.com/islove8587/220431192221))
- DB collision에 대해 설명하고 해결방법을 제시하면? Collision(충돌 현상)은 서로 다른 두 개 이상의 레코드가 같은 주소를 갖는 현상이다 해결법에는 개방 주소법(Open Addressing)이 있다 ([**참고**](https://developer-rooney.tistory.com/67))
- DB Isolation에 대해 설명하면? 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다 ([**참고**](https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation))
- Nosql과 RDBMS의 차이는? RDBMS는 정해진 스키마에 따라 데이터를 저장하여야 하므로 명확한 데이터 구조를 보장한다 NoSQL은 스키마가 없기 때문에 유연하며 자유로운 데이터 구조를 가질 수 있다 ([**참고**](https://pythontoomuchinformation.tistory.com/528))
- 정규화 개념과 각 단계를 설명하면? 관계형 데이터베이스에서 중복을 최소화하게 데이터를 구조화하는 프로세스를 정규화(Normalization)라고 한다 제1 정규화란 테이블의 컬럼이 원자값(Atomic Value, 하나의 값)을 갖도록 테이블을 분해하는 것이다 제2 정규화란 제1 정규화를 진행한 테이블에 에서 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속을 만족하도록 테이블을 분해하는 것이다 제3 정규화란 제2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것이다 BCNF 정규화란 제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것이다 ([**참고**](https://mangkyu.tistory.com/110))
- 비관적 락과 낙관적 락에 대해 설명하면? 비관적 락은 자원 요청에 따른 동시성문제가 발생할것이라고 예상하고 락을 걸어버리는 방법론입니다 낙관적 락은 자원에 락을 걸어서 선점하지말고, 동시성 문제가 발생하면 그때 가서 처리 하자는 방법론입니다 ([**참고**](https://unluckyjung.github.io/db/2022/03/07/Optimistic-vs-Pessimistic-Lock/))
- 데이터베이스를 사용하는 이유? 데이터를 파일 단위로 저장하면 데이터 무결성 문제, 종속성 문제, 중복성 문제 등이 존재하기 때문에 데이터베이스로 관리하기 시작했다 ([**참고**](https://dar0m.tistory.com/245))
- 데이터베이스 처리능력의 정의와 계산하는 방법을 설명하면? 처리 능력은 해당 작업을 수행하기 위해서 소요되는 시간이다 계산 방법은 트랜잭션 수 / 시간 ([**참고**](https://m.blog.naver.com/roser111/221660535634))
- DB Index에 적합한 자료구조는? 해시 테이블, B-Tree, B+Tree ([**참고**](https://junhyunny.github.io/information/data-structure/db-index-data-structure/))
- 기본 인덱스(primary index)와 보조 인덱스(secondary index)의 차이점은? 기본 인덱스는 데이터 블록 안의 행들의 조직에 영향을 미친다 보조 인덱스는 데이터 블록에서 실제로 조직화된 행들에 전혀 영향을 미치지 않는다 ([**참고**](https://m.blog.naver.com/remocon33/221037713789))
- Composite index란? 인덱스를 생성할 때 두 개 이상의 컬럼(속성)을 합쳐서 인덱스를 만드는 것을 말합니다 ([**참고**](https://jhkang-tech.tistory.com/210))
- Index 의 성능과 고려해야할 사항은? 데이터의 형식에 따라 인덱스를 만들면 효율적이고 만들면 비효율적은 데이터의 형식이 존재한다 ([**참고**](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database))
- 정규화는 어떤 배경에서 생겨났는가? 한 릴레이션(테이블)에 여러 엔티티의 애트리뷰트들을 혼합하게 되면 정보가 중복 저장되며, 저장 공간을 낭비하게 된다 또 중복된 정보로 인해 갱신 이상이 발생하게 된다 동일한 정보를 한 릴레이션에는 변경하고, 나머지 릴레이션에서는 변경하지 않은 경우 어느 것이 정확한지 알 수 없게 되는 것이다 이러한 문제를 해결하기 위해 정규화 과정을 거치는 것이다 ([**참고**](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database))
- 정규화란 무엇인가? 관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업이다 ([**참고**](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database))
- 정규화의 장점과 단점은? 장점은 데이터베이스 변경 시 이상 현상(Anomaly)을 제거한다 단점은 릴레이션(테이블)의 분해로 인해 릴레이션(테이블) 간의 연산(JOIN 연산)이 많아진다 ([**참고**](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database))
- 트랜잭션(Transaction)이란 무엇인가? 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위를 말한다 ([**참고**](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database))
- 트랜잭션과 Lock의 차이는? Lock은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다 ([**참고**](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database))
- 트랜잭션의 특성은? 원자성, 고립성, 지속성, 일관성을 만족 해야한다 ([**참고**](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database))
- 트랜잭션을 사용할 때 주의할 점은? 트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다 즉 트랜잭션의 범위를 최소화하라는 의미다 ([**참고**](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database)), ([**참고**](https://jwkim96.tistory.com/264))
- 교착상태란 무엇인가? 복수의 트랜잭션을 사용하다보면 교착상태가 일어날수 있다 교착상태란 두 개 이상의 트랜잭션이 특정 자원(테이블 또는 행)의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금(Lock)을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태가 되는데, 이를 교착상태라고 한다 ([**참고**](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database))
- 쿼리문 실행 단계를 설명하면? (1) 쿼리 문장 분석 (2) 컴파일 (3) 실행 ([**참고**](https://devbox.tistory.com/entry/Comporison))
- Statement와 PreparedStatement 중에 어느 것이 더 좋은가? Statement를 사용하면 매번 쿼리 실행 단계를 거치게 되고, PreparedStatement는 처음 한 번만 쿼리 실행 단계를 거친 후 캐시에 담아 재사용을 한다 만약 동일한 쿼리를 반복적으로 수행된다면 PreparedStatment가 DB에 훨씬 적은 부하를 주며, 성능도 좋다 ([**참고**](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database))
- NoSQL의 정의는? 관계형 데이터 모델을 지양 하며 대량의 분산된 데이터를 저장하고 조회하는 데 특화되었으며 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소를 말한다 ([**참고**](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database))
- CAP 이론이란? Network로 연결된 분산된 데이터베이스 시스템은 일관성(Consistency), 가용성(Availability), 분할 허용성(Partition Tolerance)의 3가지 특성중 2가지 특성만을 충족 할수 있고 3가지 모두 충족할 수 없다는 이론입니다 ([**참고**](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database))
- CAP 이론에서 일관성 이란? 다중 클라이언트에서 같은 시간에 조회하는 데이터는 항상 동일한 데이터임을 보증하는 것을 의미한다 ([**참고**](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database))
- CAP 이론에서 가용성 이란? 모든 클라이언트의 읽기와 쓰기 요청에 대하여 항상 응답이 가능해야 함을 보증하는 것이다 ([**참고**](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database))
- CAP 이론에서 분할 허용성 이란? 지역적으로 분할된 네트워크 환경에서 동작하는 시스템에서 두 지역 간의 네트워크가 단절되거나 네트워크 데이터의 유실이 일어나더라도 각 지역 내의 시스템은 정상적으로 동작해야 함을 의미한다 ([**참고**](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database))
- 저장 방식에 따른 NoSQL 분류중 Key-Value Model에 대해 설명하면? 가장 기본적인 형태의 NoSQL 이며 키 하나로 데이터 하나를 저장하고 조회할 수 있는 단일 키-값 구조를 갖는다 ([**참고**](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database))
- 저장 방식에 따른 NoSQL 분류중 Document Model에 대해 설명하면? 키-값 모델을 개념적으로 확장한 구조로 하나의 키에 하나의 구조화된 문서를 저장하고 조회한다 ([**참고**](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database))
- 저장 방식에 따른 NoSQL 분류중 Column Model에 대해 설명하면? 하나의 키에 여러 개의 컬럼 이름과 컬럼 값의 쌍으로 이루어진 데이터를 저장하고 조회한다 ([**참고**](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database))

### 01-9 디자인 패턴 ( 중요도 하 )
- 디자인 패턴이란? 자주 사용하는 설계 형태를 정형화해서 형식을 만들어 두는 것 입니다 ([**참고**](https://sshoreng.tistory.com/112?category=712983))
- 전략 패턴에 대해 설명하면? 여러 알고리즘을 하나의 추상적인 접근점(인터페이스)을 만들어 접근점에서 알고리즘이 서로 교환 가능하도록 하는 패턴이다 요구사항이 변경되었을 때 기존의 코드를 변경하지 않아도 된다는 것이 전략패턴의 장점이다 클래스가 많이 늘어날 수 있다는 것이 단점이다 ([**참고**](https://3dpit.tistory.com/671))
- 어댑터 패턴에 대해 설명하면? 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴이다 새로운 기능의 추가가 편리한 것이 장점이다 다른 구성요소에 대한 메소드 호출을 처리하기 위해 Wrapper 클래스를 더 만들어야 할 수도 있다는 것이 단점이다 ([**참고**](https://conpulake.tistory.com/254)), ([**참고**](https://lalwr.blogspot.com/2016/03/adapter-vs-facade-vs-decorator.html))
- 싱글톤 패턴에 대해 설명하면? 오직 한 개의 클래스 인스턴스만 갖도록 보장할 수 있고 전역 접근점을 제공하는 패턴이다 한번도 사용하지 않는다면 인스턴스를 생성하지 않는다는 장점이다 커플링을 조장할 수 있다는 것이 단점이다 ([**참고**](https://junwe99.tistory.com/15))
- 프로토 타입 패턴에 대해 설명하면? 원형이 되는 인스턴스로 새로운 인스턴스를 만드는 패턴이다 프로토타입이 미리 정의되어 있기 때문에 중복되는 초기화 코드를 제거할 수 있는 것이 장점이다 순환 참조가 있는 객체를 복제하는 것은 매우 까다로울 수 있다는 것이 단점이다 ([**참고**](https://keencho.github.io/posts/prototype-pattern/))
- 추상 팩토리 패턴에 대해 설명하면? 관련성 있는 여러 종류의 객체를 일관된 방식으로 생성할 수 있도록 하는 패턴이다 구체적인 구현 클래스를 분리할 수 있는 것이 장점이다 새로운 분류를 추가하기 어려운 것이 단점이다 ([**참고**](https://devowen.com/326))
- 방문자 패턴에 대해 설명하면? 로직과 구조를 분리하는 패턴이다 데이터와 알고리즘이 분리되어, 데이터의 독립성을 높여주는 것이 장점이다 두 객체(방문자와 방문 공간)의 결합도가 높아지는 것이 단점이다 ([**참고**](https://velog.io/@cham/Design-Pattern-%EB%B0%A9%EB%AC%B8%EC%9E%90-%ED%8C%A8%ED%84%B4-Visitor-pattern))
- 중재자 패턴에 대해 설명하면? 클래스간의 복잡한 로직(상호작용)을 캡슐화하여 하나의 클래스에 위임해 처리하는 패턴이다 객체간의 통신을 위해 서로간에 직접 참조할 필요가 없는 것이 장점이다 중재자 객체에 권한이 집중화되어 굉장히 크고 복잡해지는 것이 단점이다 ([**참고**](https://velog.io/@cham/Design-Pattern-%EC%A4%91%EC%9E%AC%EC%9E%90-%ED%8C%A8%ED%84%B4Mediator-Pattern))
- 스테이트 패턴에 대해 설명하면? 객체 내부의 상태가 바뀜에 따라 객체의 행동을 바꿀 수 있는 패턴이다 메서드 상의 긴 분기문들을 제거할 수 있는것이 장점이다 클래스 갯수가 많아져서 유지보수가 힘들어질 가능성이 존재하는 것이 단점이다 ([**참고**](https://kscory.com/dev/design-pattern/state))
- 컴포넌트 패턴에 대해 설명하면? 한 객체가 여러 분야를 서로 커플링(결합도) 없이 다룰 수 있게 하는 패턴이다 컴포넌트끼리 서로 디커플링 상태를 유지한다는 것이 장점이다 한 무리의 객체를 생성하고 초기화하고 알맞게 묶어줘야 하나의 객체라는 개념을 만들 수 있기 때문에 코드가 복잡해 질 수 있다는 것이 단점이다 ([**참고**](https://boycoding.tistory.com/118)), ([**참고**](https://tsyang.tistory.com/85))

<br>

## 참고한 블로그 주소들

### 목록
- https://github.com/jobhope/TechnicalNote/blob/master/InterviewQuestions.md
- https://github.com/JaeYeopHan/Interview_Question_for_Beginner
- https://woo-dev.tistory.com/163
- https://iwannabethesenior.blogspot.com/2019/10/blog-post.html
- https://m.blog.naver.com/nds888/221380832707
- https://github.com/gyoogle/tech-interview-for-developer
- https://cclient.tistory.com/m/category/pinko/career
- https://hmjo.tistory.com/264
- https://makefortune2.tistory.com/category/Computer%20Science/C%2B%2B
- https://velog.io/@kkanyo/%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-C-%EC%9A%94%EC%95%BD-%EC%A0%95%EB%A6%AC-%EA%B3%84%EC%86%8D-%EC%88%98%EC%A0%95
- https://se-jung-h.tistory.com/entry/C-C-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8
- https://91ms.tistory.com/category/%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91
- https://sshoreng.tistory.com/80?category=712983
- https://geekhub.tistory.com/category/%EB%A9%B4%EC%A0%91%20%EC%A4%80%EB%B9%84
- https://uncertainty-momo.tistory.com/46
- https://hakyoug.tistory.com/73
- https://sb-story.tistory.com/2
- https://throwbug.com/80/%EB%A9%B4%EC%A0%91%EB%95%8C-%EC%96%B4%EB%96%A4%EA%B1%B0-%EB%AC%BC%EC%96%B4%EB%B3%B4%EB%8A%94%EC%A7%80-%EA%B3%B5%EC%9C%A0%ED%95%B4%EB%B3%B4%EC%95%84%EC%9A%94
- http://www.gamejob.co.kr/Community/Talk/Detail?talk_Stat=13&idx=9149
- https://namoeye.tistory.com/entry/%EB%A9%B4%EC%A0%91%EB%8C%80%EB%B9%84-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC?category=678025
- http://kingpark0304.blogspot.com/2014/11/blog-post.html
- https://velog.io/@mardi2020/C-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC
- https://j2hworld.tistory.com/55
- https://luv-n-interest.tistory.com/1168

<br>

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}