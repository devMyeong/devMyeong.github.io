---
title:  "ê²Œì„ ìˆ˜í•™ê³¼ DirectX12 ( Unreal Engine 5.2 )"

categories:
  - DirectX 12
tags:
  - []

comments: true

toc: true
toc_sticky: true

date: 2024-05-10
last_modified_at: 2024-05-10
---

## Chapter 1 DirectX12 ì´ˆê¸°í™”

### 01-1 í”„ë¡œì íŠ¸ ì„¤ì •
- ë Œë”ë§ íŒŒì´í”„ë¼ì¸, Diffuse, Ambient, Specular, Double Buffering, Tangent Space, ê·¸ë¦¼ì ì›ë¦¬, ì§ë²Œë½ í˜„ìƒ, ì¿¼í„°ë‹ˆì–¸ì´ ì¤‘ìš”í•˜ë‹¤
- CPUì™€ GPUì˜ ê°€ì¥í° ì°¨ì´ëŠ”? ALU ê°œìˆ˜

```cpp
// LaunchWindows.cpp

int32 WINAPI WinMain(_In_ HINSTANCE hInInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ char* pCmdLine, _In_ int32 nCmdShow)
{
	// ì—¬ê¸°ê°€ ì–¸ë¦¬ì–¼ì´ ì‹œì‘ë˜ëŠ” ë¶€ë¶„ì´ë‹¤
	int32 Result = LaunchWindowsStartup(hInInstance, hPrevInstance, pCmdLine, nCmdShow, nullptr);
}
```

```cpp
// Launch.cpp

int32 GuardedMain( const TCHAR* CmdLine )
{
	#if WITH_EDITOR
	if (GIsEditor)
	{
		// ì´ ì•ˆì—ì„œ ì—”ì§„ì„ ì…‹ì—…í•œë‹¤ ( ì†”ë£¨ì…˜ êµ¬ì„±ì—ì„œ Editor ëª¨ë“œë¥¼ ì„ íƒí•˜ë©´ ì´ê³³ì´ í˜¸ì¶œëœë‹¤ )
		ErrorLevel = EditorInit(GEngineLoop);
	}
	#endif
	
	if (!GUELibraryOverrideSettings.bIsEmbedded)
	{
		// ì´ ì•ˆì—ì„œ ì—”ì§„í‹±ì´ ëŒê³ ìˆë‹¤
		while( !IsEngineExitRequested() )
		{
			EngineTick();
		}
	}
}
```

```cpp
// WindowsPlatformApplicationMisc.cpp

void FWindowsPlatformApplicationMisc::PumpMessages(bool bFromMainLoop)
{
	// ì´ ì•ˆì—ì„œ PeekMessage ê°€ ì²˜ë¦¬ë˜ê³  ìˆë‹¤ ( bFromMainLoop == false )
	if (!bFromMainLoop)
	{
		FPlatformMisc::PumpMessagesOutsideMainLoop();
		return;
	}

	// ì´ ì•ˆì—ì„œ PeekMessage ê°€ ì²˜ë¦¬ë˜ê³  ìˆë‹¤ ( bFromMainLoop == true )
	GPumpingMessagesOutsideOfMainLoop = false;
	WinPumpMessages();
}
```

- ìì£¼ í™œìš©í•˜ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì¸í´ë£¨ë“œ í•˜ëŠ”ê²Œ ê·€ì°®ê¸° ë•Œë¬¸ì— ì‚¬ìš©í•˜ëŠ” í—¤ë”ëŠ”? ë¯¸ë¦¬ ì»´íŒŒì¼ëœ í—¤ë” ( 07 : 41 )
- ì–¸ë¦¬ì–¼ ì—”ì§„ì˜ pch.h íŒŒì¼ì„ ë³´ëŠ” ë°©ë²•ì€? ì†”ë£¨ì…˜ íƒìƒ‰ê¸°ì— pch.h ê²€ìƒ‰
- d3dx12.hì˜ íŠ¹ì§•ì€? ë§ˆì´í¬ë¡œì†Œí”„íŠ¸ ì—ì„œ ì œê³µí•´ì£¼ëŠ” ë¹„ê³µì‹ì ì¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ ( 27 : 30 )

![dir](https://github.com/devMyeong/devMyeong.github.io/assets/80055816/0800c9f0-153b-41fe-939b-e4eb9f040b8c){: width="100%" height="100%"}{: .align-center}

- ì¶”ê°€ ì¢…ì†ì„± ëŒ€ì‹  lib íŒŒì¼ì„ ì¶”ê°€í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì€? pragma comment í™œìš© ( 37 : 41 )

### 01-2 ì¥ì¹˜ ì´ˆê¸°í™”

```cpp
// Engine.h

/** Global engine pointer. Can be 0 so don't use without checking. */
extern ENGINE_API class UEngine*			GEngine;
```

```cpp
// WindowsApplication.cpp

int32 FWindowsApplication::ProcessMessage( HWND hwnd, uint32 msg, WPARAM wParam, LPARAM lParam )
{
	// ì´ ì•ˆì—ì„œ ìœˆë„ìš° ë©”ì‹œì§€ê°€ ì²˜ë¦¬ë˜ê³  ìˆë‹¤
	// FWindowsPlatformApplicationMisc í´ë˜ìŠ¤ì˜ WinPumpMessages() ì—ì„œ ë‚ ì•„ì˜¨ ë©”ì‹œì§€ ì´ë‹¤ ( ë‚ ì•„ì˜¤ëŠ” ì›ë¦¬ëŠ” ì½œë°± )
	// ì•„ë˜ ë©”ì‹œì§€ ì—ì„œ ì²˜ë¦¬ë˜ê³  ìˆëŠ” ìë£Œí˜• ì¤‘ì— WINDOWINFO ë¼ëŠ”ê²Œ ìˆëŠ”ë° ê·¸ë ¤ì§ˆ í™”ë©´ í¬ê¸°ì™€ ê´€ë ¨ì´ ìˆë‹¤
	switch(msg)
	{
		// ìœˆë„ìš° ì‚¬ì´ì¦ˆ ì¡°ì •í•˜ëŠ” ì´ë²¤íŠ¸
		case WM_SIZING:
	}
}
```

```cpp
// D3D12Commands.cpp

void FD3D12CommandContext::RHISetViewport(float MinX, float MinY, float MinZ, float MaxX, float MaxY, float MaxZ)
{
	// ê·¸ë ¤ì§ˆ í™”ë©´ í¬ê¸° ê´€ë ¨ ( D3D12_VIEWPORT )
	D3D12_VIEWPORT Viewport = { MinX, MinY, (MaxX - MinX), (MaxY - MinY), MinZ, MaxZ };

}

void FD3D12CommandContext::RHISetScissorRect(bool bEnable, uint32 MinX, uint32 MinY, uint32 MaxX, uint32 MaxY)
{
	if (bEnable)
	{
		// ê·¸ë ¤ì§ˆ í™”ë©´ í¬ê¸° ê´€ë ¨ ( CD3DX12_RECT )
		const CD3DX12_RECT ScissorRect(MinX, MinY, MaxX, MaxY);
		StateCache.SetScissorRect(ScissorRect);
	}
}

void FD3D12CommandContext::RHIDrawPrimitive(uint32 BaseVertexIndex, uint32 NumPrimitives, uint32 NumInstances)
{
	// ë™ì¼í•œ ì •ì  ë°ì´í„° ì§‘í•©ì„ ì—¬ëŸ¬ ì¸ìŠ¤í„´ìŠ¤ë¡œ ë Œë”ë§í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤
	// ë™ì¼í•œ ê°ì²´ë¥¼ ì—¬ëŸ¬ ë²ˆ ê·¸ë¦¬ê±°ë‚˜, ë™ì¼í•œ ë©”ì‰¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ë‹¤ì–‘í•œ ìœ„ì¹˜ë‚˜ ì†ì„±ìœ¼ë¡œ ë Œë”ë§í•  ë•Œ ìœ ìš©í•©ë‹ˆë‹¤
	// ì´ ë‹¨ê³„ë¥¼ ê±°ì¹˜ë©´ ì •ì  ì •ë³´ê°€ Input Assembler ë‹¨ê³„ë¡œ ë„˜ì–´ê°„ë‹¤
	// Vertex Bufferë§Œ í™œìš©í•´ ê·¸ë¦¬ëŠ” í•¨ìˆ˜ì´ë‹¤
	GraphicsCommandList()->DrawInstanced(VertexCount, NumInstances, BaseVertexIndex, 0);
}

void FD3D12CommandContext::RHIDrawIndexedPrimitive(FRHIBuffer* IndexBufferRHI, int32 BaseVertexIndex, uint32 FirstInstance, uint32 NumVertices, uint32 StartIndex, uint32 NumPrimitives, uint32 NumInstances)
{
	// Vertex Bufferì™€ Index Bufferë¥¼ í•¨ê»˜ í™œìš©í•´ ê·¸ë¦¬ëŠ” í•¨ìˆ˜ì´ë‹¤
	GraphicsCommandList()->DrawIndexedInstanced(IndexCount, NumInstances, StartIndex, BaseVertexIndex, FirstInstance);
}

void FD3D12CommandContext::RHIClearMRTImpl(bool* bClearColorArray, int32 NumClearColors, const FLinearColor* ClearColorArray, bool bClearDepth, float Depth, bool bClearStencil, uint32 Stencil)
{
	if (ClearDSV)
	{
		// Depth Stencil Buffer ì´ˆê¸°í™” ( D3D12_CLEAR_FLAGSë¥¼ í™œìš©í•´ Depthë§Œ ì´ˆê¸°í™” í• ê²ƒì¸ì§€, Stencilë„ ê°™ì´ ì´ˆê¸°í™” í• ê²ƒì¸ì§€ ì •í•´ì¤„ ìˆ˜ ìˆë‹¤ )
		GraphicsCommandList()->ClearDepthStencilView(DepthStencilView->GetOfflineCpuHandle(), (D3D12_CLEAR_FLAGS)ClearFlags, Depth, Stencil, ClearRectCount, pClearRects);
		UpdateResidency(DepthStencilView->GetResource());
	}
}
```

```cpp
// D3D12Adapter.h
// D3D12Adapter.cpp

class FD3D12Adapter : public FNoncopyable
{
	// ê°ì¢… ê°ì²´ ìƒì„±, D3D12CreateDevice() í•¨ìˆ˜ë¥¼ í™œìš©í•´ ì´ˆê¸°í™” í•œë‹¤
	FORCEINLINE ID3D12Device* GetD3DDevice() const { return RootDevice; }

	// í™”ë©´ ê´€ë ¨ ê¸°ëŠ¥ë“¤, CreateDXGIFactory() í•¨ìˆ˜ë¥¼ í™œìš©í•´ ì´ˆê¸°í™” í•œë‹¤
	FORCEINLINE IDXGIFactory2* GetDXGIFactory2() const { return DxgiFactory2; }
}

void FD3D12Adapter::CreateRootDevice(bool bWithDebug)
{
	// ë””ë²„ê·¸ ( IID_PPV_ARGS ë§¤í¬ë¡œëŠ” ìì£¼ ì´ìš©ëœë‹¤ )
	TRefCountPtr<ID3D12Debug> DebugController;
	if (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(DebugController.GetInitReference()))))
	{
		DebugController->EnableDebugLayer();
	}
}

void FD3D12Adapter::InitializeDevices()
{
	// 01-5 Root Signatureì— ìˆëŠ” ì´ë¯¸ì§€ì—ì„œ desc.tableì„ ì„¸íŒ…í•´ì£¼ëŠ” ì½”ë“œ
	D3D12_DESCRIPTOR_HEAP_DESC TempHeapDesc{};

	// Constant Buffer View, Shader Resource View, Unordered Access Buffer
	TempHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;

	TempHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	TempHeapDesc.NodeMask = FRHIGPUMask::All().GetNative();
	TempHeapDesc.NumDescriptors = 2 * D3D12_MAX_SHADER_VISIBLE_DESCRIPTOR_HEAP_SIZE_TIER_2;

	// DX11ì˜ RenderTargetView, DepthStencilView ë“±ë“±ì„ ì´ì œ í†µí•©ì ìœ¼ë¡œ ê´€ë¦¬í•œë‹¤ ( ID3D12DescriptorHeap )
	// ë Œë” íƒ€ê²Ÿ ì •ë³´ì¸ ID3D12Resourceë¥¼ ì§ì ‘ ì ‘ê·¼ í•˜ëŠ” ëŒ€ì‹  ID3D12DescriptorHeapë¥¼ í™œìš©í•´ ê°„ì ‘ ì ‘ê·¼ í•˜ì
	TRefCountPtr<ID3D12DescriptorHeap> TempHeap;

	// ë°°ì—´ í˜•íƒœë¡œ ê´€ë¦¬ë˜ëŠ” TempHeap.GetInitReference() ê°€ ë§Œë“¤ì–´ ì§„ë‹¤
	HRESULT hr = RootDevice->CreateDescriptorHeap(&TempHeapDesc, IID_PPV_ARGS(TempHeap.GetInitReference()));
}
```

```cpp
// D3D12Device.h
// D3D12Device.cpp

class FD3D12Queue final
{
public:
	// ì¼ê°ì„ ì°¨ê³¡ì°¨ê³¡ ê¸°ë¡í–ˆë‹¤ê°€ í•œ ë°©ì— ìš”ì²­í•˜ëŠ” ê³³
	// ID3D12CommandAllocator, ID3D12GraphicsCommandList ì™€ ì¹œêµ¬ ( ID3D12GraphicsCommandListëŠ” Close í•¨ìˆ˜ë¥¼ í™œìš©í•´ ë¬´ì—‡ì„ ì œì¶œí•œë‹¤ )
	TRefCountPtr<ID3D12CommandQueue> D3DCommandQueue;
}

void FD3D12Device::UpdateConstantBufferPageProperties()
{
	//In genera, constant buffers should use write-combine memory (i.e. upload heaps) for optimal performance
	bool bForceWriteBackConstantBuffers = false;

	if (bForceWriteBackConstantBuffers)
	{
		ConstantBufferPageProperties = GetDevice()->GetCustomHeapProperties(0, D3D12_HEAP_TYPE_UPLOAD);
		ConstantBufferPageProperties.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_WRITE_BACK;
	}
	else
	{
		//-------------------------------------------------------------------
		// D3D12_HEAP_TYPE_UPLOAD í™ í˜•ì‹ì€
		// CPU-ì“°ê¸°-í•œ ë²ˆ, GPU ì½ê¸°-í•œ ë²ˆ ë°ì´í„°ì— ê°€ì¥ ì í•©í•©ë‹ˆë‹¤ ( MSDN )
		//-------------------------------------------------------------------
		ConstantBufferPageProperties = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	}
}
```

```cpp
// D3D12Viewport.h
// D3D12Viewport.cpp

class FD3D12FramePacing : public FRunnable, public FD3D12AdapterChild
{
private:
	// CPUì™€ GPU ë™ê¸°í™”ë¥¼ ìœ„í•œ ê°„ë‹¨í•œ ë„êµ¬
	TRefCountPtr<ID3D12Fence> Fence;
}

FD3D12Texture* GetSwapChainSurface(FD3D12Device* Parent, EPixelFormat PixelFormat, uint32 SizeX, uint32 SizeY, IDXGISwapChain* SwapChain, uint32 BackBufferIndex, TRefCountPtr<ID3D12Resource> BackBufferResourceOverride)
{
	// Grab the back buffer
	TRefCountPtr<ID3D12Resource> BackBufferResource;
	if (SwapChain)
	{
#if D3D12_VIEWPORT_EXPOSES_SWAP_CHAIN
		// ì—¬ê¸°ì„œ ë Œë” íƒ€ê²Ÿ(Back Buffer)ê³¼ ìŠ¤ì™‘ì²´ì¸ì´ ì—°ë™ëœë‹¤
		VERIFYD3D12RESULT_EX(SwapChain->GetBuffer(BackBufferIndex, IID_PPV_ARGS(BackBufferResource.GetInitReference())), Parent->GetDevice());
#else // #if D3D12_VIEWPORT_EXPOSES_SWAP_CHAIN
	}
	else
	{
		// D3D12_HEAP_TYPE_DEFAULT í™ í˜•ì‹ì€ GPUì˜ ëŒ€ì—­í­ì„ ê°€ì¥ ë§ì´ ì‚¬ìš©í•˜ì§€ë§Œ
		// CPU ì•¡ì„¸ìŠ¤ë¥¼ ì œê³µí•  ìˆ˜ëŠ” ì—†ìŠµë‹ˆë‹¤ GPUëŠ” ì´ í’€ì—ì„œ ë©”ëª¨ë¦¬ë¥¼ ì½ê³  ì“¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤ ( MSDN )
		const D3D12_HEAP_PROPERTIES HeapProps = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT, (uint32)Parent->GetGPUIndex(), Parent->GetGPUMask().GetNative());

		// Create custom back buffer texture as no swap chain is created in pixel streaming windowless mode
		// í”½ì…€ ìŠ¤íŠ¸ë¦¬ë° ëª¨ë“œì—ì„œ ìœˆë„ìš°ê°€ ì—†ëŠ” í™˜ê²½ì—ì„œëŠ” ìŠ¤ì™‘ ì²´ì¸(swap chain)ì´ ìƒì„±ë˜ì§€ ì•Šê¸° ë•Œë¬¸ì—
		// ì»¤ìŠ¤í…€ ë°± ë²„í¼ í…ìŠ¤ì²˜ë¥¼ ìƒì„±í•´ì•¼ í•œë‹¤
		D3D12_RESOURCE_DESC TextureDesc;

		// GPU RAMì— ì •ì  ì •ë³´ë“±ì„ ë³µì‚¬í•´ì£¼ê¸° ìœ„í•œ BUFFERë¥¼ ë§Œë“ ë‹¤, BackBufferResource.GetInitReference() ì´ê³³ì— ë§Œë“¤ì–´ ì§„ë‹¤
		// í•´ë‹¹ ê³µê°„ì— ìˆëŠ” ë°ì´í„°ì˜ ì£¼ì†ŒëŠ” GPU Registers ì—ê²Œ ë„˜ê²¨ì§ˆ ê²ƒì´ë‹¤
		// BackBufferResourceì˜ ìë£Œí˜•ì€ ID3D12Resourceì´ë‹¤ ì¦‰ í…ìŠ¤ì³ë„ ID3D12Resourceì— ë‹´ê¸´ë‹¤ëŠ” ì‚¬ì‹¤ì„ ì•Œ ìˆ˜ ìˆë‹¤
		Parent->GetDevice()->CreateCommittedResource(&HeapProps, D3D12_HEAP_FLAG_NONE, &TextureDesc, D3D12_RESOURCE_STATE_PRESENT, nullptr, IID_PPV_ARGS(BackBufferResource.GetInitReference()));
	}
}
```

```cpp
// D3D12Submission.cpp

FD3D12DynamicRHI::FProcessResult FD3D12DynamicRHI::ProcessInterruptQueue()
{
	if (InterruptThread && !CurrentQueue.Fence.bInterruptAwaited)
	{
		// ì—¬ê¸°ì„œ D3DFenceì™€ Eventë¥¼ í™œìš©í•´ ë™ê¸°í™” ìˆ˜í–‰ ( GPU ì‘ì—…ì´ ì™„ë£Œë  ë•Œ ê¹Œì§€ ê¸°ë‹¤ë¦°ë‹¤ )
		// ì´ê²ƒì´ ìˆìœ¼ë©´ Unmapì„ ì‚¬ìš©í•˜ì§€ ì•Šê³  ë™ê¸°í™”ê°€ ê°€ëŠ¥í•˜ë‹¤
		VERIFYD3D12RESULT(CurrentQueue.Fence.D3DFence->SetEventOnCompletion(Payload->CompletionFenceValue, InterruptThread->Event));
		CurrentQueue.Fence.bInterruptAwaited = true;
	}
}

FD3D12DynamicRHI::FProcessResult FD3D12DynamicRHI::ProcessSubmissionQueue()
{
	for (int32 Index = 0; Index < Payload->CommandListsToExecute.Num(); Index++)
	{
		// ì´ í•¨ìˆ˜ ì•ˆì—ì„œ BarrierCommandList->Close() ë¥¼ í†µí•´ ì¼ê°ë“¤ì„ ë§ˆê° ì²˜ë¦¬í•œë‹¤
		if (FD3D12CommandList* BarrierCommandList = GenerateBarrierCommandListAndUpdateState(CurrentCommandList))
		{
			FD3D12Queue& BarrierQueue = BarrierCommandList->Device->GetQueue(BarrierCommandList->QueueType);
	
			if (&BarrierQueue == &CurrentQueue)
			{
				// ì¼ê°ë“¤ ì‹¤í–‰ ìš”ì²­, ì´í›„ì— PayloadToSubmit->CommandListsToExecute.Reset() í•¨ìˆ˜ë¥¼ í™œìš©í•´ Reset í•œë‹¤
				BarrierQueue.PayloadToSubmit->CommandListsToExecute.Insert(BarrierCommandList, Index++);
			}
		}
	}
}
```

```cpp
// D3D12View.cpp

void FD3D12ViewDescriptorHandle::CreateView(const D3D12_RENDER_TARGET_VIEW_DESC& Desc, ID3D12Resource* Resource)
{
	check(HeapType == ERHIDescriptorHeapType::RenderTarget);

	// ë Œë” íƒ€ê²Ÿì´ Resource ì— ë‹´ê¸´ë‹¤ ( ë Œë” íƒ€ê²Ÿì€ ìŠ¤ì™‘ì²´ì¸ì— í™œìš©ë˜ëŠ” BackBufferë¥¼ ì˜ë¯¸í•˜ëŠ” ë“¯ )
	GetParentDevice()->GetDevice()->CreateRenderTargetView(Resource, &Desc, OfflineCpuHandle);
}

void FD3D12ViewDescriptorHandle::CreateView(const D3D12_DEPTH_STENCIL_VIEW_DESC& Desc, ID3D12Resource* Resource)
{
	check(HeapType == ERHIDescriptorHeapType::DepthStencil);

	// DepthStencilView Bufferê°€ Resourceì— ë‹´ê¸´ë‹¤
	GetParentDevice()->GetDevice()->CreateDepthStencilView(Resource, &Desc, OfflineCpuHandle);
}

void FD3D12ViewDescriptorHandle::CreateView(const D3D12_CONSTANT_BUFFER_VIEW_DESC& Desc)
{
	check(HeapType == ERHIDescriptorHeapType::Standard);

	// Constant Buffer View ìƒì„± ( ë””ë²„ê¹… í•´ë³´ë‹ˆ ì´ í•¨ìˆ˜ í˜¸ì¶œ ì•ˆë˜ê³  ìˆìŒ )
	GetParentDevice()->GetDevice()->CreateConstantBufferView(&Desc, OfflineCpuHandle);
}
```

```cpp
// WindowsD3D12Viewport.cpp

void FD3D12Viewport::Init()
{
	// ì´ ì•ˆì—ì„œ ìŠ¤ì™‘ì²´ì¸ ì„¸íŒ…ì´ ì´ë£¨ì–´ì§„ë‹¤
	bNeedSwapChain = !FParse::Param(FCommandLine::Get(), TEXT("RenderOffScreen"));
	if (bNeedSwapChain)
	{
		if (FD3D12DynamicRHI::GetD3DRHI()->IsQuadBufferStereoEnabled())
		{
			if (Factory2->IsWindowedStereoEnabled())
			{
				DXGI_SWAP_CHAIN_DESC1 SwapChainDesc1{};

				// ë²„í¼ ì¹´ìš´íŠ¸
				SwapChainDesc1.BufferCount = NumBackBuffers;
			}
		}
	}
}

HRESULT FD3D12Viewport::PresentInternal(int32 SyncInterval)
{
	if (SwapChain1)
	{
		// ì—¬ê¸°ì„œ SwapChainì— ê·¸ë ¤ì¤˜(Present)ê°€ ë“±ë¡ë˜ì–´ì•¼ í•˜ëŠ”ë° ë””ë²„ê¹… í•´ë³´ë‹ˆ í˜¸ì¶œ ì•ˆë¨
		return SwapChain1->Present(SyncInterval, Flags);
	}

	return S_OK;
}

// ìŠ¤ì™‘ ì²´ì¸ Present ëŒ€í•œ ë‚´ìš©ì´ ì—¬ê¸°ì„œ ì²˜ë¦¬ë˜ê³  ìˆëŠ”ë“¯
bool FD3D12Viewport::Present(bool bLockToVsync)
{
	if (!IsPresentAllowed())
	{
		return false;
	}

	FD3D12Adapter* Adapter = GetParentAdapter();
	
	for (uint32 GPUIndex : FRHIGPUMask::All())
	{
		FD3D12CommandContext& DefaultContext = Adapter->GetDevice(GPUIndex)->GetDefaultCommandContext();

		// Those are not necessarily the swap chain back buffer in case of multi-gpu
		FD3D12Texture* DeviceBackBuffer = DefaultContext.RetrieveObject<FD3D12Texture, FRHITexture2D>(GetBackBuffer_RHIThread());
		FD3D12Texture* DeviceSDRBackBuffer = DefaultContext.RetrieveObject<FD3D12Texture, FRHITexture2D>(GetSDRBackBuffer_RHIThread());

		DefaultContext.TransitionResource(
			DeviceBackBuffer->GetShaderResourceView()->GetResource(),
			D3D12_RESOURCE_STATE_TBD,
			D3D12_RESOURCE_STATE_PRESENT, // í˜„ì¬ í™”ë©´ ì¶œë ¥
			0
		);

		if (SDRBackBuffer_RHIThread != nullptr)
		{
			DefaultContext.TransitionResource(
				DeviceSDRBackBuffer->GetShaderResourceView()->GetResource(),
				D3D12_RESOURCE_STATE_TBD,
				D3D12_RESOURCE_STATE_PRESENT, // í˜„ì¬ í™”ë©´ ì¶œë ¥
				0
			);
		}

		DefaultContext.FlushResourceBarriers();
	}
}
```

```cpp
// D3D12DescriptorCache.cpp

void FD3D12DescriptorCache::SetRenderTargets(FD3D12RenderTargetView** RenderTargetViewArray, uint32 Count, FD3D12DepthStencilView* DepthStencilTarget)
{
	for (uint32 i = 0; i < Count; i++)
	{
		if (RenderTargetViewArray[i] != NULL)
		{
			// D3D12_RESOURCE_STATE_RENDER_TARGET ê°€ ì˜ë¯¸í•˜ëŠ” ë°”ëŠ” ì™¸ì£¼ ê²°ê³¼ë¬¼
			Context.TransitionResource(RenderTargetViewArray[i], D3D12_RESOURCE_STATE_RENDER_TARGET);
		}

		if (DepthStencilTarget != nullptr)
		{
			// ì–´ë–¤ ë²„í¼ì— ê·¸ë¦¼ì„ ê·¸ë¦´ì§€ ì§€ì •
			// RTVDescriptors ì—¬ê¸°ì— BackBufferViewê°€ ë“¤ì–´ê°€ê³ , DSVDescriptor ì—¬ê¸°ì— DepthStencilViewê°€ ë“¤ì–´ ê°€ëŠ”ë“¯
			Context.GraphicsCommandList()->OMSetRenderTargets(Count, RTVDescriptors, 0, &DSVDescriptor);
		}
	}
}

void FD3D12DescriptorCache::SetVertexBuffers(FD3D12VertexBufferCache& Cache)
{
	//-------------------------------------------------------------------------------------------
	// CurrentVertexBufferViewsì˜ ìë£Œí˜•ì€ D3D12_VERTEX_BUFFER_VIEW ì´ë‹¤
	// D3D12_VERTEX_BUFFER_VIEW ìë£Œí˜•ì€ D3D12_GPU_VIRTUAL_ADDRESSë¥¼ ê°€ì§€ê³  ìˆëŠ” êµ¬ì¡°ì²´ì´ë‹¤
	// IASetVertexBuffers í•¨ìˆ˜ë¡œ ë Œë”ë§ íŒŒì´í”„ë¼ì¸ì— GPU ê³µê°„ì„ ì—°ë™í•œë‹¤
	// ì¦‰ CurrentVertexBufferViewsë¥¼ ì´ìš©í•´ GPUì— ì •ì  ë°ì´í„°ë¥¼ ì „ë‹¬í•œë‹¤
	// ë·°í¬íŠ¸ ìƒì—ì„œ ë ˆë²¨ì— ìˆëŠ” ëª¨ë“  ê°ì²´ë¥¼ ì§€ìš°ê³  ë””ë²„ê¹…ì„ ê±¸ì–´ë³´ë©´ Countê°€ 1ì´ ëœë‹¤
	// ìœ„ì˜ ìƒíƒœì—ì„œ Planeì„ ë°°ì¹˜í•˜ê³  ë””ë²„ê¹…ì„ ê±¸ì–´ë³´ë©´ Countê°€ 3ì´ ëœë‹¤
	//-------------------------------------------------------------------------------------------
	Context.GraphicsCommandList()->IASetVertexBuffers(0, Count, Cache.CurrentVertexBufferViews);
}

void FD3D12DescriptorCache::SetRootConstantBuffers(EShaderFrequency ShaderStage, const FD3D12RootSignature* RootSignature, FD3D12ConstantBufferCache& Cache, CBVSlotMask SlotsNeededMask)
{
	if (ShaderStage == SF_Compute)
	{
		// RootSignature ê´€ë ¨ Registers ì—ê²Œ í˜„ì¬ GPU RAM BUFFER ë°ì´í„° ì£¼ì†Œ(CurrentGPUVirtualAddress)ë¥¼ ë„˜ê²¨ì£¼ê³  ìˆë‹¤
		// GPU RAM BUFFERëŠ” ì—¬ëŸ¬ê°œ ì¼ ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ëª…ì‹¬í•˜ì ( 01-4 Constant Bufferì— ìˆëŠ” ì´ë¯¸ì§€ ì°¸ê³  )
		Context.GraphicsCommandList()->SetComputeRootConstantBufferView(BaseIndex + SlotIndex, CurrentGPUVirtualAddress);
	}
	else
	{
		// RootSignature ê´€ë ¨ Registers ì—ê²Œ í˜„ì¬ GPU RAM BUFFER ë°ì´í„° ì£¼ì†Œ(CurrentGPUVirtualAddress)ë¥¼ ë„˜ê²¨ì£¼ê³  ìˆë‹¤
		// GPU RAM BUFFERëŠ” ì—¬ëŸ¬ê°œ ì¼ ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ëª…ì‹¬í•˜ì ( 01-4 Constant Bufferì— ìˆëŠ” ì´ë¯¸ì§€ ì°¸ê³  )
		Context.GraphicsCommandList()->SetGraphicsRootConstantBufferView(BaseIndex + SlotIndex, CurrentGPUVirtualAddress);
	}
}

void FD3D12DescriptorCache::SetUAVs(EShaderFrequency ShaderStage, const FD3D12RootSignature* RootSignature, FD3D12UnorderedAccessViewCache& Cache, const UAVSlotMask& SlotsNeededMask, uint32 SlotsNeeded, uint32& HeapSlot)
{
	// CPUì— ìˆëŠ” Desc.Heap ë‚´ìš©ì„ GUPì— ìˆëŠ” Desc.Heapìœ¼ë¡œ ì˜®ê²¨ì¤€ë‹¤
	GetParentDevice()->GetDevice()->CopyDescriptors(
		1, &DestDescriptor, &SlotsNeeded,
		SlotsNeeded, SrcDescriptors, nullptr /* sizes */,
		D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
}

bool FD3D12DescriptorCache::SetDescriptorHeaps(bool bForceHeapChanged)
{
	// Set the descriptor heaps.
	if (bHeapChanged)
	{
		// ì–´ë–¤ Heapì„ ì‚¬ìš©í•´ì¤„ ê²ƒì¸ì§€ ì§€ì • ( ë¬´ê±°ìš´ í•¨ìˆ˜ì—¬ì„œ í”„ë ˆì„ ë§ˆë‹¤ í•œë²ˆì”©ë§Œ í˜¸ì¶œí•´ì•¼ í•œë‹¤ )
		Context.GraphicsCommandList()->SetDescriptorHeaps(UE_ARRAY_COUNT(ppHeaps), ppHeaps);
	}
}
```

```cpp
// D3D12Resources.cpp

void FD3D12ResourceBarrierBatcher::FlushIntoCommandList(FD3D12CommandList& CommandList, FD3D12QueryAllocator& TimestampAllocator)
{
	// BarriersëŠ” D3D12_RESOURCE_BARRIER êµ¬ì¡°ë¡œ ë˜ì–´ìˆë‹¤
	// SwapChain ì •ë³´, D3D12_RESOURCE_STATE_PRESENT ì •ë³´, D3D12_RESOURCE_STATE_RENDER_TARGET ì •ë³´ê°€ ìˆì„ ìˆ˜ ìˆë‹¤
	CommandList.GraphicsCommandList()->ResourceBarrier(BatchEnd - BatchStart, &Barriers[BatchStart]);
}

// D3D12_CLEAR_VALUEëŠ” Depth Bufferë¥¼ ì´ˆê¸°í™” í•´ì¤„ë•Œ ë„£ì–´ì¤„ ê°’ì´ë‹¤ ( ë³´í†µ 1.0fê°€ ì„¤ì •ë˜ëŠ”ë° ì´ëŠ” ì•„ë¬´ ë¬¼ì²´ë„ ê·¸ë¦¬ì§€ ì•Šì€ ìƒíƒœ )
HRESULT FD3D12Adapter::CreateCommittedResource(const FD3D12ResourceDesc& InDesc, FRHIGPUMask CreationNode, const D3D12_HEAP_PROPERTIES& HeapProps, D3D12_RESOURCE_STATES InInitialState,
	ED3D12ResourceStateMode InResourceStateMode, D3D12_RESOURCE_STATES InDefaultState, const D3D12_CLEAR_VALUE* ClearValue, FD3D12Resource** ppOutResource, const TCHAR* Name, bool bVerifyHResult)
{
}
```

```cpp
D3D12StateCache.cpp

void FD3D12StateCache::ApplyState(ED3D12PipelineType PipelineType)
{
	// ì´ êµ¬ë¬¸ì— ë¸Œë ˆì´í¬ í¬ì¸íŠ¸ ì°ê³  ë“¤ì–´ê°€ë³´ë©´
	// CmdContext.GraphicsCommandList()->SetGraphicsRootSignature ì´ í•¨ìˆ˜ê°€ ì‚¬ìš©ë˜ì§€ ì•Šê³  ìˆë‹¤
	const bool bRootSignatureChanged = InternalSetRootSignature(PipelineType, PSOCommonData->RootSignature);

	if (bNeedSetViewports)
	{
		// ë·°í¬íŠ¸ ë“±ë¡
		CmdContext.GraphicsCommandList()->RSSetViewports(PipelineState.Graphics.CurrentNumberOfViewports, PipelineState.Graphics.CurrentViewport);
	}
	if (bNeedSetScissorRects)
	{
		// íŠ¹ì • ì˜ì—­ë§Œ ë Œë”ë§í•˜ê±°ë‚˜ ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•´ ì‚¬ìš©ë˜ëŠ” ì¤‘ìš”í•œ í•¨ìˆ˜
		CmdContext.GraphicsCommandList()->RSSetScissorRects(PipelineState.Graphics.CurrentNumberOfScissorRects, PipelineState.Graphics.CurrentScissorRects);
	}
	if (bNeedSetPrimitiveTopology)
	{
		// ì¸í’‹ ì–´ì…ˆë¸”ëŸ¬(Input Assembler, IA) ë‹¨ê³„ì— ì‚¬ìš©ë  ê¸°ë³¸ ë„í˜• í† í´ë¡œì§€ë¥¼ ì„¤ì •í•˜ëŠ” í•¨ìˆ˜
		CmdContext.GraphicsCommandList()->IASetPrimitiveTopology(PipelineState.Graphics.CurrentPrimitiveTopology);
	}
}

void FD3D12StateCache::InternalSetStreamSource(FD3D12ResourceLocation* VertexBufferLocation, uint32 StreamIndex, uint32 Stride, uint32 Offset)
{
	// Initialize the vertex buffer view ( View ë°ì´í„°ëŠ” CPUì™€ GPUê°€ ê³µìœ í•œë‹¤ )
	__declspec(align(16)) D3D12_VERTEX_BUFFER_VIEW NewView;
	// ë·°ì˜ ìœ„ì¹˜
	NewView.BufferLocation = (VertexBufferLocation) ? VertexBufferLocation->GetGPUVirtualAddress() + Offset : 0;
	// ì •ì  1ê°œ í¬ê¸°
	NewView.StrideInBytes = Stride;
	// ë²„í¼ì˜ í¬ê¸°
	NewView.SizeInBytes = (VertexBufferLocation) ? VertexBufferLocation->GetSize() - Offset : 0; // Make sure we account for how much we offset into the VB
}

void FD3D12StateCache::InternalSetPipelineState(FD3D12PipelineState* InPipelineState)
{
	ID3D12PipelineState* const PendingD3DPipelineState = InPipelineState->GetPipelineState();

	if (PipelineState.Common.bNeedSetPSO || CurrentD3DPipelineState == nullptr || CurrentD3DPipelineState != PendingD3DPipelineState)
	{
		// ìœ„ì˜ InternalSetStreamSource() í•¨ìˆ˜ì—ì„œ ë§Œë“  ì •ë³´ë¥¼ íŒŒì´í”„ ë¼ì¸ì— ë“±ë¡í•œë‹¤
		// ì•„ë§ˆ D3D12_INPUT_ELEMENT_DESC ì •ë³´ë„ ë“¤ì–´ìˆì„ ê²ƒì´ë‹¤
		CmdContext.GraphicsCommandList()->SetPipelineState(PendingD3DPipelineState);
	}
}

void FD3D12StateCache::InternalSetIndexBuffer(FD3D12Resource* Resource)
{
	// IndexBufferViewë¥¼ ì‚¬ìš©í•˜ì—¬ GPUì— ì¸ë±ìŠ¤ ë°ì´í„°ë¥¼ ì „ë‹¬í•œë‹¤
	CmdContext.GraphicsCommandList()->IASetIndexBuffer(&PipelineState.Graphics.IBCache.CurrentIndexBufferView);
}
```

### 01-3 ì‚¼ê°í˜• ë„ìš°ê¸°

```cpp
// D3D12RootSignature.h
// D3D12RootSignature.cpp

class FD3D12RootSignature : public FD3D12AdapterChild
{
	// RootSignatureë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” í•¨ìˆ˜ ( GPU ì—ê²Œ ê³„ì•½ì„œë¥¼ ê±´ë‚´ì£¼ëŠ” ì¼ì„ ë‹´ë‹¹í•œë‹¤ )
	ID3D12RootSignature* GetRootSignature() const { return RootSignature.GetReference(); }
}

//-----------------------------------------------------------------------------------------
// D3D12_VERSIONED_ROOT_SIGNATURE_DESC ì•ˆì— í”Œë˜ê·¸ ì •ë³´ë¥¼ ë³´ë©´
// D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT ì™€ ê°™ì€ ì •ë³´ì™€
// D3D12_ROOT_PARAMETER íƒ€ì… ë³€ìˆ˜ì— Registersë¥¼ ì–´ë–»ê²Œ í™œìš©í•  ê²ƒì¸ì§€ì— ëŒ€í•œ ì •ë³´ê°€ ìˆë‹¤
// ê°•ì¢Œì—ì„œëŠ” í•´ë‹¹ Registersë¥¼ Constant Buffer Viewë¡œ í™œìš©í–ˆë‹¤
// ì°¸ê³ ë¡œ INPUT_ASSEMBLER_INPUT_LAYOUT í”Œë˜ê·¸ëŠ” ì…ë ¥ ì¡°ë¦½ê¸° ë‹¨ê³„ë¥¼ ëœ»í•œë‹¤
//-----------------------------------------------------------------------------------------
void FD3D12RootSignature::Init(const D3D12_VERSIONED_ROOT_SIGNATURE_DESC& InDesc, uint32 BindingSpace)
{
	ID3D12Device* Device = GetParentAdapter()->GetD3DDevice();
	const HRESULT SerializeHR = D3DX12SerializeVersionedRootSignature(&InDesc, MaxRootSignatureVersion, RootSignatureBlob.GetInitReference(), Error.GetInitReference());

	VERIFYD3D12RESULT(SerializeHR);

	// Create and analyze the root signature. ( RootSignature ìƒì„± )
	VERIFYD3D12RESULT(Device->CreateRootSignature(FRHIGPUMask::All().GetNative(),
		RootSignatureBlob->GetBufferPointer(),
		RootSignatureBlob->GetBufferSize(),
		IID_PPV_ARGS(RootSignature.GetInitReference())));
}

FD3D12RootSignatureDesc::FD3D12RootSignatureDesc(const FD3D12QuantizedBoundShaderState& QBSS, const D3D12_RESOURCE_BINDING_TIER ResourceBindingTier)
{
	// Sampler ê´€ë ¨ ì •ë³´ëŠ” ì—¬ê¸°ì„œ ì„¸íŒ… ë˜ëŠ”ê²ƒ ê°™ë‹¤
	const D3D12_DESCRIPTOR_RANGE_FLAGS SamplerDescriptorRangeFlags = (ResourceBindingTier <= D3D12_RESOURCE_BINDING_TIER_1) ?
		D3D12_DESCRIPTOR_RANGE_FLAG_NONE :
		D3D12_DESCRIPTOR_RANGE_FLAG_DESCRIPTORS_VOLATILE;

	case D3D12_ROOT_PARAMETER_TYPE_CBV:
	{
		for (uint32 ShaderRegister = 0; (ShaderRegister < Shader.ConstantBufferCount) && (ShaderRegister < MAX_ROOT_CBVS); ShaderRegister++)
		{
			// RootSignature ê´€ë ¨ MSDN ìƒì— ë‚˜ì™€ ìˆëŠ” ì´ë¯¸ì§€ë¥¼ ë³´ë©´ ì´ˆë¡ìƒ‰ìœ¼ë¡œ
			// root CBV ë¼ê³  í‘œì‹œëœ ê³µê°„ì´ ìˆëŠ”ë° ê·¸ ê³µê°„ì„ í™œìš© í•œë‹¤ëŠ” ì½”ë“œ
			// í•´ë‹¹ ê³µê°„ì€ Lightì™€ ê°™ì´ ì „ì—­ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ê²ƒë“¤ì´ ì‚¬ìš©í•  ê²ƒì´ë‹¤
			// GetD3D12ShaderVisibilityëŠ” Shader ë‹¨ê³„ë“¤ì¤‘ ì–´ë””ê¹Œì§€ í™œìš©ë  ê²ƒì¸ì§€ë¥¼ ë‚˜íƒ€ë‚¸ë‹¤
			TableSlots[RootParameterCount].InitAsConstantBufferView(ShaderRegister, BindingSpace, CBVRootDescriptorFlags, GetD3D12ShaderVisibility(Visibility));
		}
	}

	case D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE:
	{
		if (Shader.ShaderResourceCount > 0)
		{
			// Shader Resource Viewë¡œ í™œìš©í•  ê²ƒì´ë©°, Shader.ShaderResourceCount ë§Œí¼ í™œìš©í•  ê²ƒì´ë©°, 0u ë²ˆì§€ë¶€í„° í™œìš©í•  ê²ƒì´ë‹¤
			DescriptorRanges[RootParameterCount].Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, Shader.ShaderResourceCount, 0u, BindingSpace, SRVDescriptorRangeFlags);
			
			// desc.table ë‚´ìš©ë¬¼ì„ ì–´ë–»ê²Œ êµ¬ì„±í•  ê²ƒì¸ì§€ ( ì´ ì •ë³´ëŠ” D3D12_VERSIONED_ROOT_SIGNATURE_DESCì— ë“±ë¡ëœë‹¤ )
			TableSlots[RootParameterCount].InitAsDescriptorTable(1, &DescriptorRanges[RootParameterCount], GetD3D12ShaderVisibility(Visibility));
		}
	}
}
```

```cpp
// D3D12StateCachePrivate.h

struct FD3D12VertexBufferCache
{
	// ID3D12Resourceë¥¼ ëŒ€ì‹ í•˜ëŠ” ê°ì²´ì´ë‹¤
	D3D12_VERTEX_BUFFER_VIEW CurrentVertexBufferViews[MAX_VBS];
}

struct FD3D12IndexBufferCache
{
	// ID3D12Resourceë¥¼ ëŒ€ì‹ í•˜ëŠ” ê°ì²´ì´ë‹¤
	D3D12_INDEX_BUFFER_VIEW CurrentIndexBufferView;
};
```

```cpp
D3D12RenderTarget.cpp

// Map, Memcpy, Unmap í•¨ìˆ˜ê°€ í•µì‹¬
void FD3D12DynamicRHI::RHIReadSurfaceFloatData(FRHITexture* TextureRHI, FIntRect InRect, TArray<FFloat16Color>& OutData, FReadSurfaceDataFlags InFlags)
{
	// ID3D12Resource íƒ€ì…ìœ¼ë¡œ ë§Œë“¤ì–´ì§„ GPU RAM BUFFERì— CPU RAM BUFFER ë°ì´í„°ì¸ pDataë¥¼ ì—°ë™í•œë‹¤
	VERIFYD3D12RESULT(TempTexture2D->GetResource()->Map(0, &Range, &pData));

	for (int32 Y = InRect.Min.Y; Y < InRect.Max.Y; Y++)
	{
		FFloat16Color* SrcPtr = (FFloat16Color*)((uint8*)pData + (Y - InRect.Min.Y) * XBytesAligned);
		int32 Index = (Y - InRect.Min.Y) * SizeX;
		check(Index + ((int32)SizeX - 1) < OutData.Num());
		FFloat16Color* DestColor = &OutData[Index];
		FFloat16* DestPtr = (FFloat16*)(DestColor);

		// ë°ì´í„°ê°€ GPU ë©”ëª¨ë¦¬ë¡œ ì „ë‹¬ëœë‹¤
		FMemory::Memcpy(DestPtr, SrcPtr, SizeX * sizeof(FFloat16) * 4);
	}

	// ë°ì´í„° ì—°ë™ ì¢…ë£Œ
	TempTexture2D->GetResource()->Unmap(0, nullptr);
}
```

```cpp
// ShaderPipelineCache.cpp

bool FShaderPipelineCacheTask::Precompile(FRHICommandListImmediate& RHICmdList, EShaderPlatform Platform, FPipelineCacheFileFormatPSO const& PSO)
{
	FVertexShaderRHIRef VertexShader;
	if (PSO.GraphicsDesc.VertexShader != FSHAHash())
	{
		// CreateVertexShader í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ Shader íŒŒì¼ì„ ì½ì–´ Initì„ í•´ì¤˜ì•¼ í•˜ëŠ”ë° í˜¸ì¶œì´ ì•ˆë˜ë„¤
		VertexShader = FShaderCodeLibrary::CreateVertexShader(Platform, PSO.GraphicsDesc.VertexShader);
		GraphicsInitializer.BoundShaderState.VertexShaderRHI = VertexShader;
	}
}
```

```cpp
// ShaderResource.cpp

FRHIShader* FShaderMapResource_InlineCode::CreateRHIShaderOrCrash(int32 ShaderIndex)
{
	TRefCountPtr<FRHIShader> RHIShader;
	switch (Frequency)
	{
	// ì–¸ë¦¬ì–¼ ì—ì„œëŠ” CreateVertexShader ëŒ€ì‹  RHICreateVertexShader ë¼ëŠ” í•¨ìˆ˜ë¥¼ ë§Œë“¤ì—ˆë‹¤
	case SF_Vertex: RHIShader = RHICreateVertexShader(ShaderCodeView, ShaderHash); break;
	case SF_Mesh: RHIShader = RHICreateMeshShader(ShaderCodeView, ShaderHash); break;
	case SF_Amplification: RHIShader = RHICreateAmplificationShader(ShaderCodeView, ShaderHash); break;
	case SF_Pixel: RHIShader = RHICreatePixelShader(ShaderCodeView, ShaderHash); break;
	case SF_Geometry: RHIShader = RHICreateGeometryShader(ShaderCodeView, ShaderHash); break;
	case SF_Compute: RHIShader = RHICreateComputeShader(ShaderCodeView, ShaderHash); break;
	}
}
```

- USF Shader íŒŒì¼ì´ë€? USF Shader íŒŒì¼ì€ HLSL ì–¸ì–´ì— ê¸°ë°˜í•œ ê²ƒìœ¼ë¡œ, ë©€í‹° í”Œë«í¼ ì…°ì´ë” ì½”ë“œê°€ ë“¤ì–´ìˆëŠ” ì–¸ë¦¬ì–¼ ì—”ì§„ ì…°ì´ë” íŒŒì¼ í¬ë§·ì…ë‹ˆë‹¤ ([**ì°¸ê³ **](https://kaynine.tistory.com/2)), ([**ì°¸ê³ **](https://scahp.tistory.com/10)), ([**ì°¸ê³ **](https://scahp.tistory.com/78)), ([**ì°¸ê³ **](https://aym0011.wordpress.com/2019/01/25/ue4-%EC%BB%A4%EC%8A%A4%ED%85%80-%ED%88%B0%EC%85%B0%EC%9D%B4%EB%8D%94-%EC%B6%94%EA%B0%80%EB%B0%A9%EB%B2%95/))

### 01-4 Constant Buffer

![pipeline](https://github.com/devMyeong/devMyeong.github.io/assets/80055816/46dbebb8-3a85-4988-9295-fb0a18b84011){: width="100%" height="100%"}{: .align-center}

![cpugpu](https://github.com/devMyeong/devMyeong.github.io/assets/80055816/36dd9b65-64d1-4b94-9ba8-4d6226bb6034){: width="100%" height="100%"}{: .align-center}

- RootSignatureì˜ ìš©ë„ëŠ”? GPU Registersë¥¼ ì–´ë–»ê²Œ í™œìš©í•  ê²ƒì¸ì§€ ì„¤ì • ( 08 : 38 ) ([**ì°¸ê³ **](https://learn.microsoft.com/ko-kr/windows/win32/direct3d12/example-root-signatures))
- Registersë¥¼ í™œìš©í•˜ê¸° ìœ„í•œ ë‹¨ê³„ë¥¼ ì„¤ëª…í•˜ë©´? CPU RAM ì—ì„œ GPU RAMìœ¼ë¡œ ë°ì´í„°ë¥¼ ë³µì‚¬í•œ ë’¤ ê·¸ ë°ì´í„°ì˜ ìœ„ì¹˜ë¥¼ Constant Buffer Viewë¡œ ì‚¬ìš©í•  Registersì— ë³µì‚¬í•´ì¤˜ì•¼ í•œë‹¤ ( 28 : 48 )
- GPU RAM ê³µê°„ ìƒì„±ê³¼ ë°ì´í„° ì—°ë™ì— ëŒ€í•´ API ê¸°ë°˜ìœ¼ë¡œ ì„¤ëª…í•˜ë©´? CreateCommittedResource -> Map -> Unmap ( 32 : 41 )
- ìœ„ì˜ ê³¼ì •ì´ ëë‚˜ë©´ ì–´ë–»ê²Œ ë˜ëŠ”ê°€? CPU RAM ë°ì´í„°ê°€ GPU RAM ìœ¼ë¡œ ì¦‰ì‹œ ë³µì‚¬ëœë‹¤ ( 33 : 07 )
- GPU RAMì—ì„œ GPU Registersë¡œì˜ ë³µì‚¬ëŠ” CommandQueueë¥¼ í™œìš©í•´ ë‚˜ì¤‘ì— ì²˜ë¦¬ ë˜ê¸° ë•Œë¬¸ì— ë°œìƒí•˜ëŠ” ë¬¸ì œì™€ í•´ê²° ë°©ë²•ì„ ì„¤ëª…í•˜ë©´? ë‚´ê°€ ì‘ì—…ì„ ìš”ì²­í–ˆë˜ ë‹¹ì‹œì™€ ìƒí™©ì´ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆë‹¤ ë•Œë¬¸ì— GPU RAM ìƒì— ë²„í¼ë¥¼ í•œê°œê°€ ì•„ë‹Œ ì—¬ëŸ¬ê°œë¡œ ë§Œë“ ë‹¤ ( 37 : 14 )
- GPU RAMì— ìƒì„±ë˜ëŠ” BUFFERì˜ íƒ€ì…ì€ ë¬´ì—‡ì¸ê°€? ID3D12Resource ( 40 : 00 )
- ìƒìˆ˜ ë²„í¼ëŠ” ëª‡ ë°”ì´íŠ¸ ë°°ìˆ˜ë¡œ ë§Œë“¤ì–´ì•¼ í•˜ëŠ”ê°€? 256 ( 42 : 59 )
- ìƒìˆ˜ ë²„í¼ëŠ” ì–´ë–»ê²Œ í™œìš©ë  ìˆ˜ ìˆëŠ”ê°€? Offsetì„ GPU Registersë¡œ ë„˜ê²¨ì¤„ ë•Œ í™œìš©ë  ìˆ˜ ìˆë‹¤ ( 57 : 20 )

### 01-5 Root Signature

![desc](https://github.com/devMyeong/devMyeong.github.io/assets/80055816/4a839a7e-cdc1-419e-8eab-8ddf06c1d340){: width="100%" height="100%"}{: .align-center}

- root CBV ê³µê°„ë§ê³  í™œìš©í•  ìˆ˜ ìˆëŠ” ê³µê°„ì€? desc.table ( 01 : 34 )
- desc.tableì„ ë™ì‹œì— í™œì„±í™” í•  ìˆ˜ ìˆëŠ”ê°€? ì•„ë‹ˆì˜¤ ( 01 : 47 )
- desc.table ì•ˆì— 5ê°œì˜ ê³µê°„ì„ ì‚¬ìš©í•˜ë ¤ë©´ ì–´ë–»ê²Œ í•´ì•¼ í•˜ëŠ”ê°€? GPU RAMì— Desc.Heapì„ ë§Œë“¤ê³  ì—¬ê¸°ì—ë„ 5ê°œì˜ ê³µê°„ì„ ë§Œë“¤ì–´ ì¤˜ì•¼ í•œë‹¤ ( 05 : 30 )
- GPU RAMì˜ Desc.Heapì— ìˆëŠ” 5ê°œì˜ ê³µê°„ì€ ì–´ë–»ê²Œ ì±„ì›Œì•¼ í•˜ëŠ”ê°€? 5ê°œì˜ ê³µê°„ì„ ê°€ì§€ê³  ìˆìœ¼ë©° ì´ ê³µê°„ì´ Constant Buffer 5ê°œë¥¼ ê°ê° ê°€ë¦¬í‚¤ëŠ” Desc.Heap ìœ¼ë¡œ ë¶€í„° ì¦‰ì‹œ ë³µì‚¬í•´ì˜¨ë‹¤ ì°¸ê³ ë¡œ í•´ë‹¹ Desc.Heapì€ Constant Buffer View ë¼ê³  ë¶€ë¥¸ë‹¤ ( 06 : 35 )
- GPU RAMì˜ Desc.Heapì— ìˆëŠ” ë°ì´í„°ë¥¼ desc.tableë¡œ ë³µì‚¬í•˜ëŠ” ê²ƒì€ ì¦‰ì‹œë³µì‚¬ ì¸ê°€ ë‚˜ì¤‘ë³µì‚¬ ì¸ê°€? ë‚˜ì¤‘ë³µì‚¬ ( 07 : 49 )
- ìœ„ì˜ ë³µì‚¬ë¡œ ì¸í•´ ìƒê¸°ëŠ” íƒ€ì´ë° ë¬¸ì œë¥¼ í•´ê²°í•  ë°©ë²•ì€? GPU RAMì˜ Desc.Heap(ì•ˆì— ê³µê°„ 5ê°œ ìˆìŒ)ì„ ì—¬ëŸ¬ê°œë¡œ ë§Œë“ ë‹¤ ( 08 : 50 )
- Constant Bufferë¥¼ ê°€ë¦¬í‚¤ê³  ìˆëŠ” Desc.Heapì˜ ìë£Œí˜•ì€ ë¬´ì—‡ì¸ê°€? ID3D12DescriptorHeap ( 19 : 20 )

```cpp
// D3D12Descriptors.h
struct FD3D12DescriptorHeap : public FD3D12DeviceChild, public FThreadSafeRefCountedObject
{
	// Constant Bufferë¥¼ ê°€ë¦¬í‚¤ê³  ìˆëŠ” Desc.Heapì˜ íŠ¹ì • ìŠ¬ë¡¯ í•¸ë“¤ì„ ê°€ì ¸ì˜¨ë‹¤
	inline D3D12_CPU_DESCRIPTOR_HANDLE GetCPUSlotHandle(uint32 Slot) const { return CD3DX12_CPU_DESCRIPTOR_HANDLE(CpuBase, Slot, DescriptorSize); }

	// GPU RAMì˜ Desc.Heapì— ìˆëŠ” íŠ¹ì • ìŠ¬ë¡¯ í•¸ë“¤ì„ ê°€ì ¸ì˜¨ë‹¤
	inline D3D12_GPU_DESCRIPTOR_HANDLE GetGPUSlotHandle(uint32 Slot) const { return CD3DX12_GPU_DESCRIPTOR_HANDLE(GpuBase, Slot, DescriptorSize); }
}
```

### 01-6 Index Buffer
- Constant BufferëŠ” ì–´ë–»ê²Œ í™œìš©í•  ìˆ˜ ìˆëŠ”ê°€? CreateCommittedResource -> Map -> Unmap í™œìš©í•´ ë¬¼ì²´ ì •ë³´ë¥¼ í•œë²ˆë§Œ ìƒì„±í•œ ë’¤ Constant Bufferë¥¼ í™œìš©í•´ ì—¬ëŸ¬ ë¬¼ì²´ë¥¼ ë‹¤ì–‘í•œ ëª¨ì–‘ìœ¼ë¡œ ë³€ê²½í•´ ë Œë”ë§ ( 01 : 42 )
- 4ë²ˆ ê°•ì¢Œì— ìˆëŠ” ë Œë”ë§ íŒŒì´í”„ ë¼ì¸ì„ ë³´ê³  ìš°ë¦¬ê°€ ë Œë”ë§ íŒŒì´í”„ ë¼ì¸ì— ì •ë³´ë¥¼ ì „ë‹¬í•˜ëŠ” ë°©ì‹ 3ê°€ì§€ë¥¼ ì„¤ëª…í•˜ë©´? Root descriptors, Descriptor tables, Root Constant ( 03 : 03 )
- ì¸ë±ìŠ¤ ë²„í¼ëŠ” ì™œ ì‚¬ìš©í•´ì•¼ í•˜ëŠ”ê°€? ì¤‘ë³µë˜ëŠ” ë²„í…ìŠ¤ ì •ë³´ë¥¼ ì œì™¸í•˜ë©´ ì‚¼ê°í˜• ë“¤ì´ ì–´ë–»ê²Œ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ ì•Œìˆ˜ì—†ê¸° ë•Œë¬¸ì´ë‹¤ ( 12 : 18 )
- ì¸ë±ìŠ¤ ë²„í¼ë¥¼ ì •í• ë•Œ ìˆœì„œê°€ ì¤‘ìš”í•œê°€? ì•„ë‹ˆì˜¤ ( 21 : 09 )
- 4ë²ˆ ê°•ì¢Œì— ìˆëŠ” ë Œë”ë§ íŒŒì´í”„ ë¼ì¸ì„ ë³´ê³  Vertex Buffer ì •ë³´ì™€ Index Buffer ì •ë³´ê°€ ì–´ëŠ ë‹¨ê³„ì—ì„œ ì •í•´ì§€ëŠ”ì§€ ê°€ë¦¬ì¼œ ë³´ë©´? ( 22 : 24 )

### 01-7 Texture Mapping
- UV ì¢Œí‘œì— ëŒ€í•´ì„œ ì„¤ëª…í•˜ë©´? ( 03 : 11 )
- í…ìŠ¤ì³ê°€ ë§µí•‘ë˜ëŠ” ì›ë¦¬ë¥¼ ì„¤ëª…í•˜ë©´? ( 04 : 08 )
- í…ìŠ¤ì³ê°€ Constant Bufferì™€ ë‹¤ë¥¸ì ì€? Constant Bufferì™€ ë‹¬ë¦¬ Desc.Heapì— Viewë¥¼ ë”± í•˜ë‚˜ë§Œ ë§Œë“¤ì–´ë„ ëœë‹¤, Constant Bufferë¥¼ ë§Œë“¤ë•ŒëŠ” Desc.Heapì— Viewë¥¼ 5ê°œ ë§Œë“¤ì–´ í•´ë‹¹ View ë‚´ìš©ì„ Registersë¡œ ë³µì‚¬í•´ì¤Œ ( 16 : 16 )

```cpp
// D3D12Texture.cpp

FTextureRHIRef FD3D12DynamicRHI::RHIAsyncCreateTexture2D(uint32 SizeX, uint32 SizeY, uint8 Format, uint32 NumMips, ETextureCreateFlags Flags, ERHIAccess InResourceState, void** InitialMipData, uint32 NumInitialMips)
{
	// ë¦¬ì†ŒìŠ¤ ë¡œë“œ ( ì—¬ê¸°ì„œ ì‚¬ìš©í•˜ëŠ” CommandListëŠ” ë¦¬ì†ŒìŠ¤ ë¡œë“œ ìš©ë„ë¡œ ì‚¬ìš©ë˜ëŠ” ê°ì²´ )
	UpdateSubresources(
	CopyScope.Context.CopyCommandList().Get(),
	Resource->GetResource(),
	TempResourceLocation.GetResource()->GetResource(),
	TempResourceLocation.GetOffsetFromBaseOfResource(),
	0, NumMips,
	SubResourceData);
}

FD3D12ResourceDesc FD3D12DynamicRHI::GetResourceDesc(const FRHITextureDesc& TextureDesc) const
{
	// 2D í…ìŠ¤ì³ë¥¼ ë§Œë“¤ê³  ìˆë‹¤
	ResourceDesc = CD3DX12_RESOURCE_DESC::Tex2D(
		PlatformResourceFormat,
		TextureDesc.Extent.X,
		TextureDesc.Extent.Y,
		TextureDesc.ArraySize * (TextureDesc.IsTextureCube() ? 6 : 1),  // Array size
		TextureDesc.NumMips,
		ActualMSAACount,
		ActualMSAAQuality,
		D3D12_RESOURCE_FLAG_NONE);  // Add misc flags later
	
	// ì–´ë–¤ ìš©ë„ë¡œ ì‚¬ìš©í•  ê²ƒì¸ì§€ ì§€ì •í•´ì£¼ê³  ìˆë‹¤
	if (EnumHasAnyFlags(TextureDesc.Flags, TexCreate_Shared))
	{
		ResourceDesc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_SIMULTANEOUS_ACCESS;
	}
	
	if (EnumHasAnyFlags(TextureDesc.Flags, TexCreate_RenderTargetable))
	{
		check(!EnumHasAnyFlags(TextureDesc.Flags, TexCreate_DepthStencilTargetable | TexCreate_ResolveTargetable));
		ResourceDesc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET;
	}
	else if (EnumHasAnyFlags(TextureDesc.Flags, TexCreate_DepthStencilTargetable))
	{
		check(!EnumHasAnyFlags(TextureDesc.Flags, TexCreate_RenderTargetable | TexCreate_ResolveTargetable));
		ResourceDesc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;
	}
	else if (EnumHasAnyFlags(TextureDesc.Flags, TexCreate_ResolveTargetable))
	{
		check(!EnumHasAnyFlags(TextureDesc.Flags, TexCreate_RenderTargetable | TexCreate_DepthStencilTargetable));
		if (TextureDesc.Format == PF_DepthStencil || TextureDesc.Format == PF_ShadowDepth || TextureDesc.Format == PF_D24)
		{
			ResourceDesc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;
		}
		else
		{
			ResourceDesc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET;
		}
	}
}
```

```cpp
// hlsl

// tex_0ëŠ” ë ˆì§€ìŠ¤í„° t0 ê³µê°„ì„ ì‚¬ìš©í•  ê²ƒì´ë‹¤
Texture2D tex_0 : register(t0)

// sam_0ëŠ” ë ˆì§€ìŠ¤í„° s0 ê³µê°„ì„ ì‚¬ìš©í•  ê²ƒì´ë‹¤
SamplerState sam_0 : register(s0)

// VS_IN ì˜ˆì‹œ
struct VS_IN
{
	float3 pos : POSITION;
	float4 color : COLOR;
	float2 uv : TEXCOORD;
}
```

```cpp
// D3D12VertexDeclaration.cpp

explicit FD3D12VertexDeclarationKey(const FVertexDeclarationElementList& InElements)
{
	for (int32 ElementIndex = 0; ElementIndex < InElements.Num(); ElementIndex++)
	{
		const FVertexElement& Element = InElements[ElementIndex];

		// hlslì˜ POSITION, COLOR, TEXCOORD ê°™ì€ ë¶€ë¶„ê³¼ ì—°ë™ë˜ëŠ” êµ¬ì¡°ì²´
		D3D12_INPUT_ELEMENT_DESC D3DElement = { 0 };
		D3DElement.InputSlot = Element.StreamIndex;
		D3DElement.AlignedByteOffset = Element.Offset;
	}
}
```

- UV ì¢Œí‘œëŠ” ëª‡ ë¶€í„° ëª‡ ê¹Œì§€ì¸ê°€? ( 41 : 30 )

### 01-8 Depth Stencil View
- Depth Stencil Viewë¥¼ ë Œë”ë§ íŒŒì´í”„ë¼ì¸ ì´ë¯¸ì§€ì—ì„œ ì§‘ì–´ë³´ë©´? ( 00 : 50 )
- ìš°ë¦¬ê°€ ì–´ë–¤ ë¬¼ì²´ë¥¼ ê·¸ë ¤ì•¼ í• ì§€ ì•ˆê·¸ë ¤ì•¼ í• ì§€ ì–´ë–»ê²Œ íŒë‹¨í•˜ëŠ”ê°€? ( 09 : 18 )
- ë§Œì•½ Depth ê°’ì´ ìŒìˆ˜ ë˜ëŠ” 1ì„ ë„˜ì–´ê°€ë©´ ì–´ë–»ê²Œ ë˜ëŠ”ê°€? ë ˆìŠ¤í„° ë¼ì´ì € ë‹¨ê³„ì—ì„œ ì œê±°ëœë‹¤ ( 13 : 22 )
- Depth Stencil View ë‹¨ê³„ì—ì„œ í•˜ê³ ì‹¶ì€ ì¼ì„ ì„œìˆ í•˜ë©´? ( 14 : 08 )
- ë§Œì•½ì— ìš°ë¦¬ê°€ Stencil ê°’ì„ ì‚¬ìš©í•˜ê³  ì‹¶ìœ¼ë©´ ì–´ë–¤ ì¼ì´ ë°œìƒí•˜ëŠ”ê°€? ( 18 : 45 )
- Stencil ê¸°ëŠ¥ì— ëŒ€í•´ ì„¤ëª…í•˜ë©´? ( 19 : 40 )
- Depth Stencil View BufferëŠ” ëª‡ê°œë¥¼ ë§Œë“¤ì–´ ì¤˜ì•¼ í•˜ëŠ”ê°€? 1ê°œ ( 25 : 28 )
- Depthì™€ Stencilê°’ì„ ëª¨ë‘ ì‚¬ìš©í•˜ë ¤ë©´ ì–´ë–¤ í˜•ì‹ìœ¼ë¡œ ë²„í¼ë¥¼ ë§Œë“¤ì–´ ì¤˜ì•¼ í•˜ëŠ”ê°€? ( 26 : 00 )
- ìœˆë„ìš° í™”ë©´ì´ 800 X 600 ì´ë¼ë©´ Depth Stencil Bufferì˜ í¬ê¸°ëŠ” ì–´ë–»ê²Œ ì§€ì •í•´ì•¼ í•˜ëŠ”ê°€? ( 27 : 30 )

```cpp
// D3D12Pipelinestate.cpp

static FD3D12LowLevelGraphicsPipelineStateDesc GetLowLevelGraphicsPipelineStateDesc(const FGraphicsPipelineStateInitializer& Initializer, const FD3D12RootSignature* RootSignature)
{
	// DepthStencilState ì„¸íŒ…
	FD3D12LowLevelGraphicsPipelineStateDesc Desc{};
	Desc.Desc.DepthStencilState = Initializer.DepthStencilState ? CD3DX12_DEPTH_STENCIL_DESC1(FD3D12DynamicRHI::ResourceCast(Initializer.DepthStencilState)->Desc) : CD3DX12_DEPTH_STENCIL_DESC1(D3D12_DEFAULT);
}
```

```cpp
// WindowsD3D12PipelineState.cpp

FD3D12_GRAPHICS_PIPELINE_STATE_STREAM FD3D12_GRAPHICS_PIPELINE_STATE_DESC::PipelineStateStream() const
{
	// DepthStencilState ì„¸íŒ…
	FD3D12_GRAPHICS_PIPELINE_STATE_STREAM Stream = {};
	Stream.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC1(this->DepthStencilState);
}

FD3D12_MESH_PIPELINE_STATE_STREAM FD3D12_GRAPHICS_PIPELINE_STATE_DESC::MeshPipelineStateStream() const
{
	// DepthStencilState ì„¸íŒ…
	FD3D12_MESH_PIPELINE_STATE_STREAM Stream{};
	Stream.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC1(this->DepthStencilState);
}
```

## Chapter 2 Component

### 02-1 Inputê³¼ Timer
- ì¤‘ìš”í•œ ë‚´ìš© ì—†ìŒ

### 02-2 Material
- Material ì´ë€ ë¬´ì—‡ì¸ê°€? ë‚´ê°€ ì‚¬ìš©í•  Shaderì™€ í•´ë‹¹ Shaderì—ì„œ ì‚¬ìš©í•  ì¸ì(Texture2D, SamplerState, POSITION, COLOR, TEXCOORD ë“±ë“±) ê¹Œì§€ ëª¨ë‘ í¬í•¨í•´ í•˜ë‚˜ì˜ í´ë˜ìŠ¤ë¡œ ê´€ë¦¬ í•˜ëŠ”ê²ƒ ( 07 : 52 )
- Shaderì—ì„œ ì‚¬ìš©í•  ì¸ìëŠ” ì–´ë””ë¡œ ì „ë‹¬ë ê¹Œ? GPU Registers ( 25 : 40 )
- GPU Registers ì—ì„œ í…ìŠ¤ì³ë¥¼ ëª‡ê°œ í™œìš©í•  ê²ƒì´ë¼ëŠ” ë‚´ìš©ì€ ì–´ë””ì— ë“±ë¡ë˜ì–´ ìˆëŠ”ê°€? RootSignature ( 26 : 58 )
- Material ê°œë…ì˜ ì¥ì ì€? ì˜¤ë¸Œì íŠ¸ ë“¤ì´ í•˜ë‚˜ì˜ Materialì„ ê³µìœ í•  ìˆ˜ ìˆë‹¤ ( 40 : 38 )

### 02-3 Component
- GameObjectë¥¼ weak_ptrë¡œ ê°–ëŠ” ì´ìœ ëŠ”? ì»´í¬ë„ŒíŠ¸ì™€ ìƒí˜¸ ì°¸ì¡° í•˜ëŠ”ê²ƒì„ ë§‰ê¸°ìœ„í•´ ( 22 : 06 )

### 02-4 Scene
- Sceneê³¼ GameObjectëŠ” ì–´ë–¤ ê´€ê³„ì¸ê°€? has-a ê´€ê³„

## Chapter 3 Vector and Matrix

### 03-1 ì‚¼ê°í•¨ìˆ˜
- í•¨ìˆ˜ë¼ëŠ” ì •ì˜ë¥¼ ì¶©ì¡±ì‹œí‚¤ê¸° ìœ„í•œ arccos, arcsin, arctanì˜ ê°ë„ ë²”ìœ„ëŠ” ì–´ë–»ê²Œ ë˜ëŠ”ê°€? arccosë§Œ 0 ~ ğ… ë‚˜ë¨¸ì§€ëŠ” -ğ…/2 ~ ğ…/2 ( 34 : 40 )
- ì½”ì‚¬ì¸ ë§ì…ˆ ì •ë¦¬ëŠ” ì–¸ì œ í™œìš© ë˜ëŠ”ê°€? íšŒì „ í–‰ë ¬ì„ ë§Œë“¤ë•Œ ( 42 : 48 )

### 03-2 ë²¡í„°
- ë²¡í„°ë¼ë¦¬ ê³±ì…ˆê³¼ ë‚˜ëˆ—ì…ˆì´ ê°€ëŠ¥í•œê°€? ì•„ë‹ˆì˜¤ ( 13 : 47 )
- ë²¡í„°ì™€ ìŠ¤ì¹¼ë¼ ê°„ì˜ ê³±ì…ˆê³¼ ë‚˜ëˆ—ì…ˆì´ ê°€ëŠ¥í•œê°€? ì˜ˆ ( 13 : 47 )
- ë‹¨ìœ„ ë²¡í„°ë¥¼ ë§Œë“œëŠ” ë°©ë²•ì€? ì›ë˜ ë²¡í„°ì˜ ê° ì„±ë¶„ì— í¬ê¸°ê°’ì„ ë‚˜ëˆ ì¤€ë‹¤ ( 24 : 30 )
- ì™¸ì ì€ êµí™˜ ë²•ì¹™ì´ ì„±ë¦½ í•˜ëŠ”ê°€? ì•„ë‹ˆì˜¤ ( 46 : 11 )

### 03-3 í–‰ë ¬
- í–‰ë ¬ì„ ê³±í•˜ê¸° ìœ„í•œ ì¡°ê±´ì€? ì„ í–‰ë ¬ì˜ ì—´ê³¼ í›„í–‰ë ¬ì˜ í–‰ì´ ê°™ì•„ì•¼ í•œë‹¤ ( 09 : 38 )
- í–‰ë ¬ì„ ê³±í•œ ê²°ê³¼ëŠ”? ì„ í–‰ë ¬ì˜ í–‰ì˜ ê°œìˆ˜ì™€ í›„í–‰ë ¬ì˜ ì—´ì˜ ê°œìˆ˜ì— í•´ë‹¹í•˜ëŠ” ìƒˆë¡œìš´ í–‰ë ¬ì„ ë§Œë“ ë‹¤ ( 10 : 08 )

### 03-4 Scale, Rotation, Translation ë³€í™˜ í–‰ë ¬
- ì´ë²ˆ ê°•ì¢Œì˜ ì£¼ ë‚´ìš©ì€? Scale, Rotation, Translation ë³€í™˜ í–‰ë ¬ì´ ì–´ë–»ê²Œ ë§Œë“¤ì–´ ì§€ëŠ”ì§€ ì„¤ëª… ( 04 : 19 )
- wë¥¼ ì¶”ê°€í•´ ì‚¬ìš©í•˜ëŠ” ì¢Œí‘œê³„ë¥¼ ë­ë¼ê³  í•˜ëŠ”ê°€? ë™ì°¨ ì¢Œí‘œê³„ ( 06 : 03 )
- ìºë¦­í„° ë°œ ë°‘ì„ ì›ì ìœ¼ë¡œ ì¡ëŠ” ì´ìœ ëŠ”? ìºë¦­í„° ì‚¬ì´ì¦ˆê°€ ì»¤ì ¸ë„ ë•…ì†ì— ë“¤ì–´ê°€ì§€ ì•Šê²Œ í•˜ê¸°ìœ„í•´ ( 18 : 53 )

### 03-5 ì¢Œí‘œê³„ ë³€í™˜ í–‰ë ¬
- ì¢Œí‘œê³„ ë³€í™˜ í–‰ë ¬ì˜ ì—­í• ì€? ìƒˆë¡œìš´ ì¢Œí‘œê³„ì—ì„œ ì›ë˜ ì¢Œí‘œê³„ì˜ íŠ¹ì • ì¢Œí‘œê°€ ì–´ë–»ê²Œ ë³€í• ì§€ ì•Œ ìˆ˜ ìˆë‹¤ ( 03 : 56 )
- ë³€í™” í•˜ë ¤ëŠ” ëŒ€ìƒì´ ìœ„ì¹˜ ë²¡í„°ì´ë©´ (x,y,z,?) ì—ì„œ ë¬¼ìŒí‘œì— ë“¤ì–´ê°ˆ ê°’ì€? 1 ( 21 : 27 )
- ë³€í™” í•˜ë ¤ëŠ” ëŒ€ìƒì´ ë°©í–¥ ë²¡í„°ì´ë©´ (x,y,z,?) ì—ì„œ ë¬¼ìŒí‘œì— ë“¤ì–´ê°ˆ ê°’ì€? 0 ( 21 : 27 )

### 03-6 World, View ë³€í™˜ í–‰ë ¬
- World ë³€í™˜ í–‰ë ¬ì€ ì–´ë–¤ í–‰ë ¬ì„ ì‘ìš©í–ˆëŠ”ê°€? ì¢Œí‘œê³„ ë³€í™˜ í–‰ë ¬
- World ë³€í™˜ í–‰ë ¬ì—ëŠ” ì–´ë–¤ ì •ë³´ê°€ ìˆëŠ”ê°€? ë³€í™”í•  Position, Rotation, Scale ( 31 : 49 )
- View ë³€í™˜ í–‰ë ¬ì´ë€? ì¹´ë©”ë¼ ì›”ë“œ í–‰ë ¬ì˜ ì—­í–‰ë ¬ ( 48 : 53 )
- View ë³€í™˜ í–‰ë ¬ì˜ ì—­í• ì€? ì¹´ë©”ë¼ë¥¼ ì›ì ì— ë°°ì¹˜í•˜ê³ , ê·¸ì— ë”°ë¼ ë‹¤ë¥¸ ì‚¬ë¬¼ë“¤ì„ ì•Œë§ê²Œ ì¬ë°°ì¹˜ í•´ì¤€ë‹¤

### 03-7 Projection, Screen ë³€í™˜ í–‰ë ¬
- nearì™€ farì˜ ì—­í• ì€? í•´ë‹¹ ì˜ì—­ ì•ˆì˜ ë¬¼ì²´ë§Œ ì¹´ë©”ë¼ì— ì°íˆê²Œ í•´ì¤€ë‹¤ ( 08 : 52 )
- ì¹´ë©”ë¼ì˜ ì‹œì•¼ë¥¼ ë„“í˜€ì£¼ê¸° ìœ„í•´ì„œëŠ” ì–´ë–¤ ê²ƒì„ ì¡°ì ˆí•´ì•¼ í•˜ëŠ”ê°€? FOV ( 10 : 33 )
- x, y ì¢Œí‘œë¥¼ z ê°’ì— ë”°ë¼ ì •ê·œí™” ì‹œì¼œì£¼ëŠ” ë°©ë²•ì€? x, y ì¢Œí‘œë¥¼ z ê°’ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ì¤€ë‹¤ ( 14 : 18 )
- Projectionì„ í•˜ê¸°ìœ„í•´ z ê°’ì„ 0~1ë¡œ ë§Œë“¤ì–´ ì¤˜ì•¼í•œë‹¤ ì´ë•Œ z ê°’ì„ ë³´ì¡´í•˜ëŠ” ë°©ë²•ì€? w ì¢Œí‘œì— z ê°’ì„ ê¸°ë¡í•´ë‘”ë‹¤ ( 25 : 37 )
- w ì¢Œí‘œì— ê¸°ë¡í•´ë‘” ê°’ì„ í™œìš©í•´ x, y, z ì¢Œí‘œë¥¼ ë‚˜ëˆ„ì–´ ì£¼ëŠ” ë‹¨ê³„ëŠ”? ë ˆìŠ¤í„° ë¼ì´ì € ( 28 : 29 )
- Normalized Coordination Spaceì˜ ë²”ìœ„ëŠ”? x, y ê°ê° -1 ì—ì„œ 1 ( 35 : 56 )
- Normalized Coordination Space ë‹¤ìŒ SpaceëŠ” ë¬´ì—‡ì¸ê°€? ViewPort, ì°¸ê³ ë¡œ ì´ ì˜ì—­ì˜ ë²”ìœ„ëŠ” (0,0) ì—ì„œ (800,600) ì´ëŸ°ì‹ì„
- ViewPortì˜ MinDepthì™€ MaxDepthë¥¼ ì–´ë–»ê²Œ ì‘ìš©í•  ìˆ˜ ìˆëŠ”ê°€? ë·°í¬íŠ¸ë¥¼ ì—¬ëŸ¬ê°œ ë§Œë“¤ì—ˆì„ë•Œ ì¦‰ ë Œë” íƒ€ê²Ÿì´ ì—¬ëŸ¬ê°œ ì¼ë•Œ ê°ê°ì˜ MinDepthì™€ MaxDepthë¥¼ ì„¤ì •í•´ ì¤„ ìˆ˜ ìˆë‹¤ ( 45 : 03 )

## Chapter 4 Camera and Lighting

### 04-1 Camera
- í–‰ë ¬ ì •ë³´ì—ì„œ ê°í–‰ì´ ì˜ë¯¸í•˜ëŠ” ë°”ëŠ”? 1í–‰ì€ Right 2í–‰ì€ Up 3í–‰ì€ Look 4í–‰ì€ Translation ( 02 : 10 )
- í–‰ë ¬ ì—°ì‚°ì„ ìµœì í™” í•˜ëŠ”ë° ì“°ì´ëŠ” ê¸°ë²•ì€? SIMD ( 03 : 29 )

### 04-2 Resources
- ì¤‘ìš”í•œ ë‚´ìš© ì—†ìŒ

### 04-3 Lighting 1
- Ambiet, Diffuse, Specular, Emissiveì˜ ê° íŠ¹ì§•ê³¼ ì—°ì‚°ê³¼ì •ì„ ì„¤ëª…í•˜ë©´? ([**ì°¸ê³ **](https://velog.io/@sham/miniRT-%ED%95%B5%EC%8B%AC%EA%B0%9C%EB%85%90-%ED%90%81-%EC%A1%B0%EB%AA%85-%EB%AA%A8%EB%8D%B8))
- Specular ë°˜ì‚¬ê´‘ ë²¡í„°ë¥¼ êµ¬í•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•˜ë©´? ( 27 : 32 )

### 04-4 Lighting 2
- LightëŠ” í•œ í”„ë ˆì„ë‹¹ ëª‡ë²ˆ ì„¸íŒ… ë˜ëŠ”ê°€? í•œë²ˆ, Lightê°€ ì—¬ëŸ¬ê°œë¼ë„ ë§ˆì°¬ê°€ì§€ ( 11 : 44 )
- desc.table ë°©ì‹ì˜ ë‹¨ì ì€? ìš”ì†Œë“¤ì„ ê°œë³„ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ í•´ì¤„ìˆ˜ ì—†ë‹¤ ( 12 : 56 )
- ìœ„ì˜ ë‹¨ì  ë•Œë¬¸ì— Lightì™€ ê°™ì´ ì „ì—­ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ê²ƒë“¤ì€ ì–´ë–¤ ë°©ì‹ì„ ì‚¬ìš©í•˜ëŠ”ê°€? root CBVë¥¼ í™œìš©í•œë‹¤ ( 13 : 57 )

```cpp
// MeshPaintVertexShader.usf

// ì´ íŒŒì¼ì´ í—¤ë” ì—­í• ì„ í•˜ëŠ”ê²ƒ ê°™ë‹¤
#include "Common.ush"

// ì´ ë³€ìˆ˜ëŠ” global variable ì´ë‹¤
// í•œ í”„ë ˆì„ë‹¹ í•œë²ˆë§Œ ì„¸íŒ…ë  ê²ƒì´ë‹¤
float4x4 c_Transform;

void Main( float4 InPosition : ATTRIBUTE0,
		   float2 InCloneTextureCoordinates : ATTRIBUTE2,
		   float3 InWorldSpaceVertexPosition : ATTRIBUTE3,
		   out float4 OutPosition : SV_POSITION,
		   out float2 OutCloneTextureCoordinates: TEXCOORD0,
		   out float3 OutWorldSpaceVertexPosition : TEXCOORD1 )
{
	// Position (on texture map, derived from the UVs of the original mesh)
	OutPosition = mul( InPosition, c_Transform );

	// Pass clone texture coordinates through to the pixel shader
	OutCloneTextureCoordinates = InCloneTextureCoordinates;

	// Position of this vertex in world space (original mesh)
	OutWorldSpaceVertexPosition = InWorldSpaceVertexPosition;
}
```

- Packing Rulesì— ëŒ€í•´ì„œ ì„¤ëª…í•˜ë©´? 4ë°”ì´íŠ¸ ë‹¨ìœ„ë¡œ íŒ¨í‚¹ë˜ê³ , 16ë°”ì´íŠ¸ ë°”ìš´ë”ë¦¬ë¥¼ ë„˜ì–´ê°ˆ ìˆ˜ ì—†ë‹¤ í•˜ì§€ë§Œ USF ì—ì„œëŠ” ë¬´ì–¸ê°€ ì²˜ë¦¬ë¥¼ í•´ì¤˜ì„œ ì´ ê·œì¹™ì„ ì§€í‚¬ í•„ìš”ê°€ ì—†ëŠ”ê²ƒ ê°™ë‹¤ ( 41 : 26 ) ([**ì°¸ê³ **](https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-packing-rules))

### 04-5 Lighting 3
- 

<br>

[ë§¨ ìœ„ë¡œ ì´ë™í•˜ê¸°](#){: .btn .btn--primary }{: .align-right}
