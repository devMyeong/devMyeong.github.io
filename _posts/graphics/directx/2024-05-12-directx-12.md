---
title:  "Unreal Engine 5.2"

categories:
  - DirectX 12
tags:
  - []

comments: true

toc: true
toc_sticky: true

date: 2024-05-10
last_modified_at: 2024-05-10
---

## Chapter 1 DirectX12 ì´ˆê¸°í™”

### 01-1 í”„ë¡œì íŠ¸ ì„¤ì •
- ë Œë”ë§ íŒŒì´í”„ë¼ì¸, Diffuse, Ambient, Specular, Double Buffering, Tangent Space, ê·¸ë¦¼ì ì›ë¦¬, ì§ë²Œë½ í˜„ìƒ, ì¿¼í„°ë‹ˆì–¸ì´ ì¤‘ìš”í•˜ë‹¤
- CPUì™€ GPUì˜ ê°€ì¥í° ì°¨ì´ëŠ”? ALU ê°œìˆ˜

```cpp
// LaunchWindows.cpp

int32 WINAPI WinMain(_In_ HINSTANCE hInInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ char* pCmdLine, _In_ int32 nCmdShow)
{
	// ì—¬ê¸°ê°€ ì–¸ë¦¬ì–¼ì´ ì‹œì‘ë˜ëŠ” ë¶€ë¶„ì´ë‹¤
	int32 Result = LaunchWindowsStartup(hInInstance, hPrevInstance, pCmdLine, nCmdShow, nullptr);
}
```

```cpp
// Launch.cpp

int32 GuardedMain( const TCHAR* CmdLine )
{
	#if WITH_EDITOR
	if (GIsEditor)
	{
		// ì´ ì•ˆì—ì„œ ì—”ì§„ì„ ì…‹ì—…í•œë‹¤ ( ì†”ë£¨ì…˜ êµ¬ì„±ì—ì„œ Editor ëª¨ë“œë¥¼ ì„ íƒí•˜ë©´ ì´ê³³ì´ í˜¸ì¶œëœë‹¤ )
		ErrorLevel = EditorInit(GEngineLoop);
	}
	#endif
	
	if (!GUELibraryOverrideSettings.bIsEmbedded)
	{
		// ì´ ì•ˆì—ì„œ ì—”ì§„í‹±ì´ ëŒê³ ìˆë‹¤
		while( !IsEngineExitRequested() )
		{
			EngineTick();
		}
	}
}
```

```cpp
// WindowsPlatformApplicationMisc.cpp

void FWindowsPlatformApplicationMisc::PumpMessages(bool bFromMainLoop)
{
	// ì´ ì•ˆì—ì„œ PeekMessage ê°€ ì²˜ë¦¬ë˜ê³  ìˆë‹¤ ( bFromMainLoop == false )
	if (!bFromMainLoop)
	{
		FPlatformMisc::PumpMessagesOutsideMainLoop();
		return;
	}

	// ì´ ì•ˆì—ì„œ PeekMessage ê°€ ì²˜ë¦¬ë˜ê³  ìˆë‹¤ ( bFromMainLoop == true )
	GPumpingMessagesOutsideOfMainLoop = false;
	WinPumpMessages();
}
```

- ìì£¼ í™œìš©í•˜ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì¸í´ë£¨ë“œ í•˜ëŠ”ê²Œ ê·€ì°®ê¸° ë•Œë¬¸ì— ì‚¬ìš©í•˜ëŠ” í—¤ë”ëŠ”? ë¯¸ë¦¬ ì»´íŒŒì¼ëœ í—¤ë” ( 07 : 41 )
- ì–¸ë¦¬ì–¼ ì—”ì§„ì˜ pch.h íŒŒì¼ì„ ë³´ëŠ” ë°©ë²•ì€? ì†”ë£¨ì…˜ íƒìƒ‰ê¸°ì— pch.h ê²€ìƒ‰
- d3dx12.hì˜ íŠ¹ì§•ì€? ë§ˆì´í¬ë¡œì†Œí”„íŠ¸ ì—ì„œ ì œê³µí•´ì£¼ëŠ” ë¹„ê³µì‹ì ì¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ ( 27 : 30 )

![dir](https://github.com/devMyeong/devMyeong.github.io/assets/80055816/0800c9f0-153b-41fe-939b-e4eb9f040b8c){: width="100%" height="100%"}{: .align-center}

- ì¶”ê°€ ì¢…ì†ì„± ëŒ€ì‹  lib íŒŒì¼ì„ ì¶”ê°€í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì€? pragma comment í™œìš© ( 37 : 41 )

### 01-2 ì¥ì¹˜ ì´ˆê¸°í™”

```cpp
// Engine.h

/** Global engine pointer. Can be 0 so don't use without checking. */
extern ENGINE_API class UEngine*			GEngine;
```

```cpp
// WindowsApplication.cpp

int32 FWindowsApplication::ProcessMessage( HWND hwnd, uint32 msg, WPARAM wParam, LPARAM lParam )
{
	// ì´ ì•ˆì—ì„œ ìœˆë„ìš° ë©”ì‹œì§€ê°€ ì²˜ë¦¬ë˜ê³  ìˆë‹¤
	// FWindowsPlatformApplicationMisc í´ë˜ìŠ¤ì˜ WinPumpMessages() ì—ì„œ ë‚ ì•„ì˜¨ ë©”ì‹œì§€ ì´ë‹¤ ( ë‚ ì•„ì˜¤ëŠ” ì›ë¦¬ëŠ” ì½œë°± )
	// ì•„ë˜ ë©”ì‹œì§€ ì—ì„œ ì²˜ë¦¬ë˜ê³  ìˆëŠ” ìë£Œí˜• ì¤‘ì— WINDOWINFO ë¼ëŠ”ê²Œ ìˆëŠ”ë° ê·¸ë ¤ì§ˆ í™”ë©´ í¬ê¸°ì™€ ê´€ë ¨ì´ ìˆë‹¤
	switch(msg)
	{
		// ìœˆë„ìš° ì‚¬ì´ì¦ˆ ì¡°ì •í•˜ëŠ” ì´ë²¤íŠ¸
		case WM_SIZING:
	}
}
```

```cpp
// D3D12Commands.cpp

void FD3D12CommandContext::RHISetViewport(float MinX, float MinY, float MinZ, float MaxX, float MaxY, float MaxZ)
{
	// ê·¸ë ¤ì§ˆ í™”ë©´ í¬ê¸° ê´€ë ¨ ( D3D12_VIEWPORT )
	D3D12_VIEWPORT Viewport = { MinX, MinY, (MaxX - MinX), (MaxY - MinY), MinZ, MaxZ };

}

void FD3D12CommandContext::RHISetScissorRect(bool bEnable, uint32 MinX, uint32 MinY, uint32 MaxX, uint32 MaxY)
{
	if (bEnable)
	{
		// ê·¸ë ¤ì§ˆ í™”ë©´ í¬ê¸° ê´€ë ¨ ( CD3DX12_RECT )
		const CD3DX12_RECT ScissorRect(MinX, MinY, MaxX, MaxY);
		StateCache.SetScissorRect(ScissorRect);
	}
}

void FD3D12CommandContext::RHIDrawPrimitive(uint32 BaseVertexIndex, uint32 NumPrimitives, uint32 NumInstances)
{
	// ë™ì¼í•œ ì •ì  ë°ì´í„° ì§‘í•©ì„ ì—¬ëŸ¬ ì¸ìŠ¤í„´ìŠ¤ë¡œ ë Œë”ë§í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤ ( ì¸ìŠ¤í„´ì‹± ê¸°ìˆ  )
	// ë™ì¼í•œ ê°ì²´ë¥¼ ì—¬ëŸ¬ ë²ˆ ê·¸ë¦¬ê±°ë‚˜, ë™ì¼í•œ ë©”ì‰¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ë‹¤ì–‘í•œ ìœ„ì¹˜ë‚˜ ì†ì„±ìœ¼ë¡œ ë Œë”ë§í•  ë•Œ ìœ ìš©í•©ë‹ˆë‹¤
	// ì´ ë‹¨ê³„ë¥¼ ê±°ì¹˜ë©´ ì •ì  ì •ë³´ê°€ Input Assembler ë‹¨ê³„ë¡œ ë„˜ì–´ê°„ë‹¤
	// Vertex Bufferë§Œ í™œìš©í•´ ê·¸ë¦¬ëŠ” í•¨ìˆ˜ì´ë‹¤ ( NumInstances ì—ì„œ ëª‡ê°œì˜ ë¬¼ì²´ë¥¼ ê·¸ë¦´ì§€ ì •í•œë‹¤ )
	GraphicsCommandList()->DrawInstanced(VertexCount, NumInstances, BaseVertexIndex, 0);
}

void FD3D12CommandContext::RHIDrawIndexedPrimitive(FRHIBuffer* IndexBufferRHI, int32 BaseVertexIndex, uint32 FirstInstance, uint32 NumVertices, uint32 StartIndex, uint32 NumPrimitives, uint32 NumInstances)
{
	// Vertex Bufferì™€ Index Bufferë¥¼ í•¨ê»˜ í™œìš©í•´ ê·¸ë¦¬ëŠ” í•¨ìˆ˜ì´ë‹¤
	GraphicsCommandList()->DrawIndexedInstanced(IndexCount, NumInstances, StartIndex, BaseVertexIndex, FirstInstance);
}

void FD3D12CommandContext::RHIClearMRTImpl(bool* bClearColorArray, int32 NumClearColors, const FLinearColor* ClearColorArray, bool bClearDepth, float Depth, bool bClearStencil, uint32 Stencil)
{
	if (ClearRTV)
	{
		for (int32 TargetIndex = 0; TargetIndex < BoundRenderTargets.GetNumActiveTargets(); TargetIndex++)
		{
			FD3D12RenderTargetView* RTView = BoundRenderTargets.GetRenderTargetView(TargetIndex);

			if (RTView != nullptr && bClearColorArray[TargetIndex])
			{
				// Render Target View ì´ˆê¸°í™” ( ClearColorArray[TargetIndex] ìƒ‰ê¹”ë¡œ ë°°ê²½ì„ ë°€ì–´ì¤€ë‹¤ )
				GraphicsCommandList()->ClearRenderTargetView(RTView->GetOfflineCpuHandle(), (float*)&ClearColorArray[TargetIndex], ClearRectCount, pClearRects);
				UpdateResidency(RTView->GetResource());
			}
		}
	}

	if (ClearDSV)
	{
		// Depth Stencil View ì´ˆê¸°í™” ( D3D12_CLEAR_FLAGSë¥¼ í™œìš©í•´ Depthë§Œ ì´ˆê¸°í™” í• ê²ƒì¸ì§€, Stencilë„ ê°™ì´ ì´ˆê¸°í™” í• ê²ƒì¸ì§€ ì •í•´ì¤„ ìˆ˜ ìˆë‹¤ )
		GraphicsCommandList()->ClearDepthStencilView(DepthStencilView->GetOfflineCpuHandle(), (D3D12_CLEAR_FLAGS)ClearFlags, Depth, Stencil, ClearRectCount, pClearRects);
		UpdateResidency(DepthStencilView->GetResource());
	}
}
```

```cpp
// D3D12Adapter.h
// D3D12Adapter.cpp

class FD3D12Adapter : public FNoncopyable
{
	// ê°ì¢… ê°ì²´ ìƒì„±, D3D12CreateDevice() í•¨ìˆ˜ë¥¼ í™œìš©í•´ ì´ˆê¸°í™” í•œë‹¤
	FORCEINLINE ID3D12Device* GetD3DDevice() const { return RootDevice; }

	// í™”ë©´ ê´€ë ¨ ê¸°ëŠ¥ë“¤, CreateDXGIFactory() í•¨ìˆ˜ë¥¼ í™œìš©í•´ ì´ˆê¸°í™” í•œë‹¤
	FORCEINLINE IDXGIFactory2* GetDXGIFactory2() const { return DxgiFactory2; }
}

void FD3D12Adapter::CreateRootDevice(bool bWithDebug)
{
	// ë””ë²„ê·¸ ( IID_PPV_ARGS ë§¤í¬ë¡œëŠ” ìì£¼ ì´ìš©ëœë‹¤ )
	TRefCountPtr<ID3D12Debug> DebugController;
	if (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(DebugController.GetInitReference()))))
	{
		DebugController->EnableDebugLayer();
	}
}

void FD3D12Adapter::InitializeDevices()
{
	// 01-5 Root Signatureì— ìˆëŠ” ì´ë¯¸ì§€ì—ì„œ desc.tableì„ ì„¸íŒ…í•´ì£¼ëŠ” ì½”ë“œ
	D3D12_DESCRIPTOR_HEAP_DESC TempHeapDesc{};

	// Constant Buffer View, Shader Resource View, Unordered Access Buffer
	TempHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	TempHeapDesc.NumDescriptors = 2 * D3D12_MAX_SHADER_VISIBLE_DESCRIPTOR_HEAP_SIZE_TIER_2;

	// DX11ì˜ RenderTargetView, DepthStencilView ë“±ë“±ì„ ì´ì œ í†µí•©ì ìœ¼ë¡œ ê´€ë¦¬í•œë‹¤ ( ID3D12DescriptorHeap )
	// ë Œë” íƒ€ê²Ÿ ì •ë³´ì¸ ID3D12Resourceë¥¼ ì§ì ‘ ì ‘ê·¼ í•˜ëŠ” ëŒ€ì‹  ID3D12DescriptorHeapë¥¼ í™œìš©í•´ ê°„ì ‘ ì ‘ê·¼ í•˜ì
	TRefCountPtr<ID3D12DescriptorHeap> TempHeap;

	// ë°°ì—´ í˜•íƒœë¡œ ê´€ë¦¬ë˜ëŠ” TempHeap.GetInitReference() ê°€ ë§Œë“¤ì–´ ì§„ë‹¤
	HRESULT hr = RootDevice->CreateDescriptorHeap(&TempHeapDesc, IID_PPV_ARGS(TempHeap.GetInitReference()));
}
```

```cpp
// D3D12Device.h
// D3D12Device.cpp

class FD3D12Queue final
{
public:
	// ì¼ê°ì„ ì°¨ê³¡ì°¨ê³¡ ê¸°ë¡í–ˆë‹¤ê°€ í•œ ë°©ì— ìš”ì²­í•˜ëŠ” ê³³
	// ID3D12CommandAllocator, ID3D12GraphicsCommandList ì™€ ì¹œêµ¬ ( ID3D12GraphicsCommandListëŠ” Close í•¨ìˆ˜ë¥¼ í™œìš©í•´ ë¬´ì—‡ì„ ì œì¶œí•œë‹¤ )
	TRefCountPtr<ID3D12CommandQueue> D3DCommandQueue;
}

void FD3D12Device::UpdateConstantBufferPageProperties()
{
	//In genera, constant buffers should use write-combine memory (i.e. upload heaps) for optimal performance
	bool bForceWriteBackConstantBuffers = false;

	if (bForceWriteBackConstantBuffers)
	{
		ConstantBufferPageProperties = GetDevice()->GetCustomHeapProperties(0, D3D12_HEAP_TYPE_UPLOAD);
		ConstantBufferPageProperties.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_WRITE_BACK;
	}
	else
	{
		//-------------------------------------------------------------------
		// D3D12_HEAP_TYPE_UPLOAD í™ í˜•ì‹ì€
		// CPU-ì“°ê¸°-í•œ ë²ˆ, GPU ì½ê¸°-í•œ ë²ˆ ë°ì´í„°ì— ê°€ì¥ ì í•©í•©ë‹ˆë‹¤ ( MSDN )
		//-------------------------------------------------------------------
		ConstantBufferPageProperties = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD);
	}
}

void FD3D12Device::CreateDefaultViews()
{
	{
		D3D12_SHADER_RESOURCE_VIEW_DESC SRVDesc{};
		// Depth Stencil View ë¼ë©´ ì—¬ê¸°ì„œ Depthì™€ Stencil ì‚¬ìš© ì—¬ë¶€ ì„¸íŒ…ì´ ê°€ëŠ¥í•  ê²ƒì´ë‹¤
		SRVDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
		// ì—¬ê¸°ëŠ” 2D í˜•ì‹ì˜ ì´ë¯¸ì§€ê°€ ì„¸íŒ…ë˜ì—ˆëŠ”ë° ìŠ¤ì¹´ì´ ë°•ìŠ¤ ì´ë¯¸ì§€ ë“±ì„ ìœ„í•´
		// íë¸Œ í˜•ì‹ì˜ ì´ë¯¸ì§€ë„ ì„¸íŒ… ê°€ëŠ¥í•˜ë‹¤
		SRVDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
		SRVDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	}

	{
		// Render Target ì„¸íŒ…
		D3D12_RENDER_TARGET_VIEW_DESC RTVDesc{};
		RTVDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
		RTVDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;
		RTVDesc.Texture2D.MipSlice = 0;

		// Render Target ìƒì„±
		DefaultViews.NullRTV = new FD3D12ViewDescriptorHandle(this, ERHIDescriptorHeapType::RenderTarget);
		DefaultViews.NullRTV->CreateView(RTVDesc, nullptr);
	}
}
```

```cpp
// D3D12Viewport.h
// D3D12Viewport.cpp

class FD3D12FramePacing : public FRunnable, public FD3D12AdapterChild
{
private:
	// CPUì™€ GPU ë™ê¸°í™”ë¥¼ ìœ„í•œ ê°„ë‹¨í•œ ë„êµ¬
	TRefCountPtr<ID3D12Fence> Fence;
}

FD3D12Texture* GetSwapChainSurface(FD3D12Device* Parent, EPixelFormat PixelFormat, uint32 SizeX, uint32 SizeY, IDXGISwapChain* SwapChain, uint32 BackBufferIndex, TRefCountPtr<ID3D12Resource> BackBufferResourceOverride)
{
	// Grab the back buffer
	TRefCountPtr<ID3D12Resource> BackBufferResource;
	if (SwapChain)
	{
#if D3D12_VIEWPORT_EXPOSES_SWAP_CHAIN
		// ì—¬ê¸°ì„œ ë Œë” íƒ€ê²Ÿ(Back Buffer)ê³¼ ìŠ¤ì™‘ì²´ì¸ì´ ì—°ë™ëœë‹¤
		VERIFYD3D12RESULT_EX(SwapChain->GetBuffer(BackBufferIndex, IID_PPV_ARGS(BackBufferResource.GetInitReference())), Parent->GetDevice());
#else // #if D3D12_VIEWPORT_EXPOSES_SWAP_CHAIN
	}
	else
	{
		// D3D12_HEAP_TYPE_DEFAULT í™ í˜•ì‹ì€ GPUì˜ ëŒ€ì—­í­ì„ ê°€ì¥ ë§ì´ ì‚¬ìš©í•˜ì§€ë§Œ
		// CPU ì•¡ì„¸ìŠ¤ë¥¼ ì œê³µí•  ìˆ˜ëŠ” ì—†ìŠµë‹ˆë‹¤ GPUëŠ” ì´ í’€ì—ì„œ ë©”ëª¨ë¦¬ë¥¼ ì½ê³  ì“¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤ ( MSDN )
		const D3D12_HEAP_PROPERTIES HeapProps = CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT, (uint32)Parent->GetGPUIndex(), Parent->GetGPUMask().GetNative());

		// Create custom back buffer texture as no swap chain is created in pixel streaming windowless mode
		// í”½ì…€ ìŠ¤íŠ¸ë¦¬ë° ëª¨ë“œì—ì„œ ìœˆë„ìš°ê°€ ì—†ëŠ” í™˜ê²½ì—ì„œëŠ” ìŠ¤ì™‘ ì²´ì¸(swap chain)ì´ ìƒì„±ë˜ì§€ ì•Šê¸° ë•Œë¬¸ì—
		// ì»¤ìŠ¤í…€ ë°± ë²„í¼ í…ìŠ¤ì²˜ë¥¼ ìƒì„±í•´ì•¼ í•œë‹¤
		D3D12_RESOURCE_DESC TextureDesc;

		// GPU RAMì— ì •ì  ì •ë³´ë“±ì„ ë³µì‚¬í•´ì£¼ê¸° ìœ„í•œ BUFFERë¥¼ ë§Œë“ ë‹¤, BackBufferResource.GetInitReference() ì´ê³³ì— ë§Œë“¤ì–´ ì§„ë‹¤
		// í•´ë‹¹ ê³µê°„ì— ìˆëŠ” ë°ì´í„°ì˜ ì£¼ì†ŒëŠ” GPU Registers ì—ê²Œ ë„˜ê²¨ì§ˆ ê²ƒì´ë‹¤
		// BackBufferResourceì˜ ìë£Œí˜•ì€ ID3D12Resourceì´ë‹¤ ì¦‰ í…ìŠ¤ì³ë„ ID3D12Resourceì— ë‹´ê¸´ë‹¤ëŠ” ì‚¬ì‹¤ì„ ì•Œ ìˆ˜ ìˆë‹¤
		Parent->GetDevice()->CreateCommittedResource(&HeapProps, D3D12_HEAP_FLAG_NONE, &TextureDesc, D3D12_RESOURCE_STATE_PRESENT, nullptr, IID_PPV_ARGS(BackBufferResource.GetInitReference()));
	}
}
```

```cpp
// D3D12Submission.cpp

FD3D12DynamicRHI::FProcessResult FD3D12DynamicRHI::ProcessInterruptQueue()
{
	if (InterruptThread && !CurrentQueue.Fence.bInterruptAwaited)
	{
		// ì—¬ê¸°ì„œ D3DFenceì™€ Eventë¥¼ í™œìš©í•´ ë™ê¸°í™” ìˆ˜í–‰ ( GPU ì‘ì—…ì´ ì™„ë£Œë  ë•Œ ê¹Œì§€ ê¸°ë‹¤ë¦°ë‹¤ )
		// ì´ê²ƒì´ ìˆìœ¼ë©´ Unmapì„ ì‚¬ìš©í•˜ì§€ ì•Šê³  ë™ê¸°í™”ê°€ ê°€ëŠ¥í•˜ë‹¤
		VERIFYD3D12RESULT(CurrentQueue.Fence.D3DFence->SetEventOnCompletion(Payload->CompletionFenceValue, InterruptThread->Event));
		CurrentQueue.Fence.bInterruptAwaited = true;
	}
}

FD3D12DynamicRHI::FProcessResult FD3D12DynamicRHI::ProcessSubmissionQueue()
{
	for (int32 Index = 0; Index < Payload->CommandListsToExecute.Num(); Index++)
	{
		// ì´ í•¨ìˆ˜ ì•ˆì—ì„œ BarrierCommandList->Close() ë¥¼ í†µí•´ ì¼ê°ë“¤ì„ ë§ˆê° ì²˜ë¦¬í•œë‹¤
		if (FD3D12CommandList* BarrierCommandList = GenerateBarrierCommandListAndUpdateState(CurrentCommandList))
		{
			FD3D12Queue& BarrierQueue = BarrierCommandList->Device->GetQueue(BarrierCommandList->QueueType);
	
			if (&BarrierQueue == &CurrentQueue)
			{
				// ì¼ê°ë“¤ ì‹¤í–‰ ìš”ì²­, ì´í›„ì— PayloadToSubmit->CommandListsToExecute.Reset() í•¨ìˆ˜ë¥¼ í™œìš©í•´ Reset í•œë‹¤
				BarrierQueue.PayloadToSubmit->CommandListsToExecute.Insert(BarrierCommandList, Index++);
			}
		}
	}
}
```

```cpp
// D3D12View.cpp

void FD3D12ViewDescriptorHandle::CreateView(const D3D12_RENDER_TARGET_VIEW_DESC& Desc, ID3D12Resource* Resource)
{
	// ë Œë” íƒ€ê²Ÿì´ Resource ì— ë‹´ê¸´ë‹¤ ( ë Œë” íƒ€ê²Ÿì€ ìŠ¤ì™‘ì²´ì¸ì— í™œìš©ë˜ëŠ” BackBufferë¥¼ ì˜ë¯¸í•˜ëŠ” ë“¯ )
	GetParentDevice()->GetDevice()->CreateRenderTargetView(Resource, &Desc, OfflineCpuHandle);
}

void FD3D12ViewDescriptorHandle::CreateView(const D3D12_DEPTH_STENCIL_VIEW_DESC& Desc, ID3D12Resource* Resource)
{
	// DepthStencilView Bufferê°€ Resourceì— ë‹´ê¸´ë‹¤
	GetParentDevice()->GetDevice()->CreateDepthStencilView(Resource, &Desc, OfflineCpuHandle);
}

void FD3D12ViewDescriptorHandle::CreateView(const D3D12_CONSTANT_BUFFER_VIEW_DESC& Desc)
{
	// Constant Buffer View ìƒì„± ( ë””ë²„ê¹… í•´ë³´ë‹ˆ ì´ í•¨ìˆ˜ í˜¸ì¶œ ì•ˆë˜ê³  ìˆìŒ )
	GetParentDevice()->GetDevice()->CreateConstantBufferView(&Desc, OfflineCpuHandle);
}
```

```cpp
// WindowsD3D12Viewport.cpp

void FD3D12Viewport::Init()
{
	// ì´ ì•ˆì—ì„œ ìŠ¤ì™‘ì²´ì¸ ì„¸íŒ…ì´ ì´ë£¨ì–´ì§„ë‹¤
	bNeedSwapChain = !FParse::Param(FCommandLine::Get(), TEXT("RenderOffScreen"));
	if (bNeedSwapChain)
	{
		if (FD3D12DynamicRHI::GetD3DRHI()->IsQuadBufferStereoEnabled())
		{
			if (Factory2->IsWindowedStereoEnabled())
			{
				DXGI_SWAP_CHAIN_DESC1 SwapChainDesc1{};

				// ë²„í¼ ì¹´ìš´íŠ¸
				SwapChainDesc1.BufferCount = NumBackBuffers;
			}
		}
	}
}

HRESULT FD3D12Viewport::PresentInternal(int32 SyncInterval)
{
	if (SwapChain1)
	{
		// ì—¬ê¸°ì„œ SwapChainì— ê·¸ë ¤ì¤˜(Present)ê°€ ë“±ë¡ë˜ì–´ì•¼ í•˜ëŠ”ë° ë””ë²„ê¹… í•´ë³´ë‹ˆ í˜¸ì¶œ ì•ˆë¨
		return SwapChain1->Present(SyncInterval, Flags);
	}

	return S_OK;
}

// ìŠ¤ì™‘ ì²´ì¸ Present ëŒ€í•œ ë‚´ìš©ì´ ì—¬ê¸°ì„œ ì²˜ë¦¬ë˜ê³  ìˆëŠ”ë“¯
bool FD3D12Viewport::Present(bool bLockToVsync)
{
	if (!IsPresentAllowed())
	{
		return false;
	}

	FD3D12Adapter* Adapter = GetParentAdapter();
	
	for (uint32 GPUIndex : FRHIGPUMask::All())
	{
		FD3D12CommandContext& DefaultContext = Adapter->GetDevice(GPUIndex)->GetDefaultCommandContext();

		// Those are not necessarily the swap chain back buffer in case of multi-gpu
		FD3D12Texture* DeviceBackBuffer = DefaultContext.RetrieveObject<FD3D12Texture, FRHITexture2D>(GetBackBuffer_RHIThread());
		FD3D12Texture* DeviceSDRBackBuffer = DefaultContext.RetrieveObject<FD3D12Texture, FRHITexture2D>(GetSDRBackBuffer_RHIThread());

		// ì´ í•¨ìˆ˜ë¥¼ ì¶”ì í•´ë³´ë©´ FD3D12ResourceBarrierBatcher::AddTransition í•¨ìˆ˜ì™€ ì—°ê²°ëœë‹¤
		// ê·¸ë¦¬ê³  í•´ë‹¹ í•¨ìˆ˜ ì•ˆì— CD3DX12_RESOURCE_BARRIER::Transition í•¨ìˆ˜ ë¶€ë¶„ì´ ìˆë‹¤
		DefaultContext.TransitionResource(
			DeviceBackBuffer->GetShaderResourceView()->GetResource(),
			D3D12_RESOURCE_STATE_TBD,
			D3D12_RESOURCE_STATE_PRESENT, // í˜„ì¬ í™”ë©´ ì¶œë ¥
			0
		);

		if (SDRBackBuffer_RHIThread != nullptr)
		{
			DefaultContext.TransitionResource(
				DeviceSDRBackBuffer->GetShaderResourceView()->GetResource(),
				D3D12_RESOURCE_STATE_TBD,
				D3D12_RESOURCE_STATE_PRESENT, // í˜„ì¬ í™”ë©´ ì¶œë ¥
				0
			);
		}

		// Flushes the batched resource barriers to the current command list
		DefaultContext.FlushResourceBarriers();
	}
}
```

```cpp
// D3D12DescriptorCache.cpp

void FD3D12DescriptorCache::SetRenderTargets(FD3D12RenderTargetView** RenderTargetViewArray, uint32 Count, FD3D12DepthStencilView* DepthStencilTarget)
{
	for (uint32 i = 0; i < Count; i++)
	{
		if (RenderTargetViewArray[i] != NULL)
		{
			// D3D12_RESOURCE_STATE_RENDER_TARGET ê°€ ì˜ë¯¸í•˜ëŠ” ë°”ëŠ” ì™¸ì£¼ ê²°ê³¼ë¬¼
			Context.TransitionResource(RenderTargetViewArray[i], D3D12_RESOURCE_STATE_RENDER_TARGET);
		}

		if (DepthStencilTarget != nullptr)
		{
			// ì–´ë–¤ ë²„í¼ì— ê²°ê³¼ë¬¼ì„ ê·¸ë¦´ì§€ ì§€ì • ( HLSLì˜ SV_Target ë¶€ë¶„ê³¼ ë§ë¬¼ë ¤ì„œ ë™ì‘í•œë‹¤ )
			// RTVDescriptors ì—¬ê¸°ì— BackBufferViewê°€ ë“¤ì–´ê°€ê³ , DSVDescriptor ì—¬ê¸°ì— DepthStencilViewê°€ ë“¤ì–´ ê°€ëŠ”ë“¯
			Context.GraphicsCommandList()->OMSetRenderTargets(Count, RTVDescriptors, 0, &DSVDescriptor);
		}
	}
}

void FD3D12DescriptorCache::SetVertexBuffers(FD3D12VertexBufferCache& Cache)
{
	//-------------------------------------------------------------------------------------------
	// CurrentVertexBufferViewsì˜ ìë£Œí˜•ì€ D3D12_VERTEX_BUFFER_VIEW ì´ë‹¤
	// D3D12_VERTEX_BUFFER_VIEW ìë£Œí˜•ì€ D3D12_GPU_VIRTUAL_ADDRESSë¥¼ ê°€ì§€ê³  ìˆëŠ” êµ¬ì¡°ì²´ì´ë‹¤
	// IASetVertexBuffers í•¨ìˆ˜ë¡œ ë Œë”ë§ íŒŒì´í”„ë¼ì¸ì— GPU ê³µê°„ì„ ì—°ë™í•œë‹¤
	// ì¦‰ CurrentVertexBufferViewsë¥¼ ì´ìš©í•´ GPUì— ì •ì  ë°ì´í„°ë¥¼ ì „ë‹¬í•œë‹¤
	// Countê°€ ì˜ë¯¸í•˜ëŠ” ë°”ëŠ” ë²„í¼ì˜ ê°œìˆ˜ì´ë‹¤
	//-------------------------------------------------------------------------------------------
	Context.GraphicsCommandList()->IASetVertexBuffers(0, Count, Cache.CurrentVertexBufferViews);
}

void FD3D12DescriptorCache::SetRootConstantBuffers(EShaderFrequency ShaderStage, const FD3D12RootSignature* RootSignature, FD3D12ConstantBufferCache& Cache, CBVSlotMask SlotsNeededMask)
{
	if (ShaderStage == SF_Compute)
	{
		// SetComputeRootConstantBufferView
		// RootSignature ê´€ë ¨ Registers ì—ê²Œ í˜„ì¬ GPU RAM BUFFER ë°ì´í„° ì£¼ì†Œ(CurrentGPUVirtualAddress)ë¥¼ ë„˜ê²¨ì£¼ê³  ìˆë‹¤
		// GPU RAM BUFFERëŠ” ì—¬ëŸ¬ê°œ ì¼ ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ëª…ì‹¬í•˜ì ( 01-4 Constant Bufferì— ìˆëŠ” ì´ë¯¸ì§€ ì°¸ê³  )
		Context.GraphicsCommandList()->SetComputeRootConstantBufferView(BaseIndex + SlotIndex, CurrentGPUVirtualAddress);
	}
	else
	{
		// SetGraphicsRootConstantBufferView
		// RootSignature ê´€ë ¨ Registers ì—ê²Œ í˜„ì¬ GPU RAM BUFFER ë°ì´í„° ì£¼ì†Œ(CurrentGPUVirtualAddress)ë¥¼ ë„˜ê²¨ì£¼ê³  ìˆë‹¤
		// GPU RAM BUFFERëŠ” ì—¬ëŸ¬ê°œ ì¼ ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ëª…ì‹¬í•˜ì ( 01-4 Constant Bufferì— ìˆëŠ” ì´ë¯¸ì§€ ì°¸ê³  )
		Context.GraphicsCommandList()->SetGraphicsRootConstantBufferView(BaseIndex + SlotIndex, CurrentGPUVirtualAddress);
	}
}

void FD3D12DescriptorCache::SetUAVs(EShaderFrequency ShaderStage, const FD3D12RootSignature* RootSignature, FD3D12UnorderedAccessViewCache& Cache, const UAVSlotMask& SlotsNeededMask, uint32 SlotsNeeded, uint32& HeapSlot)
{
	// CPUì— ìˆëŠ” Desc.Heap ë‚´ìš©ì„ GUPì— ìˆëŠ” Desc.Heapìœ¼ë¡œ ì˜®ê²¨ì¤€ë‹¤
	GetParentDevice()->GetDevice()->CopyDescriptors(
		1, &DestDescriptor, &SlotsNeeded,
		SlotsNeeded, SrcDescriptors, nullptr /* sizes */,
		D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
}

bool FD3D12DescriptorCache::SetDescriptorHeaps(bool bForceHeapChanged)
{
	// Set the descriptor heaps.
	if (bHeapChanged)
	{
		// ì–´ë–¤ Heapì„ ì‚¬ìš©í•´ì¤„ ê²ƒì¸ì§€ ì§€ì • ( ë¬´ê±°ìš´ í•¨ìˆ˜ì—¬ì„œ í”„ë ˆì„ ë§ˆë‹¤ í•œë²ˆì”©ë§Œ í˜¸ì¶œí•´ì•¼ í•œë‹¤ )
		Context.GraphicsCommandList()->SetDescriptorHeaps(UE_ARRAY_COUNT(ppHeaps), ppHeaps);
	}
}
```

```cpp
// D3D12Resources.cpp

void FD3D12ResourceBarrierBatcher::FlushIntoCommandList(FD3D12CommandList& CommandList, FD3D12QueryAllocator& TimestampAllocator)
{
	// BarriersëŠ” D3D12_RESOURCE_BARRIER êµ¬ì¡°ë¡œ ë˜ì–´ìˆë‹¤
	// SwapChain ì •ë³´, D3D12_RESOURCE_STATE_PRESENT ì •ë³´, D3D12_RESOURCE_STATE_RENDER_TARGET ì •ë³´ê°€ ìˆì„ ìˆ˜ ìˆë‹¤
	CommandList.GraphicsCommandList()->ResourceBarrier(BatchEnd - BatchStart, &Barriers[BatchStart]);
}

// D3D12_CLEAR_VALUEëŠ” Depth Bufferë¥¼ ì´ˆê¸°í™” í•´ì¤„ë•Œ ë„£ì–´ì¤„ ê°’ì´ë‹¤
// ë³´í†µ 1.0fê°€ ì„¤ì •ë˜ëŠ”ë° ì´ëŠ” ì•„ë¬´ ë¬¼ì²´ë„ ê·¸ë¦¬ì§€ ì•Šì€ ìƒíƒœì´ë©° 0.fê°€ Min ê°’ì´ë‹¤
HRESULT FD3D12Adapter::CreateCommittedResource(const FD3D12ResourceDesc& InDesc, FRHIGPUMask CreationNode, const D3D12_HEAP_PROPERTIES& HeapProps, D3D12_RESOURCE_STATES InInitialState,
	ED3D12ResourceStateMode InResourceStateMode, D3D12_RESOURCE_STATES InDefaultState, const D3D12_CLEAR_VALUE* ClearValue, FD3D12Resource** ppOutResource, const TCHAR* Name, bool bVerifyHResult)
{
	// ìƒˆë¡œìš´ GPU ë¦¬ì†ŒìŠ¤ë¥¼ ìƒì„±í•˜ëŠ” ì—­í• ì„ í•˜ëŠ”ë“¯ í•˜ë‹¤
}

int32 FD3D12ResourceBarrierBatcher::AddTransition(FD3D12Resource* pResource, D3D12_RESOURCE_STATES Before, D3D12_RESOURCE_STATES After, uint32 Subresource)
{
	// ë Œë” íƒ€ê²Ÿ í…ìŠ¤ì³ ë“±ì„ ê°€ì ¸ì™€ Barrierì— ë‹´ì„ ê²ƒì´ë‹¤
	// í•´ë‹¹ ê°ì²´ëŠ” ìŠ¤ì™‘ì²´ì¸ í• ë•Œ ëœ ê·¸ë ¤ì¤€ ë²„í¼ê°€ ë Œë”ë§ ë˜ëŠ”ê²ƒì„ ë°©ì§€í•˜ëŠ” ìš©ë„ì´ë‹¤
	// ì¢€ ë” ìì„¸í•˜ê²Œ ì„¤ëª…í•˜ë©´ Before ìš©ë„ë¥¼ After ìš©ë„ë¡œ ë°”ê¿”ì¤„ ê²ƒì´ë‹¤
	FD3D12ResourceBarrier& Barrier = Barriers.Emplace_GetRef(CD3DX12_RESOURCE_BARRIER::Transition(pResource->GetResource(), Before, After, Subresource));
	if (pResource->IsBackBuffer() && EnumHasAnyFlags(After, BackBufferBarrierWriteTransitionTargets))
	{
		Barrier.Flags |= BarrierFlag_CountAsIdleTime;
	}
}
```

```cpp
D3D12StateCache.cpp

void FD3D12StateCache::ApplyState(ED3D12PipelineType PipelineType)
{
	// ì´ êµ¬ë¬¸ì— ë¸Œë ˆì´í¬ í¬ì¸íŠ¸ ì°ê³  ë“¤ì–´ê°€ë³´ë©´
	// CmdContext.GraphicsCommandList()->SetGraphicsRootSignature ì´ í•¨ìˆ˜ê°€ ì‚¬ìš©ë˜ì§€ ì•Šê³  ìˆë‹¤
	const bool bRootSignatureChanged = InternalSetRootSignature(PipelineType, PSOCommonData->RootSignature);

	if (bNeedSetViewports)
	{
		// ë·°í¬íŠ¸ ë“±ë¡
		CmdContext.GraphicsCommandList()->RSSetViewports(PipelineState.Graphics.CurrentNumberOfViewports, PipelineState.Graphics.CurrentViewport);
	}
	if (bNeedSetScissorRects)
	{
		// íŠ¹ì • ì˜ì—­ë§Œ ë Œë”ë§í•˜ê±°ë‚˜ ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•´ ì‚¬ìš©ë˜ëŠ” ì¤‘ìš”í•œ í•¨ìˆ˜
		CmdContext.GraphicsCommandList()->RSSetScissorRects(PipelineState.Graphics.CurrentNumberOfScissorRects, PipelineState.Graphics.CurrentScissorRects);
	}
	if (bNeedSetPrimitiveTopology)
	{
		// ì¸í’‹ ì–´ì…ˆë¸”ëŸ¬(Input Assembler, IA) ë‹¨ê³„ì— ì‚¬ìš©ë  ê¸°ë³¸ ë„í˜• í† í´ë¡œì§€ë¥¼ ì„¤ì •í•˜ëŠ” í•¨ìˆ˜
		CmdContext.GraphicsCommandList()->IASetPrimitiveTopology(PipelineState.Graphics.CurrentPrimitiveTopology);
	}
}

void FD3D12StateCache::InternalSetStreamSource(FD3D12ResourceLocation* VertexBufferLocation, uint32 StreamIndex, uint32 Stride, uint32 Offset)
{
	// Initialize the vertex buffer view ( View ë°ì´í„°ëŠ” CPUì™€ GPUê°€ ê³µìœ í•œë‹¤ )
	__declspec(align(16)) D3D12_VERTEX_BUFFER_VIEW NewView;
	// ë·°ì˜ ìœ„ì¹˜
	NewView.BufferLocation = (VertexBufferLocation) ? VertexBufferLocation->GetGPUVirtualAddress() + Offset : 0;
	// ì •ì  1ê°œ í¬ê¸°
	NewView.StrideInBytes = Stride;
	// ë²„í¼ì˜ í¬ê¸°
	NewView.SizeInBytes = (VertexBufferLocation) ? VertexBufferLocation->GetSize() - Offset : 0; // Make sure we account for how much we offset into the VB
}

void FD3D12StateCache::InternalSetPipelineState(FD3D12PipelineState* InPipelineState)
{
	ID3D12PipelineState* const PendingD3DPipelineState = InPipelineState->GetPipelineState();

	if (PipelineState.Common.bNeedSetPSO || CurrentD3DPipelineState == nullptr || CurrentD3DPipelineState != PendingD3DPipelineState)
	{
		// ìœ„ì˜ InternalSetStreamSource() í•¨ìˆ˜ì—ì„œ ë§Œë“  ì •ë³´ë¥¼ íŒŒì´í”„ ë¼ì¸ì— ë“±ë¡í•œë‹¤
		// ì•„ë§ˆ D3D12_INPUT_ELEMENT_DESC ì •ë³´ë„ ë“¤ì–´ìˆì„ ê²ƒì´ë‹¤
		CmdContext.GraphicsCommandList()->SetPipelineState(PendingD3DPipelineState);
	}
}

void FD3D12StateCache::InternalSetIndexBuffer(FD3D12Resource* Resource)
{
	// IndexBufferViewë¥¼ ì‚¬ìš©í•˜ì—¬ GPUì— ì¸ë±ìŠ¤ ë°ì´í„°ë¥¼ ì „ë‹¬í•œë‹¤
	CmdContext.GraphicsCommandList()->IASetIndexBuffer(&PipelineState.Graphics.IBCache.CurrentIndexBufferView);
}

void FD3D12StateCache::ApplySamplers(const FD3D12RootSignature* const pRootSignature, uint32 StartStage, uint32 EndStage)
{
	FD3D12UniqueSamplerTable* CachedTable = GlobalSamplerSet.Find(Table);
	if (CachedTable)
	{
		if (Stage == SF_Compute)
		{
			const uint32 RDTIndex = pRootSignature->SamplerRDTBindSlot(EShaderFrequency(Stage));

			// GPU ìª½ìœ¼ë¡œ Compute ì •ë³´ê°€ ë„˜ì–´ê°„ë‹¤
			CmdContext.GraphicsCommandList()->SetComputeRootDescriptorTable(RDTIndex, CachedTable->GPUHandle);
		}
		else
		{
			const uint32 RDTIndex = pRootSignature->SamplerRDTBindSlot(EShaderFrequency(Stage));

			// GPU ìª½ìœ¼ë¡œ ë¨¸í‹°ë¦¬ì–¼ ì •ë³´ê°€ ë„˜ì–´ê°„ë‹¤
			CmdContext.GraphicsCommandList()->SetGraphicsRootDescriptorTable(RDTIndex, CachedTable->GPUHandle);
		}
	}
}
```

### 01-3 ì‚¼ê°í˜• ë„ìš°ê¸°

```cpp
// D3D12RootSignature.h
// D3D12RootSignature.cpp

class FD3D12RootSignature : public FD3D12AdapterChild
{
	// RootSignatureë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” í•¨ìˆ˜ ( GPU ì—ê²Œ ê³„ì•½ì„œë¥¼ ê±´ë‚´ì£¼ëŠ” ì¼ì„ ë‹´ë‹¹í•œë‹¤ )
	ID3D12RootSignature* GetRootSignature() const { return RootSignature.GetReference(); }
}

//-----------------------------------------------------------------------------------------
// D3D12_VERSIONED_ROOT_SIGNATURE_DESC ì•ˆì— í”Œë˜ê·¸ ì •ë³´ë¥¼ ë³´ë©´
// D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT ì™€ ê°™ì€ ì •ë³´ì™€
// D3D12_ROOT_PARAMETER íƒ€ì… ë³€ìˆ˜ì— Registersë¥¼ ì–´ë–»ê²Œ í™œìš©í•  ê²ƒì¸ì§€ì— ëŒ€í•œ ì •ë³´ê°€ ìˆë‹¤
// ê°•ì¢Œì—ì„œëŠ” í•´ë‹¹ Registersë¥¼ Constant Buffer Viewë¡œ í™œìš©í–ˆë‹¤
// ì°¸ê³ ë¡œ INPUT_ASSEMBLER_INPUT_LAYOUT í”Œë˜ê·¸ëŠ” ì…ë ¥ ì¡°ë¦½ê¸° ë‹¨ê³„ë¥¼ ëœ»í•œë‹¤
//-----------------------------------------------------------------------------------------
void FD3D12RootSignature::Init(const D3D12_VERSIONED_ROOT_SIGNATURE_DESC& InDesc, uint32 BindingSpace)
{
	ID3D12Device* Device = GetParentAdapter()->GetD3DDevice();

	// Create and analyze the root signature. ( RootSignature ìƒì„± )
	VERIFYD3D12RESULT(Device->CreateRootSignature(FRHIGPUMask::All().GetNative(),
		RootSignatureBlob->GetBufferPointer(),
		RootSignatureBlob->GetBufferSize(),
		IID_PPV_ARGS(RootSignature.GetInitReference())));
}

FD3D12RootSignatureDesc::FD3D12RootSignatureDesc(const FD3D12QuantizedBoundShaderState& QBSS, const D3D12_RESOURCE_BINDING_TIER ResourceBindingTier)
{
	// Sampler ê´€ë ¨ ì •ë³´ëŠ” ì—¬ê¸°ì„œ ì„¸íŒ… ë˜ëŠ”ê²ƒ ê°™ë‹¤
	const D3D12_DESCRIPTOR_RANGE_FLAGS SamplerDescriptorRangeFlags = (ResourceBindingTier <= D3D12_RESOURCE_BINDING_TIER_1) ?
		D3D12_DESCRIPTOR_RANGE_FLAG_NONE :
		D3D12_DESCRIPTOR_RANGE_FLAG_DESCRIPTORS_VOLATILE;

	case D3D12_ROOT_PARAMETER_TYPE_CBV:
	{
		for (uint32 ShaderRegister = 0; (ShaderRegister < Shader.ConstantBufferCount) && (ShaderRegister < MAX_ROOT_CBVS); ShaderRegister++)
		{
			// RootSignature ê´€ë ¨ MSDN ìƒì— ë‚˜ì™€ ìˆëŠ” ì´ë¯¸ì§€ë¥¼ ë³´ë©´ ì´ˆë¡ìƒ‰ìœ¼ë¡œ
			// root CBV ë¼ê³  í‘œì‹œëœ ê³µê°„ì´ ìˆëŠ”ë° ê·¸ ê³µê°„ì„ í™œìš© í•œë‹¤ëŠ” ì½”ë“œ
			// í•´ë‹¹ ê³µê°„ì€ Lightì™€ ê°™ì´ ì „ì—­ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ê²ƒë“¤ì´ ì‚¬ìš©í•  ê²ƒì´ë‹¤
			// GetD3D12ShaderVisibilityëŠ” Shader ë‹¨ê³„ë“¤ì¤‘ ì–´ë””ê¹Œì§€ í™œìš©ë  ê²ƒì¸ì§€ë¥¼ ë‚˜íƒ€ë‚¸ë‹¤
			TableSlots[RootParameterCount].InitAsConstantBufferView(ShaderRegister, BindingSpace, CBVRootDescriptorFlags, GetD3D12ShaderVisibility(Visibility));
		}
	}

	case D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE:
	{
		if (Shader.ShaderResourceCount > 0)
		{
			// Shader Resource Viewë¡œ í™œìš©í•  ê²ƒì´ë©°, Shader.ShaderResourceCount ë§Œí¼ í™œìš©í•  ê²ƒì´ë©°, 0u ë²ˆì§€ë¶€í„° í™œìš©í•  ê²ƒì´ë‹¤
			DescriptorRanges[RootParameterCount].Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, Shader.ShaderResourceCount, 0u, BindingSpace, SRVDescriptorRangeFlags);
			
			// desc.table ë‚´ìš©ë¬¼ì„ ì–´ë–»ê²Œ êµ¬ì„±í•  ê²ƒì¸ì§€ ( ì´ ì •ë³´ëŠ” D3D12_VERSIONED_ROOT_SIGNATURE_DESCì— ë“±ë¡ëœë‹¤ )
			TableSlots[RootParameterCount].InitAsDescriptorTable(1, &DescriptorRanges[RootParameterCount], GetD3D12ShaderVisibility(Visibility));
		}
	}
}
```

```cpp
// D3D12StateCachePrivate.h

struct FD3D12VertexBufferCache
{
	// ID3D12Resourceë¥¼ ëŒ€ì‹ í•˜ëŠ” ê°ì²´ì´ë‹¤
	D3D12_VERTEX_BUFFER_VIEW CurrentVertexBufferViews[MAX_VBS];
}

struct FD3D12IndexBufferCache
{
	// ID3D12Resourceë¥¼ ëŒ€ì‹ í•˜ëŠ” ê°ì²´ì´ë‹¤
	D3D12_INDEX_BUFFER_VIEW CurrentIndexBufferView;
};
```

```cpp
// D3D12RenderTarget.cpp

// Map, Memcpy, Unmap í•¨ìˆ˜ê°€ í•µì‹¬
void FD3D12DynamicRHI::ReadSurfaceDataNoMSAARaw(FRHITexture* TextureRHI, FIntRect InRect, TArray<uint8>& OutData, FReadSurfaceDataFlags InFlags)
{
	// Lock the staging resource.
	void* pData;
	D3D12_RANGE ReadRange = { SrcStart, SrcStart + XBytesAligned * (SizeY - 1) + BytesPerLine };

	// ID3D12Resource íƒ€ì…ìœ¼ë¡œ ë§Œë“¤ì–´ì§„ GPU RAM BUFFERì— CPU RAM BUFFERì¸ pDataë¥¼ ì—°ë™í•œë‹¤
	VERIFYD3D12RESULT(TempTexture2D->GetResource()->Map(0, &ReadRange, &pData));

	uint8* DestPtr = OutData.GetData();
	uint8* SrcPtr = (uint8*)pData + SrcStart;
	for (uint32 Y = 0; Y < SizeY; Y++)
	{
		// ë°ì´í„°ê°€ GPU ë©”ëª¨ë¦¬ë¡œ ì „ë‹¬ëœë‹¤
		// ë³´í†µ SrcPtrì— ì›ë³¸ Vertex ì •ë³´ ë“±ì´ ë‹´ê¸´ë‹¤
		// ê·¸ë¦¬ê³  DestPtrì™€ pDataê°€ ê°™ì€ ë³€ìˆ˜ëª…ì„ ì‚¬ìš©í•´ì•¼ í•˜ëŠ”ë° ì™œ ë‹¤ë¥¼ê¹Œ
		memcpy(DestPtr, SrcPtr, BytesPerLine);
		DestPtr += BytesPerLine;
		SrcPtr += XBytesAligned;
	}

	// ë°ì´í„° ì—°ë™ ì¢…ë£Œ
	TempTexture2D->GetResource()->Unmap(0, nullptr);
}
```

- ìœ„ì˜ ì½”ë“œì— ëŒ€í•´ì„œëŠ” ì˜¤ë¥¸ìª½ ë§í¬ë¥¼ ì°¸ê³ í•˜ì ([**ì°¸ê³ **](https://velog.io/@ehdbs28/DX12-%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EB%A0%8C%EB%8D%94%EB%A7%81)), ([**ì°¸ê³ **](https://lipcoder.tistory.com/127))

```cpp
SkeletalMeshDuplicatedVerticesBuffer.h

class FDuplicatedVerticesBuffer : public FRenderResource
{
	virtual void InitRHI() override
	{
		{
			FResourceArrayInterface* ResourceArray = DupVertData.GetResourceArray();
			check(ResourceArray->GetResourceDataSize() > 0);

			// ìš°ë¦¬ê°€ BPë¥¼ ì›”ë“œì— ì§‘ì–´ ë„£ì„ë•Œ ì—¬ê¸°ì„œ í•´ë‹¹ BPì˜ ë²„í…ìŠ¤ ì •ë³´ê°€ ë³µì‚¬ë˜ëŠ”ë“¯ í•˜ë‹¤
			FRHIResourceCreateInfo CreateInfo(TEXT("DuplicatedVerticesIndexBuffer"), ResourceArray);
			DuplicatedVerticesIndexBuffer.VertexBufferRHI = RHICreateVertexBuffer(ResourceArray->GetResourceDataSize(), BUF_Static | BUF_ShaderResource, CreateInfo);
			DuplicatedVerticesIndexBuffer.VertexBufferRHI->SetOwnerName(GetOwnerName());
			DuplicatedVerticesIndexBuffer.VertexBufferSRV = RHICreateShaderResourceView(DuplicatedVerticesIndexBuffer.VertexBufferRHI, sizeof(uint32), PF_R32_UINT);
		}

		{
			FResourceArrayInterface* ResourceArray = DupVertIndexData.GetResourceArray();
			check(ResourceArray->GetResourceDataSize() > 0);

			// ìš°ë¦¬ê°€ BPë¥¼ ì›”ë“œì— ì§‘ì–´ ë„£ì„ë•Œ ì—¬ê¸°ì„œ í•´ë‹¹ BPì˜ ì¸ë±ìŠ¤ ì •ë³´ê°€ ë³µì‚¬ë˜ëŠ”ë“¯ í•˜ë‹¤
			FRHIResourceCreateInfo CreateInfo(TEXT("LengthAndIndexDuplicatedVerticesIndexBuffer"), ResourceArray);
			LengthAndIndexDuplicatedVerticesIndexBuffer.VertexBufferRHI = RHICreateVertexBuffer(ResourceArray->GetResourceDataSize(), BUF_Static | BUF_ShaderResource, CreateInfo);
			LengthAndIndexDuplicatedVerticesIndexBuffer.VertexBufferRHI->SetOwnerName(GetOwnerName());
			LengthAndIndexDuplicatedVerticesIndexBuffer.VertexBufferSRV = RHICreateShaderResourceView(LengthAndIndexDuplicatedVerticesIndexBuffer.VertexBufferRHI, sizeof(uint32), PF_R32_UINT);
		}
	}
}
```

```cpp
// ShaderPipelineCache.cpp

bool FShaderPipelineCacheTask::Precompile(FRHICommandListImmediate& RHICmdList, EShaderPlatform Platform, FPipelineCacheFileFormatPSO const& PSO)
{
	FVertexShaderRHIRef VertexShader;
	if (PSO.GraphicsDesc.VertexShader != FSHAHash())
	{
		// CreateVertexShader í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ Shader íŒŒì¼ì„ ì½ì–´ Initì„ í•´ì¤˜ì•¼ í•˜ëŠ”ë° í˜¸ì¶œì´ ì•ˆë˜ë„¤
		VertexShader = FShaderCodeLibrary::CreateVertexShader(Platform, PSO.GraphicsDesc.VertexShader);
		GraphicsInitializer.BoundShaderState.VertexShaderRHI = VertexShader;
	}
}
```

```cpp
// ShaderResource.cpp

FRHIShader* FShaderMapResource_InlineCode::CreateRHIShaderOrCrash(int32 ShaderIndex)
{
	TRefCountPtr<FRHIShader> RHIShader;
	switch (Frequency)
	{
	// ì–¸ë¦¬ì–¼ ì—ì„œëŠ” CreateVertexShader ëŒ€ì‹  RHICreateVertexShader ë¼ëŠ” í•¨ìˆ˜ë¥¼ ë§Œë“¤ì—ˆë‹¤
	case SF_Vertex: RHIShader = RHICreateVertexShader(ShaderCodeView, ShaderHash); break;
	case SF_Mesh: RHIShader = RHICreateMeshShader(ShaderCodeView, ShaderHash); break;
	case SF_Amplification: RHIShader = RHICreateAmplificationShader(ShaderCodeView, ShaderHash); break;
	case SF_Pixel: RHIShader = RHICreatePixelShader(ShaderCodeView, ShaderHash); break;
	case SF_Geometry: RHIShader = RHICreateGeometryShader(ShaderCodeView, ShaderHash); break;
	case SF_Compute: RHIShader = RHICreateComputeShader(ShaderCodeView, ShaderHash); break;
	}
}
```

- USF Shader íŒŒì¼ì´ë€? USF Shader íŒŒì¼ì€ HLSL ì–¸ì–´ì— ê¸°ë°˜í•œ ê²ƒìœ¼ë¡œ, ë©€í‹° í”Œë«í¼ ì…°ì´ë” ì½”ë“œê°€ ë“¤ì–´ìˆëŠ” ì–¸ë¦¬ì–¼ ì—”ì§„ ì…°ì´ë” íŒŒì¼ í¬ë§·ì…ë‹ˆë‹¤ ([**ì°¸ê³ **](https://itscai.us/blog/post/ue-view-extensions/)), ([**ì°¸ê³ **](https://www.youtube.com/watch?v=sXIAIOuGee4&t=5s)), ([**ì°¸ê³ **](https://kaynine.tistory.com/2)), ([**ì°¸ê³ **](https://forums.unrealengine.com/t/toon-shading-models-stylized-rendering-experiments/218895)), ([**ì°¸ê³ **](https://aym0011.wordpress.com/2019/01/25/ue4-%EC%BB%A4%EC%8A%A4%ED%85%80-%ED%88%B0%EC%85%B0%EC%9D%B4%EB%8D%94-%EC%B6%94%EA%B0%80%EB%B0%A9%EB%B2%95/))

### 01-4 Constant Buffer

![pipeline](https://github.com/devMyeong/devMyeong.github.io/assets/80055816/46dbebb8-3a85-4988-9295-fb0a18b84011){: width="100%" height="100%"}{: .align-center}

![cpugpu](https://github.com/devMyeong/devMyeong.github.io/assets/80055816/36dd9b65-64d1-4b94-9ba8-4d6226bb6034){: width="100%" height="100%"}{: .align-center}

- RootSignatureì˜ ìš©ë„ëŠ”? GPU Registersë¥¼ ì–´ë–»ê²Œ í™œìš©í•  ê²ƒì¸ì§€ ì„¤ì • ( 08 : 38 ) ([**ì°¸ê³ **](https://learn.microsoft.com/ko-kr/windows/win32/direct3d12/example-root-signatures))
- Registersë¥¼ í™œìš©í•˜ê¸° ìœ„í•œ ë‹¨ê³„ë¥¼ ì„¤ëª…í•˜ë©´? CPU RAM ì—ì„œ GPU RAMìœ¼ë¡œ ë°ì´í„°ë¥¼ ë³µì‚¬í•œ ë’¤ ê·¸ ë°ì´í„°ì˜ ìœ„ì¹˜ë¥¼ Constant Buffer Viewë¡œ ì‚¬ìš©í•  Registersì— ë³µì‚¬í•´ì¤˜ì•¼ í•œë‹¤ ( 28 : 48 )
- GPU RAM ê³µê°„ ìƒì„±ê³¼ ë°ì´í„° ì—°ë™ì— ëŒ€í•´ API ê¸°ë°˜ìœ¼ë¡œ ì„¤ëª…í•˜ë©´? CreateCommittedResource -> Map -> Unmap ( 32 : 41 )
- ìœ„ì˜ ê³¼ì •ì´ ëë‚˜ë©´ ì–´ë–»ê²Œ ë˜ëŠ”ê°€? CPU RAM ë°ì´í„°ê°€ GPU RAM ìœ¼ë¡œ ì¦‰ì‹œ ë³µì‚¬ëœë‹¤ ( 33 : 07 )
- GPU RAMì—ì„œ GPU Registersë¡œì˜ ë³µì‚¬ëŠ” CommandQueueë¥¼ í™œìš©í•´ ë‚˜ì¤‘ì— ì²˜ë¦¬ ë˜ê¸° ë•Œë¬¸ì— ë°œìƒí•˜ëŠ” ë¬¸ì œì™€ í•´ê²° ë°©ë²•ì„ ì„¤ëª…í•˜ë©´? ë‚´ê°€ ì‘ì—…ì„ ìš”ì²­í–ˆë˜ ë‹¹ì‹œì™€ ìƒí™©ì´ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆë‹¤ ë•Œë¬¸ì— GPU RAM ìƒì— ë²„í¼ë¥¼ í•œê°œê°€ ì•„ë‹Œ ì—¬ëŸ¬ê°œë¡œ ë§Œë“ ë‹¤ ( 37 : 14 )
- GPU RAMì— ìƒì„±ë˜ëŠ” BUFFERì˜ íƒ€ì…ì€ ë¬´ì—‡ì¸ê°€? ID3D12Resource ( 40 : 00 )
- ìƒìˆ˜ ë²„í¼ëŠ” ëª‡ ë°”ì´íŠ¸ ë°°ìˆ˜ë¡œ ë§Œë“¤ì–´ì•¼ í•˜ëŠ”ê°€? 256 ( 42 : 59 )
- ìƒìˆ˜ ë²„í¼ëŠ” ì–´ë–»ê²Œ í™œìš©ë  ìˆ˜ ìˆëŠ”ê°€? Offsetì„ GPU Registersë¡œ ë„˜ê²¨ì¤„ ë•Œ í™œìš©ë  ìˆ˜ ìˆë‹¤ ( 57 : 20 )

### 01-5 Root Signature

![desc](https://github.com/devMyeong/devMyeong.github.io/assets/80055816/4a839a7e-cdc1-419e-8eab-8ddf06c1d340){: width="100%" height="100%"}{: .align-center}

- root CBV ê³µê°„ë§ê³  í™œìš©í•  ìˆ˜ ìˆëŠ” ê³µê°„ì€? desc.table ( 01 : 34 )
- desc.tableì„ ë™ì‹œì— í™œì„±í™” í•  ìˆ˜ ìˆëŠ”ê°€? ì•„ë‹ˆì˜¤ ( 01 : 47 )
- desc.table ì•ˆì— 5ê°œì˜ ê³µê°„ì„ ì‚¬ìš©í•˜ë ¤ë©´ ì–´ë–»ê²Œ í•´ì•¼ í•˜ëŠ”ê°€? GPU RAMì— Desc.Heapì„ ë§Œë“¤ê³  ì—¬ê¸°ì—ë„ 5ê°œì˜ ê³µê°„ì„ ë§Œë“¤ì–´ ì¤˜ì•¼ í•œë‹¤ ( 05 : 30 )
- GPU RAMì˜ Desc.Heapì— ìˆëŠ” 5ê°œì˜ ê³µê°„ì€ ì–´ë–»ê²Œ ì±„ì›Œì•¼ í•˜ëŠ”ê°€? 5ê°œì˜ ê³µê°„ì„ ê°€ì§€ê³  ìˆìœ¼ë©° ì´ ê³µê°„ì´ Constant Buffer 5ê°œë¥¼ ê°ê° ê°€ë¦¬í‚¤ëŠ” Desc.Heap ìœ¼ë¡œ ë¶€í„° ì¦‰ì‹œ ë³µì‚¬í•´ì˜¨ë‹¤ ì°¸ê³ ë¡œ í•´ë‹¹ Desc.Heapì€ Constant Buffer View ë¼ê³  ë¶€ë¥¸ë‹¤ ( 06 : 35 )
- GPU RAMì˜ Desc.Heapì— ìˆëŠ” ë°ì´í„°ë¥¼ desc.tableë¡œ ë³µì‚¬í•˜ëŠ” ê²ƒì€ ì¦‰ì‹œë³µì‚¬ ì¸ê°€ ë‚˜ì¤‘ë³µì‚¬ ì¸ê°€? ë‚˜ì¤‘ë³µì‚¬ ( 07 : 49 )
- ìœ„ì˜ ë³µì‚¬ë¡œ ì¸í•´ ìƒê¸°ëŠ” íƒ€ì´ë° ë¬¸ì œë¥¼ í•´ê²°í•  ë°©ë²•ì€? GPU RAMì˜ Desc.Heap(ì•ˆì— ê³µê°„ 5ê°œ ìˆìŒ)ì„ ì—¬ëŸ¬ê°œë¡œ ë§Œë“ ë‹¤ ( 08 : 50 )
- Constant Bufferë¥¼ ê°€ë¦¬í‚¤ê³  ìˆëŠ” Desc.Heapì˜ ìë£Œí˜•ì€ ë¬´ì—‡ì¸ê°€? ID3D12DescriptorHeap ( 19 : 20 )

```cpp
// D3D12Descriptors.h
struct FD3D12DescriptorHeap : public FD3D12DeviceChild, public FThreadSafeRefCountedObject
{
	// Constant Bufferë¥¼ ê°€ë¦¬í‚¤ê³  ìˆëŠ” Desc.Heapì˜ íŠ¹ì • ìŠ¬ë¡¯ í•¸ë“¤ì„ ê°€ì ¸ì˜¨ë‹¤
	inline D3D12_CPU_DESCRIPTOR_HANDLE GetCPUSlotHandle(uint32 Slot) const { return CD3DX12_CPU_DESCRIPTOR_HANDLE(CpuBase, Slot, DescriptorSize); }

	// GPU RAMì˜ Desc.Heapì— ìˆëŠ” íŠ¹ì • ìŠ¬ë¡¯ í•¸ë“¤ì„ ê°€ì ¸ì˜¨ë‹¤
	inline D3D12_GPU_DESCRIPTOR_HANDLE GetGPUSlotHandle(uint32 Slot) const { return CD3DX12_GPU_DESCRIPTOR_HANDLE(GpuBase, Slot, DescriptorSize); }
}
```

### 01-6 Index Buffer
- Constant BufferëŠ” ì–´ë–»ê²Œ í™œìš©í•  ìˆ˜ ìˆëŠ”ê°€? CreateCommittedResource -> Map -> Unmap í™œìš©í•´ ë¬¼ì²´ ì •ë³´ë¥¼ í•œë²ˆë§Œ ìƒì„±í•œ ë’¤ Constant Bufferë¥¼ í™œìš©í•´ ì—¬ëŸ¬ ë¬¼ì²´ë¥¼ ë‹¤ì–‘í•œ ëª¨ì–‘ìœ¼ë¡œ ë³€ê²½í•´ ë Œë”ë§ ( 01 : 42 )
- 4ë²ˆ ê°•ì¢Œì— ìˆëŠ” ë Œë”ë§ íŒŒì´í”„ ë¼ì¸ì„ ë³´ê³  ìš°ë¦¬ê°€ ë Œë”ë§ íŒŒì´í”„ ë¼ì¸ì— ì •ë³´ë¥¼ ì „ë‹¬í•˜ëŠ” ë°©ì‹ 3ê°€ì§€ë¥¼ ì„¤ëª…í•˜ë©´? Root descriptors, Descriptor tables, Root Constant ( 03 : 03 )
- ì¸ë±ìŠ¤ ë²„í¼ëŠ” ì™œ ì‚¬ìš©í•´ì•¼ í•˜ëŠ”ê°€? ì¤‘ë³µë˜ëŠ” ë²„í…ìŠ¤ ì •ë³´ë¥¼ ì œì™¸í•˜ë©´ ì‚¼ê°í˜• ë“¤ì´ ì–´ë–»ê²Œ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ ì•Œìˆ˜ì—†ê¸° ë•Œë¬¸ì´ë‹¤ ( 12 : 18 )
- ì¸ë±ìŠ¤ ë²„í¼ë¥¼ ì •í• ë•Œ ìˆœì„œê°€ ì¤‘ìš”í•œê°€? ì•„ë‹ˆì˜¤ ( 21 : 09 )
- 4ë²ˆ ê°•ì¢Œì— ìˆëŠ” ë Œë”ë§ íŒŒì´í”„ ë¼ì¸ì„ ë³´ê³  Vertex Buffer ì •ë³´ì™€ Index Buffer ì •ë³´ê°€ ì–´ëŠ ë‹¨ê³„ì—ì„œ ì •í•´ì§€ëŠ”ì§€ ê°€ë¦¬ì¼œ ë³´ë©´? ( 22 : 24 )

### 01-7 Texture Mapping
- UV ì¢Œí‘œì— ëŒ€í•´ì„œ ì„¤ëª…í•˜ë©´? ( 03 : 11 )
- í…ìŠ¤ì³ê°€ ë§µí•‘ë˜ëŠ” ì›ë¦¬ë¥¼ ì„¤ëª…í•˜ë©´? ( 04 : 08 )
- í…ìŠ¤ì³ê°€ Constant Bufferì™€ ë‹¤ë¥¸ì ì€? Constant Bufferì™€ ë‹¬ë¦¬ Desc.Heapì— Viewë¥¼ ë”± í•˜ë‚˜ë§Œ ë§Œë“¤ì–´ë„ ëœë‹¤, Constant Bufferë¥¼ ë§Œë“¤ë•ŒëŠ” Desc.Heapì— Viewë¥¼ 5ê°œ ë§Œë“¤ì–´ í•´ë‹¹ View ë‚´ìš©ì„ Registersë¡œ ë³µì‚¬í•´ì¤Œ ( 16 : 16 )

```cpp
// D3D12Texture.cpp

FTextureRHIRef FD3D12DynamicRHI::RHIAsyncCreateTexture2D(uint32 SizeX, uint32 SizeY, uint8 Format, uint32 NumMips, ETextureCreateFlags Flags, ERHIAccess InResourceState, void** InitialMipData, uint32 NumInitialMips)
{
	// ë¦¬ì†ŒìŠ¤ ë¡œë“œ ( ì—¬ê¸°ì„œ ì‚¬ìš©í•˜ëŠ” CommandListëŠ” ë¦¬ì†ŒìŠ¤ ë¡œë“œ ìš©ë„ë¡œ ì‚¬ìš©ë˜ëŠ” ê°ì²´ )
	UpdateSubresources(
	CopyScope.Context.CopyCommandList().Get(),
	Resource->GetResource(),
	TempResourceLocation.GetResource()->GetResource(),
	TempResourceLocation.GetOffsetFromBaseOfResource(),
	0, NumMips,
	SubResourceData);
}

FD3D12ResourceDesc FD3D12DynamicRHI::GetResourceDesc(const FRHITextureDesc& TextureDesc) const
{
	// 2D í…ìŠ¤ì³ë¥¼ ë§Œë“¤ê³  ìˆë‹¤
	ResourceDesc = CD3DX12_RESOURCE_DESC::Tex2D(
		PlatformResourceFormat,
		TextureDesc.Extent.X,
		TextureDesc.Extent.Y,
		TextureDesc.ArraySize * (TextureDesc.IsTextureCube() ? 6 : 1),  // Array size
		TextureDesc.NumMips,
		ActualMSAACount,
		ActualMSAAQuality,
		D3D12_RESOURCE_FLAG_NONE);  // Add misc flags later
	
	// ì–´ë–¤ ìš©ë„ë¡œ ì‚¬ìš©í•  ê²ƒì¸ì§€ ì§€ì •í•´ì£¼ê³  ìˆë‹¤
	if (EnumHasAnyFlags(TextureDesc.Flags, TexCreate_Shared))
	{
		ResourceDesc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_SIMULTANEOUS_ACCESS;
	}
	
	// ì–´ë–¤ ìš©ë„ë¡œ ì‚¬ìš©í•  ê²ƒì¸ì§€ ì§€ì •í•´ì£¼ê³  ìˆë‹¤
	if (EnumHasAnyFlags(TextureDesc.Flags, TexCreate_RenderTargetable))
	{
		ResourceDesc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET;
	}
	else if (EnumHasAnyFlags(TextureDesc.Flags, TexCreate_DepthStencilTargetable))
	{
		ResourceDesc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;
	}
	else if (EnumHasAnyFlags(TextureDesc.Flags, TexCreate_ResolveTargetable))
	{
		if (TextureDesc.Format == PF_DepthStencil || TextureDesc.Format == PF_ShadowDepth || TextureDesc.Format == PF_D24)
		{
			ResourceDesc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;
		}
		else
		{
			ResourceDesc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET;
		}
	}
}
```

```cpp
// hlsl

// tex_0ëŠ” ë ˆì§€ìŠ¤í„° t0 ê³µê°„ì„ ì‚¬ìš©í•  ê²ƒì´ë‹¤
Texture2D tex_0 : register(t0)

// sam_0ëŠ” ë ˆì§€ìŠ¤í„° s0 ê³µê°„ì„ ì‚¬ìš©í•  ê²ƒì´ë‹¤
SamplerState sam_0 : register(s0)

// VS_IN ì˜ˆì‹œ
struct VS_IN
{
	float3 pos : POSITION;
	float4 color : COLOR;
	float2 uv : TEXCOORD;
}
```

```cpp
// D3D12VertexDeclaration.cpp

struct FD3D12VertexDeclarationKey
{
	explicit FD3D12VertexDeclarationKey(const FVertexDeclarationElementList& InElements)
	{
		for (int32 ElementIndex = 0; ElementIndex < InElements.Num(); ElementIndex++)
		{
			const FVertexElement& Element = InElements[ElementIndex];
	
			// hlslì˜ POSITION, COLOR, TEXCOORD ê°™ì€ ë¶€ë¶„ê³¼ ì—°ë™ë˜ëŠ” êµ¬ì¡°ì²´
			D3D12_INPUT_ELEMENT_DESC D3DElement = { 0 };

			// D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATAê°€ ì˜ë¯¸í•˜ëŠ” ë°”ëŠ” ì¸ìŠ¤í„´ìŠ¤ ë§ˆë‹¤ êµìœ í•˜ê²Œ í•˜ë‚˜ì”© ë°°ì •ë˜ëŠ” ë°ì´í„°
			D3DElement.InputSlotClass = Element.bUseInstanceIndex ? D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA : D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		}
	}
}
```

- UV ì¢Œí‘œëŠ” ëª‡ ë¶€í„° ëª‡ ê¹Œì§€ì¸ê°€? ( 41 : 30 )

### 01-8 Depth Stencil View
- Depth Stencil Viewë¥¼ ë Œë”ë§ íŒŒì´í”„ë¼ì¸ ì´ë¯¸ì§€ì—ì„œ ì§‘ì–´ë³´ë©´? ( 00 : 50 )
- ìš°ë¦¬ê°€ ì–´ë–¤ ë¬¼ì²´ë¥¼ ê·¸ë ¤ì•¼ í• ì§€ ì•ˆê·¸ë ¤ì•¼ í• ì§€ ì–´ë–»ê²Œ íŒë‹¨í•˜ëŠ”ê°€? ( 09 : 18 )
- ë§Œì•½ Depth ê°’ì´ ìŒìˆ˜ ë˜ëŠ” 1ì„ ë„˜ì–´ê°€ë©´ ì–´ë–»ê²Œ ë˜ëŠ”ê°€? ë ˆìŠ¤í„° ë¼ì´ì € ë‹¨ê³„ì—ì„œ ì œê±°ëœë‹¤ ( 13 : 22 )
- Depth Stencil View ë‹¨ê³„ì—ì„œ í•˜ê³ ì‹¶ì€ ì¼ì„ ì„œìˆ í•˜ë©´? ( 14 : 08 )
- ë§Œì•½ì— ìš°ë¦¬ê°€ Stencil ê°’ì„ ì‚¬ìš©í•˜ê³  ì‹¶ìœ¼ë©´ ì–´ë–¤ ì¼ì´ ë°œìƒí•˜ëŠ”ê°€? ( 18 : 45 )
- Stencil ê¸°ëŠ¥ì— ëŒ€í•´ ì„¤ëª…í•˜ë©´? ( 19 : 40 )
- Depth Stencil View BufferëŠ” ëª‡ê°œë¥¼ ë§Œë“¤ì–´ ì¤˜ì•¼ í•˜ëŠ”ê°€? 1ê°œ ( 25 : 28 )
- Depthì™€ Stencilê°’ì„ ëª¨ë‘ ì‚¬ìš©í•˜ë ¤ë©´ ì–´ë–¤ í˜•ì‹ìœ¼ë¡œ ë²„í¼ë¥¼ ë§Œë“¤ì–´ ì¤˜ì•¼ í•˜ëŠ”ê°€? ( 26 : 00 )
- ìœˆë„ìš° í™”ë©´ì´ 800 X 600 ì´ë¼ë©´ Depth Stencil Bufferì˜ í¬ê¸°ëŠ” ì–´ë–»ê²Œ ì§€ì •í•´ì•¼ í•˜ëŠ”ê°€? ( 27 : 30 )

```cpp
// D3D12Pipelinestate.cpp

static FD3D12LowLevelGraphicsPipelineStateDesc GetLowLevelGraphicsPipelineStateDesc(const FGraphicsPipelineStateInitializer& Initializer, const FD3D12RootSignature* RootSignature)
{
	// DepthStencilState ì„¸íŒ…
	FD3D12LowLevelGraphicsPipelineStateDesc Desc{};
	Desc.Desc.DepthStencilState = Initializer.DepthStencilState ? CD3DX12_DEPTH_STENCIL_DESC1(FD3D12DynamicRHI::ResourceCast(Initializer.DepthStencilState)->Desc) : CD3DX12_DEPTH_STENCIL_DESC1(D3D12_DEFAULT);
}
```

```cpp
// WindowsD3D12PipelineState.cpp

FD3D12_GRAPHICS_PIPELINE_STATE_STREAM FD3D12_GRAPHICS_PIPELINE_STATE_DESC::PipelineStateStream() const
{
	// DepthStencilState ì„¸íŒ…
	FD3D12_GRAPHICS_PIPELINE_STATE_STREAM Stream = {};
	Stream.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC1(this->DepthStencilState);
}

FD3D12_MESH_PIPELINE_STATE_STREAM FD3D12_GRAPHICS_PIPELINE_STATE_DESC::MeshPipelineStateStream() const
{
	// DepthStencilState ì„¸íŒ…
	FD3D12_MESH_PIPELINE_STATE_STREAM Stream{};
	Stream.DepthStencilState = CD3DX12_DEPTH_STENCIL_DESC1(this->DepthStencilState);
}
```

## Chapter 2 Component

### 02-1 Inputê³¼ Timer
- ì¤‘ìš”í•œ ë‚´ìš© ì—†ìŒ

### 02-2 Material
- Material ì´ë€ ë¬´ì—‡ì¸ê°€? ë‚´ê°€ ì‚¬ìš©í•  Shaderì™€ í•´ë‹¹ Shaderì—ì„œ ì‚¬ìš©í•  ì¸ì(Texture2D, SamplerState, POSITION, COLOR, TEXCOORD ë“±ë“±) ê¹Œì§€ ëª¨ë‘ í¬í•¨í•´ í•˜ë‚˜ì˜ í´ë˜ìŠ¤ë¡œ ê´€ë¦¬ í•˜ëŠ”ê²ƒ ( 07 : 52 )
- Shaderì—ì„œ ì‚¬ìš©í•  ì¸ìëŠ” ì–´ë””ë¡œ ì „ë‹¬ë ê¹Œ? GPU Registers ( 25 : 40 )
- GPU Registers ì—ì„œ í…ìŠ¤ì³ë¥¼ ëª‡ê°œ í™œìš©í•  ê²ƒì´ë¼ëŠ” ë‚´ìš©ì€ ì–´ë””ì— ë“±ë¡ë˜ì–´ ìˆëŠ”ê°€? RootSignature ( 26 : 58 )
- Material ê°œë…ì˜ ì¥ì ì€? ì˜¤ë¸Œì íŠ¸ ë“¤ì´ í•˜ë‚˜ì˜ Materialì„ ê³µìœ í•  ìˆ˜ ìˆë‹¤ ( 40 : 38 )

### 02-3 Component
- GameObjectë¥¼ weak_ptrë¡œ ê°–ëŠ” ì´ìœ ëŠ”? ì»´í¬ë„ŒíŠ¸ì™€ ìƒí˜¸ ì°¸ì¡° í•˜ëŠ”ê²ƒì„ ë§‰ê¸°ìœ„í•´ ( 22 : 06 )

### 02-4 Scene
- Sceneê³¼ GameObjectëŠ” ì–´ë–¤ ê´€ê³„ì¸ê°€? has-a ê´€ê³„

## Chapter 3 Vector and Matrix

### 03-1 ì‚¼ê°í•¨ìˆ˜
- í•¨ìˆ˜ë¼ëŠ” ì •ì˜ë¥¼ ì¶©ì¡±ì‹œí‚¤ê¸° ìœ„í•œ arccos, arcsin, arctanì˜ ê°ë„ ë²”ìœ„ëŠ” ì–´ë–»ê²Œ ë˜ëŠ”ê°€? arccosë§Œ 0 ~ ğ… ë‚˜ë¨¸ì§€ëŠ” -ğ…/2 ~ ğ…/2 ( 34 : 40 )
- ì½”ì‚¬ì¸ ë§ì…ˆ ì •ë¦¬ëŠ” ì–¸ì œ í™œìš© ë˜ëŠ”ê°€? íšŒì „ í–‰ë ¬ì„ ë§Œë“¤ë•Œ ( 42 : 48 )

### 03-2 ë²¡í„°
- ë²¡í„°ë¼ë¦¬ ê³±ì…ˆê³¼ ë‚˜ëˆ—ì…ˆì´ ê°€ëŠ¥í•œê°€? ì•„ë‹ˆì˜¤ ( 13 : 47 )
- ë²¡í„°ì™€ ìŠ¤ì¹¼ë¼ ê°„ì˜ ê³±ì…ˆê³¼ ë‚˜ëˆ—ì…ˆì´ ê°€ëŠ¥í•œê°€? ì˜ˆ ( 13 : 47 )
- ë‹¨ìœ„ ë²¡í„°ë¥¼ ë§Œë“œëŠ” ë°©ë²•ì€? ì›ë˜ ë²¡í„°ì˜ ê° ì„±ë¶„ì— í¬ê¸°ê°’ì„ ë‚˜ëˆ ì¤€ë‹¤ ( 24 : 30 )
- ì™¸ì ì€ êµí™˜ ë²•ì¹™ì´ ì„±ë¦½ í•˜ëŠ”ê°€? ì•„ë‹ˆì˜¤ ( 46 : 11 )

### 03-3 í–‰ë ¬
- í–‰ë ¬ì„ ê³±í•˜ê¸° ìœ„í•œ ì¡°ê±´ì€? ì„ í–‰ë ¬ì˜ ì—´ê³¼ í›„í–‰ë ¬ì˜ í–‰ì´ ê°™ì•„ì•¼ í•œë‹¤ ( 09 : 38 )
- í–‰ë ¬ì„ ê³±í•œ ê²°ê³¼ëŠ”? ì„ í–‰ë ¬ì˜ í–‰ì˜ ê°œìˆ˜ì™€ í›„í–‰ë ¬ì˜ ì—´ì˜ ê°œìˆ˜ì— í•´ë‹¹í•˜ëŠ” ìƒˆë¡œìš´ í–‰ë ¬ì„ ë§Œë“ ë‹¤ ( 10 : 08 )

### 03-4 Scale, Rotation, Translation ë³€í™˜ í–‰ë ¬
- ì´ë²ˆ ê°•ì¢Œì˜ ì£¼ ë‚´ìš©ì€? Scale, Rotation, Translation ë³€í™˜ í–‰ë ¬ì´ ì–´ë–»ê²Œ ë§Œë“¤ì–´ ì§€ëŠ”ì§€ ì„¤ëª… ( 04 : 19 )
- wë¥¼ ì¶”ê°€í•´ ì‚¬ìš©í•˜ëŠ” ì¢Œí‘œê³„ë¥¼ ë­ë¼ê³  í•˜ëŠ”ê°€? ë™ì°¨ ì¢Œí‘œê³„ ( 06 : 03 )
- ìºë¦­í„° ë°œ ë°‘ì„ ì›ì ìœ¼ë¡œ ì¡ëŠ” ì´ìœ ëŠ”? ìºë¦­í„° ì‚¬ì´ì¦ˆê°€ ì»¤ì ¸ë„ ë•…ì†ì— ë“¤ì–´ê°€ì§€ ì•Šê²Œ í•˜ê¸°ìœ„í•´ ( 18 : 53 )

### 03-5 ì¢Œí‘œê³„ ë³€í™˜ í–‰ë ¬
- ì¢Œí‘œê³„ ë³€í™˜ í–‰ë ¬ì˜ ì—­í• ì€? ìƒˆë¡œìš´ ì¢Œí‘œê³„ì—ì„œ ì›ë˜ ì¢Œí‘œê³„ì˜ íŠ¹ì • ì¢Œí‘œê°€ ì–´ë–»ê²Œ ë³€í• ì§€ ì•Œ ìˆ˜ ìˆë‹¤ ( 03 : 56 )
- ë³€í™” í•˜ë ¤ëŠ” ëŒ€ìƒì´ ìœ„ì¹˜ ë²¡í„°ì´ë©´ (x,y,z,?) ì—ì„œ ë¬¼ìŒí‘œì— ë“¤ì–´ê°ˆ ê°’ì€? 1 ( 21 : 27 )
- ë³€í™” í•˜ë ¤ëŠ” ëŒ€ìƒì´ ë°©í–¥ ë²¡í„°ì´ë©´ (x,y,z,?) ì—ì„œ ë¬¼ìŒí‘œì— ë“¤ì–´ê°ˆ ê°’ì€? 0 ( 21 : 27 )

### 03-6 World, View ë³€í™˜ í–‰ë ¬
- World ë³€í™˜ í–‰ë ¬ì€ ì–´ë–¤ í–‰ë ¬ì„ ì‘ìš©í–ˆëŠ”ê°€? ì¢Œí‘œê³„ ë³€í™˜ í–‰ë ¬ ([**ì°¸ê³ **](https://pjnull.tistory.com/7))
- World ë³€í™˜ í–‰ë ¬ì—ëŠ” ì–´ë–¤ ì •ë³´ê°€ ìˆëŠ”ê°€? ë³€í™”í•  Position, Rotation, Scale ( 31 : 49 )
- View ë³€í™˜ í–‰ë ¬ì´ë€? ì¹´ë©”ë¼ ì›”ë“œ í–‰ë ¬ì˜ ì—­í–‰ë ¬ ( 48 : 53 )
- View ë³€í™˜ í–‰ë ¬ì˜ ì—­í• ì€? ì¹´ë©”ë¼ë¥¼ ì›ì ì— ë°°ì¹˜í•˜ê³ , ê·¸ì— ë”°ë¼ ë‹¤ë¥¸ ì‚¬ë¬¼ë“¤ì„ ì•Œë§ê²Œ ì¬ë°°ì¹˜ í•´ì¤€ë‹¤

### 03-7 Projection, Screen ë³€í™˜ í–‰ë ¬
- nearì™€ farì˜ ì—­í• ì€? í•´ë‹¹ ì˜ì—­ ì•ˆì˜ ë¬¼ì²´ë§Œ ì¹´ë©”ë¼ì— ì°íˆê²Œ í•´ì¤€ë‹¤ ( 08 : 52 )
- ì¹´ë©”ë¼ì˜ ì‹œì•¼ë¥¼ ë„“í˜€ì£¼ê¸° ìœ„í•´ì„œëŠ” ì–´ë–¤ ê²ƒì„ ì¡°ì ˆí•´ì•¼ í•˜ëŠ”ê°€? FOV ( 10 : 33 )
- x, y ì¢Œí‘œë¥¼ z ê°’ì— ë”°ë¼ ì •ê·œí™” ì‹œì¼œì£¼ëŠ” ë°©ë²•ì€? x, y ì¢Œí‘œë¥¼ z ê°’ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ì¤€ë‹¤ ( 14 : 18 )
- Projectionì„ í•˜ê¸°ìœ„í•´ z ê°’ì„ 0~1ë¡œ ë§Œë“¤ì–´ ì¤˜ì•¼í•œë‹¤ ì´ë•Œ z ê°’ì„ ë³´ì¡´í•˜ëŠ” ë°©ë²•ì€? w ì¢Œí‘œì— z ê°’ì„ ê¸°ë¡í•´ë‘”ë‹¤ ( 25 : 37 )
- w ì¢Œí‘œì— ê¸°ë¡í•´ë‘” ê°’ì„ í™œìš©í•´ x, y, z ì¢Œí‘œë¥¼ ë‚˜ëˆ„ì–´ ì£¼ëŠ” ë‹¨ê³„ëŠ”? ë ˆìŠ¤í„° ë¼ì´ì € ( 28 : 29 )
- Normalized Coordination Spaceì˜ ë²”ìœ„ëŠ”? x, y ê°ê° -1 ì—ì„œ 1 ( 35 : 56 )
- Normalized Coordination Space ë‹¤ìŒ SpaceëŠ” ë¬´ì—‡ì¸ê°€? ViewPort, ì°¸ê³ ë¡œ ì´ ì˜ì—­ì˜ ë²”ìœ„ëŠ” (0,0) ì—ì„œ (800,600) ì´ëŸ°ì‹ì„
- ViewPortì˜ MinDepthì™€ MaxDepthë¥¼ ì–´ë–»ê²Œ ì‘ìš©í•  ìˆ˜ ìˆëŠ”ê°€? ë·°í¬íŠ¸ë¥¼ ì—¬ëŸ¬ê°œ ë§Œë“¤ì—ˆì„ë•Œ ì¦‰ ë Œë” íƒ€ê²Ÿì´ ì—¬ëŸ¬ê°œ ì¼ë•Œ ê°ê°ì˜ MinDepthì™€ MaxDepthë¥¼ ì„¤ì •í•´ ì¤„ ìˆ˜ ìˆë‹¤ ( 45 : 03 )

## Chapter 4 Camera and Lighting

### 04-1 Camera
- í–‰ë ¬ ì •ë³´ì—ì„œ ê°í–‰ì´ ì˜ë¯¸í•˜ëŠ” ë°”ëŠ”? 1í–‰ì€ Right 2í–‰ì€ Up 3í–‰ì€ Look 4í–‰ì€ Translation ( 02 : 10 )
- í–‰ë ¬ ì—°ì‚°ì„ ìµœì í™” í•˜ëŠ”ë° ì“°ì´ëŠ” ê¸°ë²•ì€? SIMD ( 03 : 29 )

### 04-2 Resources
- ì¤‘ìš”í•œ ë‚´ìš© ì—†ìŒ

### 04-3 Lighting 1
- Ambiet, Diffuse, Specular, Emissiveì˜ ê° íŠ¹ì§•ê³¼ ì—°ì‚°ê³¼ì •ì„ ì„¤ëª…í•˜ë©´? ([**ì°¸ê³ **](https://velog.io/@sham/miniRT-%ED%95%B5%EC%8B%AC%EA%B0%9C%EB%85%90-%ED%90%81-%EC%A1%B0%EB%AA%85-%EB%AA%A8%EB%8D%B8))
- Specular ë°˜ì‚¬ê´‘ ë²¡í„°ë¥¼ êµ¬í•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•˜ë©´? ( 27 : 32 )

### 04-4 Lighting 2
- LightëŠ” í•œ í”„ë ˆì„ë‹¹ ëª‡ë²ˆ ì„¸íŒ… ë˜ëŠ”ê°€? í•œë²ˆ, Lightê°€ ì—¬ëŸ¬ê°œë¼ë„ ë§ˆì°¬ê°€ì§€ ( 11 : 44 )
- desc.table ë°©ì‹ì˜ ë‹¨ì ì€? ìš”ì†Œë“¤ì„ ê°œë³„ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ í•´ì¤„ìˆ˜ ì—†ë‹¤ ( 12 : 56 )
- ìœ„ì˜ ë‹¨ì  ë•Œë¬¸ì— Lightì™€ ê°™ì´ ì „ì—­ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ê²ƒë“¤ì€ ì–´ë–¤ ë°©ì‹ì„ ì‚¬ìš©í•˜ëŠ”ê°€? root CBVë¥¼ í™œìš©í•œë‹¤ ( 13 : 57 )

```cpp
// MeshPaintVertexShader.usf

// ì´ íŒŒì¼ì´ í—¤ë” ì—­í• ì„ í•˜ëŠ”ê²ƒ ê°™ë‹¤
#include "Common.ush"

// ì´ ë³€ìˆ˜ëŠ” global variable ì´ë‹¤
// í•œ í”„ë ˆì„ë‹¹ í•œë²ˆë§Œ ì„¸íŒ…ë  ê²ƒì´ë‹¤
float4x4 c_Transform;

void Main( float4 InPosition : ATTRIBUTE0,
		   float2 InCloneTextureCoordinates : ATTRIBUTE2,
		   float3 InWorldSpaceVertexPosition : ATTRIBUTE3,
		   out float4 OutPosition : SV_POSITION,
		   out float2 OutCloneTextureCoordinates: TEXCOORD0,
		   out float3 OutWorldSpaceVertexPosition : TEXCOORD1 )
{
	// Position (on texture map, derived from the UVs of the original mesh)
	OutPosition = mul( InPosition, c_Transform );

	// Pass clone texture coordinates through to the pixel shader
	OutCloneTextureCoordinates = InCloneTextureCoordinates;

	// Position of this vertex in world space (original mesh)
	OutWorldSpaceVertexPosition = InWorldSpaceVertexPosition;
}
```

- Packing Rulesì— ëŒ€í•´ì„œ ì„¤ëª…í•˜ë©´? 4ë°”ì´íŠ¸ ë‹¨ìœ„ë¡œ íŒ¨í‚¹ë˜ê³ , 16ë°”ì´íŠ¸ ë°”ìš´ë”ë¦¬ë¥¼ ë„˜ì–´ê°ˆ ìˆ˜ ì—†ë‹¤ í•˜ì§€ë§Œ USF ì—ì„œëŠ” ë¬´ì–¸ê°€ ì²˜ë¦¬ë¥¼ í•´ì¤˜ì„œ ì´ ê·œì¹™ì„ ì§€í‚¬ í•„ìš”ê°€ ì—†ëŠ”ê²ƒ ê°™ë‹¤ ( 41 : 26 ) ([**ì°¸ê³ **](https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-packing-rules))

### 04-5 Lighting 3
- Light ì—°ì‚°ì„ í•  ë•Œ ì£¼ì˜í•´ì•¼ í•  ë‚´ìš©ì€? í”½ì…€ì˜ ì¢Œí‘œê³„ì™€ ë…¸ë§ ì¢Œí‘œê³„ë¥¼ ì¼ì¹˜ ì‹œì¼œì•¼ í•œë‹¤, ë¡œì»¬ ì›”ë“œ ë·° ì¤‘ì—ì„œ ( 01 : 02 )
- Specularì˜ íŠ¹ì§•ì€? ìì‹ ì˜ ìƒ‰ìƒê³¼ ê³±í•´ì§€ì§€ ì•ŠëŠ”ë‹¤ ( 05 : 58 )
- Specular ì—°ì‚°ì— ì œê³±ì´ ë“¤ì–´ê°€ëŠ” ì´ìœ ëŠ”? Specularê°€ ì ìš©ë˜ëŠ” êµ¬ê°„ì„ ì¢í˜€ì£¼ê¸° ìœ„í•¨ì´ë‹¤ ( 19 : 26 )
- SpotLightì— ëŒ€í•œ ì„¤ëª… ( 26 : 04 )

### 04-6 Normal Mapping
- ë…¸ë§ë§µì˜ ìš©ë„ëŠ”? ê° í”½ì…€ì— í•´ë‹¹í•˜ëŠ” ë…¸ë§ ë²¡í„°ê°’ì„ ì €ì¥í•œë‹¤ ( 10 : 22 )
- ë…¸ë§ë§µ ì „ìš© ì¢Œí‘œê³„ë¥¼ ë­ë¼ê³  ë¶€ë¥´ëŠ”ê°€? íƒ„ì  íŠ¸ ìŠ¤í˜ì´ìŠ¤, íƒ„ì  íŠ¸(X)ì¶• ë°”ì´ë…¸ë§(Y)ì¶• ë…¸ë§(Z)ì¶• ìœ¼ë¡œ êµ¬ì„±ë˜ë©° í”½ì…€ ë§ˆë‹¤ ê°ê¸° ë‹¤ë¥¸ íƒ„ì  íŠ¸ ìŠ¤í˜ì´ìŠ¤ë¥¼ ê°–ëŠ”ë‹¤ ( 17 : 49 )
- ë…¸ë§ë§µ RGB ê°’ì€ ê°ê° 0~255 ì´ë‹¤ ì´ê²ƒì„ ì–´ë–¤ ë²”ìœ„ë¡œ ì •ê·œí™” í•´ì¤˜ì•¼ í•˜ëŠ”ê°€? -1.0 ~ 1.0 ìœ¼ë¡œ ì •ê·œí™” í•´ì¤˜ì•¼ í•œë‹¤, ë°©í–¥ ë²¡í„°ì´ê¸° ë•Œë¬¸ì´ë‹¤ ( 23 : 03 )
- í”½ì…€ ì»¬ëŸ¬ë¥¼ ê³„ì‚°í•  ë•Œ íƒ„ì  íŠ¸ ìŠ¤í˜ì´ìŠ¤ë¥¼ í™œìš©í•  ìˆ˜ ì—†ë‹¤ ì–´ë–»ê²Œ í•˜ë©´ ì¢‹ì„ê¹Œ? ë·°ìŠ¤í˜ì´ìŠ¤ë¡œ ë³€í™˜í•œë‹¤ ( 42 : 31 )

### 04-7 SKYBOX
- SKYBOXëŠ” ì¹´ë©”ë¼ ë·°í–‰ë ¬ ì •ë³´ë§Œ ìˆìœ¼ë©´ ëœë‹¤ ì´ë•Œ SKYBOXì— ì ìš© í•´ì•¼í•  ì„±ë¶„ê³¼ ì ìš©í•˜ì§€ ë§ì•„ì•¼í•  ì„±ë¶„ì„ ê°ê° ì–˜ê¸°í•˜ë©´? Rotation ì„±ë¶„ì€ ì ìš©í•˜ê³  Translation ì„±ë¶„ì€ ì ìš©í•˜ì§€ ì•ŠëŠ”ë‹¤ ( 09 : 17 )
- ì»¬ë§ ëª¨ë“œëŠ” ì–´ëŠ ë‹¨ê³„ì—ì„œ ì„¤ì •í•´ì•¼ í•˜ëŠ”ê°€? ë ˆìŠ¤í„°ë¼ì´ì € ë‹¨ê³„ ( 17 : 11 )
- ë ˆìŠ¤í„°ë¼ì´ì € ë‹¨ê³„ì— ëŒ€í•´ ê°„ë‹¨í•˜ê²Œ ì„¤ëª…í•˜ë©´? ì •ì  ì‚¬ì´ì— ì†í•´ìˆëŠ” í”½ì…€ ì¦‰ ì¶œë ¥í•´ì•¼í•  í”½ì…€ë“¤ì„ ì°¾ì•„ì„œ í”½ì…€ ì…°ì´ë”ì—ê²Œ ë„˜ê²¨ì¤€ë‹¤, ë¶€ê°€ì ìœ¼ë¡œ ìƒ‰ì„ ë³´ê°„í•˜ëŠ” ì—­í• ë„ ë‹´ë‹¹í•œë‹¤ ( 18 : 14 )

```cpp
// D3D12State.cpp

FRasterizerStateRHIRef FD3D12DynamicRHI::RHICreateRasterizerState(const FRasterizerStateInitializerRHI& Initializer)
{
	FD3D12RasterizerState* RasterizerState = new FD3D12RasterizerState;

	D3D12_RASTERIZER_DESC& RasterizerDesc = RasterizerState->Desc;
	FMemory::Memzero(&RasterizerDesc, sizeof(D3D12_RASTERIZER_DESC));

	// ì»¬ë§ ëª¨ë“œ
	RasterizerDesc.CullMode = TranslateCullMode(Initializer.CullMode);
	// í•„ ëª¨ë“œ ( ê³ ì²´ë¡œ ê·¸ë¦´ê²ƒì¸ì§€, ì™€ì´ì–´ í”„ë ˆì„ìœ¼ë¡œ ê·¸ë¦´ê²ƒì¸ì§€ )
	RasterizerDesc.FillMode = TranslateFillMode(Initializer.FillMode);

	return RasterizerState;
}

FDepthStencilStateRHIRef FD3D12DynamicRHI::RHICreateDepthStencilState(const FDepthStencilStateInitializerRHI& Initializer)
{
	FD3D12DepthStencilState* DepthStencilState = new FD3D12DepthStencilState;

	D3D12_DEPTH_STENCIL_DESC1 &DepthStencilDesc = DepthStencilState->Desc;
	FMemory::Memzero(&DepthStencilDesc, sizeof(D3D12_DEPTH_STENCIL_DESC1));

	// DepthEnable í™œì„±í™”
	DepthStencilDesc.DepthEnable = Initializer.DepthTest != CF_Always || Initializer.bEnableDepthWrite;
	// 1 ë³´ë‹¤ ì‘ì€ ì• ë“¤ë§Œ ê·¸ë¦´ê²ƒì¸ì§€, ë™ë“±í•œ ì• ë„ ê·¸ë¦´ê²ƒì¸ì§€ ë“±ë“±ì„ ì„¤ì •
	DepthStencilDesc.DepthFunc = TranslateCompareFunction(Initializer.DepthTest);
}

FBlendStateRHIRef FD3D12DynamicRHI::RHICreateBlendState(const FBlendStateInitializerRHI& Initializer)
{
	for (uint32 RenderTargetIndex = 0; RenderTargetIndex < MaxSimultaneousRenderTargets; ++RenderTargetIndex)
	{
		const FBlendStateInitializerRHI::FRenderTarget& RenderTargetInitializer = Initializer.RenderTargets[RenderTargetIndex];

		// í”½ì…€ ì‰ì´ë” ê²°ê³¼ë¬¼ê³¼ ë Œë” íƒ€ê²Ÿì„ ì–´ë–»ê²Œ Blend í• ì§€ ê²°ì •
		D3D12_RENDER_TARGET_BLEND_DESC& RenderTarget = BlendDesc.RenderTarget[RenderTargetIndex];

		RenderTarget.BlendEnable =
			RenderTargetInitializer.ColorBlendOp != BO_Add || RenderTargetInitializer.ColorDestBlend != BF_Zero || RenderTargetInitializer.ColorSrcBlend != BF_One ||
			RenderTargetInitializer.AlphaBlendOp != BO_Add || RenderTargetInitializer.AlphaDestBlend != BF_Zero || RenderTargetInitializer.AlphaSrcBlend != BF_One;
		RenderTarget.BlendOp = TranslateBlendOp(RenderTargetInitializer.ColorBlendOp);
		RenderTarget.SrcBlend = TranslateBlendFactor(RenderTargetInitializer.ColorSrcBlend);
		RenderTarget.DestBlend = TranslateBlendFactor(RenderTargetInitializer.ColorDestBlend);
		RenderTarget.BlendOpAlpha = TranslateBlendOp(RenderTargetInitializer.AlphaBlendOp);
		RenderTarget.SrcBlendAlpha = TranslateBlendFactor(RenderTargetInitializer.AlphaSrcBlend);
		RenderTarget.DestBlendAlpha = TranslateBlendFactor(RenderTargetInitializer.AlphaDestBlend);
		RenderTarget.RenderTargetWriteMask =
			((RenderTargetInitializer.ColorWriteMask & CW_RED) ? D3D12_COLOR_WRITE_ENABLE_RED : 0)
			| ((RenderTargetInitializer.ColorWriteMask & CW_GREEN) ? D3D12_COLOR_WRITE_ENABLE_GREEN : 0)
			| ((RenderTargetInitializer.ColorWriteMask & CW_BLUE) ? D3D12_COLOR_WRITE_ENABLE_BLUE : 0)
			| ((RenderTargetInitializer.ColorWriteMask & CW_ALPHA) ? D3D12_COLOR_WRITE_ENABLE_ALPHA : 0);
	}

	return BlendState;
}
```

- ì…°ì´ë” ë¬¸ë²•ì—ì„œ clipSpacePos.xywwê°€ ì˜ë¯¸í•˜ëŠ” ë°”ëŠ”? í•­ìƒ ê¹Šì´ê°’ì„ 1ë¡œ ìœ ì§€í•˜ê² ë‹¤ ( 36 : 42 )

### 04-8 Frustum Culling
- í‰ë©´ì˜ ë°©ì •ì‹ì— ëŒ€í•´ ì„¤ëª…í•˜ë©´? ( 04 : 13 )
- ax + by + cz + d = 0 ì—ì„œ a,b,cê°€ ì˜ë¯¸í•˜ëŠ” ë°”ëŠ”? í•´ë‹¹ í‰ë©´ì˜ ë…¸ë§ ë²¡í„° ([**ì°¸ê³ **](https://backga.tistory.com/8))
- ìœ„ì˜ ë‚´ìš©ì„ ìˆ˜í•™ì ìœ¼ë¡œ ì¦ëª…í•˜ë©´? ( 06 : 49 )
- ax + by + cz + d = 0 ì—ì„œ dê°€ ì˜ë¯¸í•˜ëŠ” ë°”ëŠ”? ì›ì ì—ì„œ í‰ë©´ê¹Œì§€ì˜ ê±°ë¦¬ ([**ì°¸ê³ **](https://backga.tistory.com/8))
- ìœ„ì˜ ë‚´ìš©ì„ ìˆ˜í•™ì ìœ¼ë¡œ ì¦ëª…í•˜ë©´? ( 10 : 40 )
- ì ˆë‘ì²´ ì»¬ë§ì˜ ì›ë¦¬ì— ëŒ€í•´ ì„¤ëª…í•˜ë©´? ( 16 : 10 )
- ì ˆë‘ì²´ë¥¼ êµ¬ì„±í•˜ëŠ” í‰ë©´ì„ ì–´ë–»ê²Œ ë§Œë“¤ ê²ƒì¸ê°€? ( 20 : 20 )
- XMVector3TransformCoord() í•¨ìˆ˜ì˜ ì—­í• ì€? ( 27 : 53 )

```cpp
// ConvexVolume.cpp

void GetViewFrustumBoundsInternal(FConvexVolume& OutResult, const FMatrix& ViewProjectionMatrix, bool bUseNearPlane, bool bUseFarPlane, const FPlane* InFarPlaneOverride)
{
	// Frustum Culling ì„¸íŒ…ì´ ì—¬ê¸°ì„œ ì¼ì–´ë‚˜ëŠ”ë“¯ í•˜ë‹¤
	OutResult.Planes.Empty(6);
	FPlane Temp;
}
```

- BoundScaleì˜ ì—­í• ì€? Frustum Cullingì— ì˜í–¥ì„ ë°›ì„ ë¶€í”¼ ( 38 : 29 )

## Chapter 5 Quaternion

### 05-1 Quaternion 1
- í•¸ë“œí°ì„ Yaw ì¶•ìœ¼ë¡œ 45Â° ëŒë¦°ë’¤ ì¢Œí‘œê³„ë¥¼ ë°”ê¾¸ì§€ ì•Šê³  Pitch ì¶•ìœ¼ë¡œ 45Â° ëŒë¦°ê²ƒê³¼, í•¸ë“œí°ì„ Yaw ì¶•ìœ¼ë¡œ 45Â° ëŒë¦°ë’¤ ì¢Œí‘œê³„ë¥¼ ë°”ê¾¸ê³  Pitch ì¶•ìœ¼ë¡œ 45Â° ëŒë¦°ê²ƒì€ ë‹¤ë¥´ë‹¤
- ë³µì†Œìˆ˜ì˜ ê¸°ë³¸í˜• ì¨ë³´ë©´? ( 16 : 00 )
- ì¼¤ë ˆ ë³µì†Œìˆ˜ë€? ( 21 : 46 )
- ì–´ë–¤ ë³µì†Œìˆ˜ ì—ë‹¤ê°€ ìê¸°ìì‹ ì˜ ì¼¤ë ¤ ë³µì†Œìˆ˜ë¥¼ ê³±í•˜ë©´ ì–´ë–»ê²Œ ë˜ëŠ”ê°€? ( 24 : 58 )
- ë³µì†Œìˆ˜ ë‚˜ëˆ—ì…ˆì— ëŒ€í•´ ì„¤ëª…í•˜ë©´? ( 26 : 20 )
- ê·¹ì¢Œí‘œê³„ë€ ë¬´ì—‡ì¸ê°€? ( 28 : 59 )
- ê·¹ì¢Œí‘œ ë‘ê°œë¥¼ ê³±í•˜ë©´ ì–´ë–¤ í˜„ìƒì´ ì¼ì–´ë‚˜ëŠ”ì§€ ì„¤ëª…í•´ë³´ë©´? íŒíŠ¸ëŠ” ì‚¼ê°í•¨ìˆ˜ì˜ ë§ì…ˆì •ë¦¬ ( 30 : 41 )
- ë³µì†Œìˆ˜ë¥¼ í–‰ë ¬ë¡œ í‘œí˜„í•´ë³´ë©´? ( 36 : 25 )
- Quaternion ì´ë¼ëŠ” ê°œë…ì´ ë°œê²¬ëœ ê³„ê¸°ë¥¼ ë§í•´ë³´ë©´? ( 40 : 10 )

### 05-2 Quaternion 2
- Pure Quaternionì— ëŒ€í•´ ì„¤ëª…í•˜ë©´? ( 27 : 36 )
- Quaternionì˜ ì¥ì ì€? ì§ë²Œë½ í˜„ìƒì„ ì—†ì•¨ìˆ˜ ìˆê³ , í–‰ë ¬ ì—°ì‚°ì— ë¹„í•´ ì†ë„ê°€ ë” ë¹ ë¥´ë‹¤ ( 43 : 26 )
- q = xi + yj + zk + w ì—ì„œ xi + yj + zkê°€ ì˜ë¯¸í•˜ëŠ” ë°”ì™€ wê°€ ì˜ë¯¸í•˜ëŠ” ë°”ë¥¼ ì„¤ëª…í•˜ë©´? íšŒì „ì¶•(ë²¡í„°ë¶€, í—ˆìˆ˜ë¶€)ê³¼ ê°ë„(ìŠ¤ì¹¼ë¼ë¶€, ì‹¤ìˆ˜ë¶€) ([**ì°¸ê³ **](https://tintana4168.tistory.com/9))

## Chapter 6 Rendering

### 06-1 Orthographic Projection
- ì§êµ íˆ¬ì˜ì˜ íŠ¹ì§•ì€? ê¹Šì´ê°’ì˜ ì˜í–¥ì„ ë°›ì§€ ì•ŠëŠ”ë‹¤ ( 04 : 49 )
- ì»¬ë§ ë§ˆìŠ¤í¬ ê°œë…ì— ëŒ€í•´ì„œ ì„¤ëª…í•˜ë©´? ë Œë”í•  ì˜¤ë¸Œì íŠ¸ ìœ í˜•ì„ ì„¤ì •í•  ìˆ˜ ìˆë‹¤ ( 22 : 26 )

### 06-2 Render Target
- SV_Targetì— ê·¸ë ¤ì§„ ê²°ê³¼ë¬¼ì„ ì¶œë ¥í•˜ëŠ” í•¨ìˆ˜ëŠ”? Present í•¨ìˆ˜ ( 02 : 34 )
- í¬ì›Œë“œ ë Œë”ë§ê³¼ ë””í¼ë“œ ë Œë”ë§ì˜ ê°€ì¥ í° ì°¨ì´ëŠ”? í¬ì›Œë“œ ë Œë”ë§ì€ SV_Targetì´ í•˜ë‚˜ì´ê³  ë””í¼ë“œ ë Œë”ë§ì€ SV_Targetì´ ì—¬ëŸ¬ê°œ ì´ë‹¤ ( 13 : 04 )
- ë Œë” íƒ€ê²Ÿë“¤ ì¤‘ì—ì„œ SWAP_CHAINì— ë“¤ì–´ìˆëŠ” ì •ë³´ë“¤ê³¼ G_BUFFERì— ë“¤ì–´ìˆëŠ” ì •ë³´ë“¤ì„ ê°ê° ë§í•´ë³´ë©´? SWAP_CHAIN ì—ëŠ” BACK_BUFFER, FRONT_BUFFERê°€ ë“¤ì–´ìˆê³  G_BUFFER ì—ëŠ” POSITION, NORMAL, COLORê°€ ë“¤ì–´ìˆë‹¤ ( 21 : 17 )
- ë””í¼ë“œ ì…°ì´ë” ëŒ€ìƒì—ì„œ ì œì™¸ë˜ëŠ” ì˜¤ë¸Œì íŠ¸ëŠ”? UI ( 54 : 10 )

### 06-3 Deferred Rendering
- í¬ì›Œë“œ ë Œë”ë§ì˜ ë¬¸ì œì ì€? ì–´ë–¤ ë¹›ì´ í•´ë‹¹ ì˜¤ë¸Œì íŠ¸ì— ì˜í–¥ì„ ì¤„ê²ƒì¸ì§€ ë¯¸ë¦¬ íŒë³„í•  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì— ëª¨ë“  ë¹›ê³¼ í•´ë‹¹ ì˜¤ë¸Œì íŠ¸ë¥¼ ë¹„êµí•´ì•¼ í•œë‹¤ ( 03 : 30 )
- ë””í¼ë“œ ë Œë”ë§ì˜ í”½ì…€ ì…°ì´ë” ë‹¨ê³„ì—ì„œ ì¼ì–´ë‚˜ëŠ” ì¼ì€? ê´‘ì›ì— í•´ë‹¹í•˜ëŠ” ì˜ì—­ê³¼ í¬ì§€ì…˜ ë§µì„ ë¹„êµí•´ ê´‘ì› ì²˜ë¦¬ë¥¼ í•´ì¤˜ì•¼ í•˜ëŠ” ì˜ì—­ì„ íŒë³„í•œë‹¤ ( 06 : 39 )
- ìœ„ì˜ ì‘ì—…ì—ì„œ ìœ ì˜í•  ì ì€? ê´‘ì›ì— í•´ë‹¹í•˜ëŠ” ì˜ì—­ê³¼ í¬ì§€ì…˜ë§µì´ ê²¹ì¹œë‹¤ í•˜ë”ë¼ë„ í•´ë‹¹ ê´‘ì›ê³¼ í¬ì§€ì…˜ì˜ ê±°ë¦¬ê°€ ì—„ì²­ ë©€ìˆ˜ë„ ìˆë‹¤ ( 28 : 11 )
- ë””í¼ë“œ ë Œë”ë§ ê´‘ì›ì˜ íŠ¹ì§•ì€? ê´‘ì›ì´ ë¬¼ì²´ë¥¼ ì°¾ì•„ ê·¸ë ¤ì¤€ë‹¤ ( 56 : 17 )

## Chapter 7 Particle

### 07-1 Compute Shader
- Compute Shaderì˜ íŠ¹ì§•ì€? ë Œë”ë§ íŒŒì´í”„ë¼ì¸ì— ë…ë¦½ì ì´ë‹¤ ( 06 : 11 )
- Compute Shaderê°€ í™œìš©ë˜ëŠ” ì˜ˆëŠ”? ì´í™íŠ¸, ì• ë‹ˆë©”ì´ì…˜ ( 06 : 58 )
- ì •ë³´ êµí™˜ì— ìˆì–´ CPUì™€ GPUì˜ íŠ¹ì§•ì€? CPU ë˜ëŠ” GPUê°€ ê°ìì˜ RAMê³¼ í†µì‹ í•˜ëŠ” ì†ë„ëŠ” ë¹ ë¥´ë‹¤ ê·¸ëŸ¬ë‚˜ CPUì™€ GPUê°€ ì„œë¡œ í†µì‹ í•˜ëŠ” ì†ë„ëŠ” ëŠë¦¬ë‹¤ ( 07 : 28 )
- register(u0)ì˜ ìš©ë„ëŠ”? UAV ì¦‰ Compute Shader ì „ìš© ë ˆì§€ìŠ¤í„° ( 10 : 14 )
- RWTexture2Dì— ëŒ€í•´ ì„¤ëª…í•˜ë©´? ì½ê¸° ì“°ê¸° ëª¨ë‘ ê°€ëŠ¥ ( 10 : 33 )
- Compute Shader ì—ê²Œ ì¼ì„ ì‹œí‚¤ê¸° ìœ„í•œ í•¨ìˆ˜ëŠ”? Dispatch ( 11 : 40 )
- CUDA í”„ë¡œê·¸ë¨ ì‹¤í–‰ê³¼ì •ì„ ì„¤ëª…í•˜ë©´? ê·¸ë¦¬ë“œ ë¸”ë¡ ìŠ¤ë ˆë“œ ìˆœìœ¼ë¡œ í¬í•¨ ê´€ê³„ë¥¼ ê°–ê³  ì¼ì„ ì²˜ë¦¬í•œë‹¤ ( 12 : 02 )

```cpp
// PostProcessMobile.usf

#if CLEAR_UAV_UINT_COMPUTE_SHADER
uint NumEntries;

uint ClearValue;
RWBuffer<uint> UAV;

//---------------------------------------------------------------------------------
// learn.microsoft.com/ko-kr/windows/win32/direct3dhlsl/sm5-attributes-numthreads
// blog.naver.com/songg90/221145775846
// ì“°ë ˆë“œ ê·¸ë£¹ë‹¹ ì“°ë ˆë“œ ê°œìˆ˜
// max : 1024 ( í˜„ì¬ 64 * 1 * 1 = 64 ì´ë‹ˆê¹Œ ê´œì°®ì€ ìƒíƒœ )
// í•˜ë‚˜ì˜ ì“°ë ˆë“œ ê·¸ë£¹ì€ í•˜ë‚˜ì˜ ë‹¤ì¤‘ì²˜ë¦¬ê¸°ì—ì„œ ì‹¤í–‰
//---------------------------------------------------------------------------------
[numthreads(64, 1, 1)]
void ClearUAVUIntCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	if (DispatchThreadId.x < NumEntries)
	{
		// ì•„ë˜ ì—°ì‚°ì€ DispatchThreadId.x ë¼ëŠ” ê³ ìœ  IDë¥¼ ì‚¬ìš©í•˜ê³  ìˆê¸° ë•Œë¬¸ì—
		// ë™ê¸°í™”ê°€ í•„ìš”ì—†ë‹¤
		UAV[DispatchThreadId.x] = ClearValue;
	}
}
#endif
```

```cpp
// D3D12RHIPrivate.h

inline D3D12_COMMAND_LIST_TYPE GetD3DCommandListType(ED3D12QueueType QueueType)
{
	switch (QueueType)
	{
	// Graphic ìš©ë„ì˜ CommandQueue
	case ED3D12QueueType::Direct: return D3D12_COMMAND_LIST_TYPE_DIRECT;

	case ED3D12QueueType::Copy  : return D3D12RHI_PLATFORM_COPY_COMMAND_LIST_TYPE;

	// Compute ìš©ë„ì˜ CommandQueue
	case ED3D12QueueType::Async : return D3D12_COMMAND_LIST_TYPE_COMPUTE;
	}
}
```

- Compute Shader ì—ì„œ ì¶”ê°€ëœ ViewëŠ”? UAV ( 38 : 01 )
- UAV ìš©ë„ì˜ Textureë¥¼ ìƒì„±í•  ë•Œ ì‚¬ìš©í•˜ëŠ” enum ê°’ì€? D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS

```cpp
// D3D12Buffer.cpp

FD3D12Buffer* FD3D12DynamicRHI::CreateD3D12Buffer(class FRHICommandListBase* RHICmdList, uint32 Size, EBufferUsageFlags Usage, uint32 Stride, ERHIAccess InResourceState, FRHIResourceCreateInfo& CreateInfo, ID3D12ResourceAllocator* ResourceAllocator)
{
	D3D12_RESOURCE_DESC Desc;

	// Desc ë‚´ìš©ë“¤( ì˜ˆë¥¼ë“¤ì–´ D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS )ì„ í™œìš©í•´ ë²„í¼ë¥¼ ë§Œë“œëŠ”ë“¯ í•˜ë‹¤
	FD3D12Buffer::GetResourceDescAndAlignment(Size, Stride, Usage, Desc, Alignment);
}
```

### 07-2 Particle System
- íŒŒí‹°í´ ì‹œìŠ¤í…œì€ ì–´ë–¤ ê¸°ìˆ ì„ í™œìš©í•˜ëŠ”ê°€? ì¸ìŠ¤í„´ì‹± ( 04 : 06 )
- ì¸ìŠ¤í„´ì‹± ê¸°ìˆ ì˜ ì¥ì ì€? 1000ê°œì˜ ì˜¤ë¸Œì íŠ¸ë¥¼ ê·¸ë¦´ë•Œ ë Œë”ë§ íŒŒì´í”„ë¼ì¸ì´ 1000ë²ˆ ë™ì‘í•˜ëŠ”ê²ƒì€ ê°™ì§€ë§Œ ì˜¤ë¸Œì íŠ¸ë“¤ì„ ë Œë”ë§ íŒŒì´í”„ ë¼ì¸ìœ¼ë¡œ ë„˜ê¸°ëŠ” íšŒìˆ˜ê°€ 1íšŒë¡œ ì¤„ì–´ë“ ë‹¤ ì¦‰ ë“œë¡œìš° ì½œì„ ì¤„ì¸ë‹¤ ( 05 : 19 )
- ì¸ìŠ¤í„´ì‹±ì„ ì‚¬ìš©í•  ë•Œ ê°ê°ì˜ ë¬¼ì²´ë¥¼ ì–´ë–»ê²Œ êµ¬ë¶„ í•˜ëŠ”ê°€? SV_InstanceIDë¥¼ í™œìš©í•œë‹¤ ( 06 : 20 )
- hlsl ì—ì„œ cbufferì˜ ë‹¨ì ì€? í¬ê¸°ê°€ ê³ ì •ë˜ë©° GPUê°€ í•´ë‹¹ cbufferë¥¼ Readë§Œ í•  ìˆ˜ ìˆë‹¤ ( 08 : 00 )
- hlsl ì—ì„œ StructuredBuffer, RWStructuredBufferì˜ ì¥ì ì€? í¬ê¸°ê°€ ìœ ë™ì ì´ë©° ë°°ì—´ì´ë¼ê³  ë³´ë©´ ëœë‹¤ ( 10 : 12 )
- íŒŒí‹°í´ì„ ê³„ì‚°í•˜ëŠ” ì˜ì—­ì€ ì–´ë””ì¸ê°€? GPU ì´ë©° Compute Shader ë‹¨ê³„ì—ì„œ ê³„ì‚°ì´ ì´ë£¨ì–´ì§„ë‹¤ ( 11 : 31 )
- íŠ¹ì • íŒŒí‹°í´ì´ ê·¸ë ¤ì§€ì§€ ì•Šê²Œ í•˜ë ¤ë©´ ë¬´ì—‡ì„ í™œìš©í•´ì•¼ í•˜ëŠ”ê°€? Geometry Shaderë¥¼ í™œìš©í•œë‹¤ ( 16 : 01 )
- Geometry Shader ì—ì„œ RestartStrip í•¨ìˆ˜ì˜ ì—­í• ì€? ë„í˜•ì„ ë¬¶ëŠ”ë‹¤ ( 17 : 56 )

```cpp
// hlsl êµ¬ì¡°ì²´ ì˜ˆì‹œ

// íŒ¨ë”©ì„ ì‚¬ìš©í•´ êµ¬ì¡°ì²´ í¬ê¸°ë¥¼ ë§ì¶°ì£¼ëŠ” ê²½ìš°ê°€ ìˆë‹¤ëŠ” ê²ƒì„ ì¸ì§€í•˜ì
// ì—¬ê¸°ì„œëŠ” 16 ë°”ì´íŠ¸ ë‹¨ìœ„ë¡œ ë§ì¶°ì£¼ê³  ìˆë‹¤
struct Particle
{
	float3	worldPos;
	float	curTime;
	float3	worldDir;
	float	lifeTime;
	int	alive;
	float3	padding;
}
```

- hlsl ì—ì„œ GroupMemoryBarrierWithGroupSync í•¨ìˆ˜ì˜ ì—­í• ì€? ìŠ¤ë ˆë“œê°„ì˜ ë™ê¸°í™” ( 34 : 29 )

```cpp
// LumenSurfaceCacheFeedback.usf

bool HashTableAdd(uint Key, inout uint Index)
{
	LOOP
	for (uint LinearProbingStep = 0; LinearProbingStep < MaxLinearProbingSteps; ++LinearProbingStep)
	{
		if (StoredKey != Key)
		{
			uint PrevKey;

			// ì›ìì„± ë³´ì¥
			// RWHashTableKeys[Index]ì™€ 0ì´ ê°™ìœ¼ë©´ RWHashTableKeys[Index]ì— Key ê°’ì„ ë„£ì–´ì¤€ë‹¤
			// ê·¸ë¦¬ê³  PrevKeyì— RWHashTableKeys[Index]ê°’ì„ ë„£ì–´ì¤€ë‹¤
			InterlockedCompareExchange(RWHashTableKeys[Index], 0, Key, PrevKey);
		}
	}
}
```

- Compute Shader ë‹¨ê³„ì—ì„œ ê³„ì‚°ì´ ëë‚œ íŒŒí‹°í´ì€ ì–´ë””ë¡œ ë³´ë‚´ì¤˜ì•¼ í•˜ëŠ”ê°€? ë Œë”ë§ ì „ìš© StructuredBuffer ìœ¼ë¡œ ë³´ë‚´ì¤˜ì•¼ í•œë‹¤ ì´í›„ ì›ë˜ ë Œë”ë§ íŒŒì´í”„ ë¼ì¸ì„ í†µí•´ í•´ë‹¹ íŒŒí‹°í´ì´ ì¶œë ¥ë  ê²ƒì´ë‹¤ ( 48 : 46 )
- Geometry Shader ì—ì„œ í•˜ëŠ”ì¼ì€? ì •ì ì„ ì¶”ê°€ í•´ì£¼ê±°ë‚˜ ê·¸ë¦¬ì§€ ì•Šê²Œ í•´ì¤€ë‹¤ ( 49 : 28 )
- íŒŒí‹°í´ì€ ë””í¼ë“œ ë Œë”ë§ì„ ì ìš©í•´ì•¼ í• ê¹Œ í¬ì›Œë“œ ë Œë”ë§ì„ ì ìš©í•´ì•¼ í• ê¹Œ? í¬ì›Œë“œ ë Œë”ë§ ( 01 : 14 : 50 )

### 07-2 Instancing
- ì¸ìŠ¤í„´ì‹±ì„ í™œìš©í•˜ê¸° ìœ„í•œ ì¡°ê±´ì€? ë²„í…ìŠ¤ ë²„í¼, ì¸ë±ìŠ¤ ë²„í¼, ë¨¸í‹°ë¦¬ì–¼, ì‰ì´ë”ê°€ ê°™ì•„ì•¼ í•œë‹¤ ( 03 : 05 )

## Chapter 8 Shadow Mapping

### 08-1 Shadow Mapping
- Shadow Mappingì„ í•˜ê¸°ìœ„í•œ ì²«ë²ˆì§¸ ë‹¨ê³„ëŠ”? ë¹›ì˜ ìœ„ì¹˜ì— ê°€ìƒì˜ ì¹´ë©”ë¼ë¥¼ ë°°ì¹˜í•˜ê³  í•´ë‹¹ ì¹´ë©”ë¼ ê¸°ì¤€ì—ì„œ ëŒ€ìƒì˜ ê¹Šì´ê°’ì„ í…ìŠ¤ì³ë¡œ ì €ì¥í•œë‹¤ ( 04 : 33 )
- ì¢Œí‘œê³„ ë³€í™˜ ìˆœì„œë¥¼ ì •í™•í•˜ê²Œ ì„¤ëª…í•˜ë©´? WorldMat - ViewMat - ProjMat - ClipPos - W ë‚˜ëˆ„ê¸° - ProjPos ( 07 : 41 )
- ê·¸ë¦¼ìë¥¼ ê·¸ë ¤ì£¼ëŠ” ShaderëŠ” ë¬´ì—‡ì¸ê°€? Lighting Shader ( 08 : 47 )
- ê·¸ë¦¼ìë¥¼ ê·¸ë ¤ì¤˜ì•¼ í•˜ëŠ” í”½ì…€ì¸ì§€ ì–´ë–»ê²Œ ì•Œ ìˆ˜ ìˆëŠ”ê°€? ì‹¤ì œ ì¹´ë©”ë¼ ì´ë¯¸ì§€ì˜ í•´ë‹¹ í”½ì…€ ViewPosì— ViewInverseMatrixë¥¼ ê³±í•´ WorldPosë¡œ ë°”ê¿”ì£¼ê³  ê°€ìƒì˜ ì¹´ë©”ë¼ ViewProjMatì„ ê³±í•´ ClipPosë¡œ ë°”ê¿”ì¤€ë’¤ W ë‚˜ëˆ„ê¸°ë¥¼ í†µí•´ ProjPosë¥¼ êµ¬í•œë‹¤ìŒ UV ì¢Œí‘œê³„ë¡œ í™˜ì‚°í•œ ê°€ìƒì˜ ì¹´ë©”ë¼ ì´ë¯¸ì§€ ìœ„ì¹˜ê°€ ê·¸ë¦¼ìê°€ ê·¸ë ¤ì ¸ì•¼ í•˜ëŠ” ìœ„ì¹˜ì™€ ì¼ì¹˜í•˜ëŠ”ì§€ ë¹„êµí•´ ê·¸ë¦¼ìë¥¼ ê·¸ë¦°ë‹¤ ( 08 : 47 )
- ìœ„ì˜ ë°©ì‹ì—ì„œ ìœ ì˜í•´ì•¼í•  ì ì€? ê·¸ë¦¼ìë¥¼ ê·¸ë ¤ì•¼ í•˜ëŠ”ì§€ íŒë³„í•´ì•¼ í•˜ëŠ” í”½ì…€ì˜ ê¹Šì´ ê°’ê³¼ ë Œë” íƒ€ê²Ÿì— ë“±ë¡ë˜ì–´ ìˆëŠ” ê¹Šì´ ê°’ì„ ë¹„êµí•´ ë Œë” íƒ€ê²Ÿì˜ ê¹Šì´ê°’ ë³´ë‹¤ íŒë³„í•´ì•¼ í•˜ëŠ” í”½ì…€ì˜ ê¹Šì´ ê°’ì´ ë” ì»¤ì•¼ë§Œ ê·¸ë¦¼ìë¥¼ ê·¸ë ¤ì¤˜ì•¼ í•œë‹¤ ( 13 : 08 )
- ê·¸ë¦¼ì ê³„ë‹¨ í˜„ìƒì„ ì—†ì• ë ¤ë©´ ì–´ë–»ê²Œ í•´ì•¼ í•˜ëŠ”ê°€? ê·¸ë¦¼ìì™€ ê´€ë ¨ëœ ë Œë” íƒ€ê²Ÿ í…ìŠ¤ì³ì˜ í¬ê¸°ë¥¼ í‚¤ìš´ë‹¤ ( 15 : 17 )
- Static ë¬¼ì²´ëŠ” ë™ì ìœ¼ë¡œ ê·¸ë¦¼ìë¥¼ ê·¸ë ¤ì¤„ í•„ìš”ê°€ ìˆëŠ”ê°€? ì•„ë‹ˆì˜¤ ( 30 : 47 )

### 08-2 Tessellation
- 

<br>

[ë§¨ ìœ„ë¡œ ì´ë™í•˜ê¸°](#){: .btn .btn--primary }{: .align-right}
