---
title:  "게임 수학과 DirectX12 ( Unreal Engine 5.2 )"

categories:
  - DirectX 12
tags:
  - []

comments: true

toc: true
toc_sticky: true

date: 2024-05-10
last_modified_at: 2024-05-10
---

## Chapter 1 DirectX12 초기화

### 01-1 프로젝트 설정
- 렌더링 파이프라인, Diffuse, Ambient, Specular, Double Buffering, Tangent Space, 그림자 원리, 짐벌락 현상, 쿼터니언이 중요하다
- CPU와 GPU의 가장큰 차이는? ALU 개수

```cpp
// LaunchWindows.cpp

int32 WINAPI WinMain(_In_ HINSTANCE hInInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ char* pCmdLine, _In_ int32 nCmdShow)
{
	// 여기가 언리얼이 시작되는 부분이다
	int32 Result = LaunchWindowsStartup(hInInstance, hPrevInstance, pCmdLine, nCmdShow, nullptr);
}
```

```cpp
// Launch.cpp

int32 GuardedMain( const TCHAR* CmdLine )
{
	#if WITH_EDITOR
	if (GIsEditor)
	{
		// 이 안에서 엔진을 셋업한다 ( 솔루션 구성에서 Editor 모드를 선택하면 이곳이 호출된다 )
		ErrorLevel = EditorInit(GEngineLoop);
	}
	#endif
	
	if (!GUELibraryOverrideSettings.bIsEmbedded)
	{
		// 이 안에서 엔진틱이 돌고있다
		while( !IsEngineExitRequested() )
		{
			EngineTick();
		}
	}
}
```

```cpp
// WindowsPlatformApplicationMisc.cpp

void FWindowsPlatformApplicationMisc::PumpMessages(bool bFromMainLoop)
{
	// 이 안에서 PeekMessage 가 처리되고 있다 ( bFromMainLoop == false )
	if (!bFromMainLoop)
	{
		FPlatformMisc::PumpMessagesOutsideMainLoop();
		return;
	}

	// 이 안에서 PeekMessage 가 처리되고 있다 ( bFromMainLoop == true )
	GPumpingMessagesOutsideOfMainLoop = false;
	WinPumpMessages();
}
```

- 자주 활용하는 라이브러리를 인클루드 하는게 귀찮기 때문에 사용하는 헤더는? 미리 컴파일된 헤더 ( 07 : 41 )
- 언리얼 엔진의 pch.h 파일을 보는 방법은? 솔루션 탐색기에 pch.h 검색
- d3dx12.h의 특징은? 마이크로소프트 에서 제공해주는 비공식적인 라이브러리 ( 27 : 30 )

![dir](https://github.com/devMyeong/devMyeong.github.io/assets/80055816/0800c9f0-153b-41fe-939b-e4eb9f040b8c){: width="100%" height="100%"}{: .align-center}

- 추가 종속성 대신 lib 파일을 추가할 수 있는 방법은? pragma comment 활용 ( 37 : 41 )

### 01-2 장치 초기화

```cpp
// Engine.h

/** Global engine pointer. Can be 0 so don't use without checking. */
extern ENGINE_API class UEngine*			GEngine;
```

```cpp
// WindowsApplication.cpp

int32 FWindowsApplication::ProcessMessage( HWND hwnd, uint32 msg, WPARAM wParam, LPARAM lParam )
{
	// 이 안에서 윈도우 메시지가 처리되고 있다
	// FWindowsPlatformApplicationMisc 클래스의 WinPumpMessages() 에서 날아온 메시지 이다 ( 날아오는 원리는 콜백 )
	// 아래 메시지 에서 처리되고 있는 자료형 중에 WINDOWINFO 라는게 있는데 그려질 화면 크기와 관련이 있다
	switch(msg)
	{
		// 윈도우 사이즈 조정하는 이벤트
		case WM_SIZING:
	}
}
```

```cpp
// D3D12Commands.cpp

void FD3D12CommandContext::RHISetViewport(float MinX, float MinY, float MinZ, float MaxX, float MaxY, float MaxZ)
{
	// 그려질 화면 크기 관련 ( D3D12_VIEWPORT )
	D3D12_VIEWPORT Viewport = { MinX, MinY, (MaxX - MinX), (MaxY - MinY), MinZ, MaxZ };

}

void FD3D12CommandContext::RHISetScissorRect(bool bEnable, uint32 MinX, uint32 MinY, uint32 MaxX, uint32 MaxY)
{
	if (bEnable)
	{
		// 그려질 화면 크기 관련 ( CD3DX12_RECT )
		const CD3DX12_RECT ScissorRect(MinX, MinY, MaxX, MaxY);
		StateCache.SetScissorRect(ScissorRect);
	}
}
```

```cpp
// D3D12Adapter.h
// D3D12Adapter.cpp

class FD3D12Adapter : public FNoncopyable
{
	// 각종 객체 생성, D3D12CreateDevice() 함수를 활용해 초기화 한다
	FORCEINLINE ID3D12Device* GetD3DDevice() const { return RootDevice; }

	// 화면 관련 기능들, CreateDXGIFactory() 함수를 활용해 초기화 한다
	FORCEINLINE IDXGIFactory2* GetDXGIFactory2() const { return DxgiFactory2; }
}

void FD3D12Adapter::CreateRootDevice(bool bWithDebug)
{
	// 디버그 ( IID_PPV_ARGS 매크로는 자주 이용된다 )
	TRefCountPtr<ID3D12Debug> DebugController;
	if (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(DebugController.GetInitReference()))))
	{
		DebugController->EnableDebugLayer();
	}
}

void FD3D12Adapter::InitializeDevices()
{
	// create an overly large heap and test for failure
	D3D12_DESCRIPTOR_HEAP_DESC TempHeapDesc{};

	// Constant Buffer View, Shader Resource View, Unordered Access Buffer
	TempHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;

	TempHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	TempHeapDesc.NodeMask = FRHIGPUMask::All().GetNative();
	TempHeapDesc.NumDescriptors = 2 * D3D12_MAX_SHADER_VISIBLE_DESCRIPTOR_HEAP_SIZE_TIER_2;

	// DX11의 RenderTargetView, DepthStencilView 등등을 이제 통합적으로 관리한다 ( ID3D12DescriptorHeap )
	TRefCountPtr<ID3D12DescriptorHeap> TempHeap;

	// 배열 형태로 관리되는 TempHeap.GetInitReference() 가 만들어 진다
	HRESULT hr = RootDevice->CreateDescriptorHeap(&TempHeapDesc, IID_PPV_ARGS(TempHeap.GetInitReference()));
}
```

```cpp
// D3D12Device.h

class FD3D12Queue final
{
public:
	// 일감을 차곡차곡 기록했다가 한 방에 요청하는 것
	// ID3D12CommandAllocator, ID3D12GraphicsCommandList 와 친구 ( ID3D12GraphicsCommandList는 Close 함수를 활용해 무엇을 제출한다 )
	TRefCountPtr<ID3D12CommandQueue> D3DCommandQueue;
}
```

```cpp
// D3D12Viewport.h
// D3D12Viewport.cpp

class FD3D12FramePacing : public FRunnable, public FD3D12AdapterChild
{
private:
	// CPU와 GPU 동기화를 위한 간단한 도구
	TRefCountPtr<ID3D12Fence> Fence;
}

FD3D12Texture* GetSwapChainSurface(FD3D12Device* Parent, EPixelFormat PixelFormat, uint32 SizeX, uint32 SizeY, IDXGISwapChain* SwapChain, uint32 BackBufferIndex, TRefCountPtr<ID3D12Resource> BackBufferResourceOverride)
{
	// Grab the back buffer
	TRefCountPtr<ID3D12Resource> BackBufferResource;
	if (SwapChain)
	{
#if D3D12_VIEWPORT_EXPOSES_SWAP_CHAIN
		// 여기서 렌더 타겟(Back Buffer)과 스왑체인이 연동된다
		VERIFYD3D12RESULT_EX(SwapChain->GetBuffer(BackBufferIndex, IID_PPV_ARGS(BackBufferResource.GetInitReference())), Parent->GetDevice());
#else // #if D3D12_VIEWPORT_EXPOSES_SWAP_CHAIN
	}
}
```

```cpp
// D3D12Submission.cpp

FD3D12DynamicRHI::FProcessResult FD3D12DynamicRHI::ProcessInterruptQueue()
{
	if (InterruptThread && !CurrentQueue.Fence.bInterruptAwaited)
	{
		// 여기서 D3DFence와 Event를 활용해 동기화 수행
		VERIFYD3D12RESULT(CurrentQueue.Fence.D3DFence->SetEventOnCompletion(Payload->CompletionFenceValue, InterruptThread->Event));
		CurrentQueue.Fence.bInterruptAwaited = true;
	}
}
```

```cpp
// D3D12View.cpp

void FD3D12ViewDescriptorHandle::CreateView(const D3D12_RENDER_TARGET_VIEW_DESC& Desc, ID3D12Resource* Resource)
{
	check(HeapType == ERHIDescriptorHeapType::RenderTarget);

	// 렌더 타겟이 Resource 에 담긴다 ( 렌더 타겟은 스왑체인에 활용되는 BackBuffer를 의미하는 듯 )
	GetParentDevice()->GetDevice()->CreateRenderTargetView(Resource, &Desc, OfflineCpuHandle);
}
```

```cpp
// WindowsD3D12Viewport.cpp

void FD3D12Viewport::Init()
{
	// 이 안에서 스왑체인 세팅이 이루어진다
	bNeedSwapChain = !FParse::Param(FCommandLine::Get(), TEXT("RenderOffScreen"));
	if (bNeedSwapChain)
	{
		if (FD3D12DynamicRHI::GetD3DRHI()->IsQuadBufferStereoEnabled())
		{
			if (Factory2->IsWindowedStereoEnabled())
			{
				DXGI_SWAP_CHAIN_DESC1 SwapChainDesc1{};

				// 버퍼 카운트
				SwapChainDesc1.BufferCount = NumBackBuffers;
			}
		}
	}
}

HRESULT FD3D12Viewport::PresentInternal(int32 SyncInterval)
{
	if (SwapChain1)
	{
		// 여기서 SwapChain에 그려줘(Present)가 등록되어야 하는데 디버깅 해보니 호출 안됨
		return SwapChain1->Present(SyncInterval, Flags);
	}

	return S_OK;
}

// 스왑 체인 Present 대한 내용이 여기서 처리되고 있는듯
bool FD3D12Viewport::Present(bool bLockToVsync)
{
	if (!IsPresentAllowed())
	{
		return false;
	}

	FD3D12Adapter* Adapter = GetParentAdapter();
	
	for (uint32 GPUIndex : FRHIGPUMask::All())
	{
		FD3D12CommandContext& DefaultContext = Adapter->GetDevice(GPUIndex)->GetDefaultCommandContext();

		// Those are not necessarily the swap chain back buffer in case of multi-gpu
		FD3D12Texture* DeviceBackBuffer = DefaultContext.RetrieveObject<FD3D12Texture, FRHITexture2D>(GetBackBuffer_RHIThread());
		FD3D12Texture* DeviceSDRBackBuffer = DefaultContext.RetrieveObject<FD3D12Texture, FRHITexture2D>(GetSDRBackBuffer_RHIThread());

		DefaultContext.TransitionResource(
			DeviceBackBuffer->GetShaderResourceView()->GetResource(),
			D3D12_RESOURCE_STATE_TBD,
			D3D12_RESOURCE_STATE_PRESENT,
			0
		);

		if (SDRBackBuffer_RHIThread != nullptr)
		{
			DefaultContext.TransitionResource(
				DeviceSDRBackBuffer->GetShaderResourceView()->GetResource(),
				D3D12_RESOURCE_STATE_TBD,
				D3D12_RESOURCE_STATE_PRESENT,
				0
			);
		}

		DefaultContext.FlushResourceBarriers();
	}
}
```

- ( 60 : 00 )

<br>

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}
