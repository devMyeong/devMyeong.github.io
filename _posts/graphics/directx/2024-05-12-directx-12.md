---
title:  "게임 수학과 DirectX12"

categories:
  - DirectX 12
tags:
  - []

comments: true

toc: true
toc_sticky: true

date: 2024-05-10
last_modified_at: 2024-05-10
---

## Chapter 1 DirectX12 초기화

### 01-1 프로젝트 설정
- 렌더링 파이프라인, Diffuse, Ambient, Specular, Double Buffering, Tangent Space, 그림자 원리, 짐벌락 현상, 쿼터니언이 중요하다
- CPU와 GPU의 가장큰 차이는? ALU 개수

```cpp
// LaunchWindows.cpp
int32 WINAPI WinMain(_In_ HINSTANCE hInInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ char* pCmdLine, _In_ int32 nCmdShow)
{
	// 여기가 언리얼이 시작되는 부분이다
	int32 Result = LaunchWindowsStartup(hInInstance, hPrevInstance, pCmdLine, nCmdShow, nullptr);
}

// Launch.cpp
#if WITH_EDITOR
if (GIsEditor)
{
	// 이 안에서 엔진을 셋업한다 ( 솔루션 구성에서 Editor 모드를 선택하면 이곳이 호출된다 )
	ErrorLevel = EditorInit(GEngineLoop);
}
else
#endif

// Launch.cpp
if (!GUELibraryOverrideSettings.bIsEmbedded)
{
	// 이 안에서 엔진틱이 돌고있다
	while( !IsEngineExitRequested() )
	{
		EngineTick();
	}
}

// WindowsPlatformApplicationMisc.cpp
void FWindowsPlatformApplicationMisc::PumpMessages(bool bFromMainLoop)
{
	// 이 안에서 PeekMessage 가 처리되고 있다 ( bFromMainLoop == false )
	if (!bFromMainLoop)
	{
		FPlatformMisc::PumpMessagesOutsideMainLoop();
		return;
	}

	// 이 안에서 PeekMessage 가 처리되고 있다 ( bFromMainLoop == true )
	GPumpingMessagesOutsideOfMainLoop = false;
	WinPumpMessages();
}
```

- 자주 활용하는 라이브러리를 인클루드 하는게 귀찮기 때문에 사용하는 헤더는? 미리 컴파일된 헤더 ( 07 : 41 )
- 언리얼 엔진의 pch.h 파일을 보는 방법은? 솔루션 탐색기에 pch.h 검색
- d3dx12.h의 특징은? 마이크로소프트 에서 제공해주는 비공식적인 라이브러리 ( 27 : 30 )

![dir](https://github.com/devMyeong/devMyeong.github.io/assets/80055816/0800c9f0-153b-41fe-939b-e4eb9f040b8c){: width="100%" height="100%"}{: .align-center}

- 추가 종속성 대신 lib 파일을 추가할 수 있는 방법은? pragma comment 활용 ( 37 : 41 )

### 01-2 장치 초기화

```cpp
// Engine.h
/** Global engine pointer. Can be 0 so don't use without checking. */
extern ENGINE_API class UEngine*			GEngine;

// WindowsApplication.cpp
int32 FWindowsApplication::ProcessMessage( HWND hwnd, uint32 msg, WPARAM wParam, LPARAM lParam )
{
	// 이 안에서 윈도우 메시지가 처리되고 있다
	// FWindowsPlatformApplicationMisc 클래스의 WinPumpMessages() 에서 날아온 메시지 이다 ( 날아오는 원리는 콜백 )
	// 아래 메시지 에서 처리되고 있는 자료형 중에 WINDOWINFO 라는게 있는데 그려질 화면 크기와 관련이 있다
	switch(msg)
	{
		// 윈도우 사이즈 조정하는 이벤트
		case WM_SIZING:
	}
}

// D3D12Commands.cpp
void FD3D12CommandContext::RHISetViewport(float MinX, float MinY, float MinZ, float MaxX, float MaxY, float MaxZ)
{
	// 그려질 화면 크기 관련 ( D3D12_VIEWPORT )
	D3D12_VIEWPORT Viewport = { MinX, MinY, (MaxX - MinX), (MaxY - MinY), MinZ, MaxZ };

}

// D3D12Commands.cpp
void FD3D12CommandContext::RHISetScissorRect(bool bEnable, uint32 MinX, uint32 MinY, uint32 MaxX, uint32 MaxY)
{
	if (bEnable)
	{
		// 그려질 화면 크기 관련 ( CD3DX12_RECT )
		const CD3DX12_RECT ScissorRect(MinX, MinY, MaxX, MaxY);
		StateCache.SetScissorRect(ScissorRect);
	}
}

// D3D12Adapter.h
class FD3D12Adapter : public FNoncopyable
{
	// 각종 객체 생성, D3D12CreateDevice() 함수를 활용해 초기화 한다
	FORCEINLINE ID3D12Device* GetD3DDevice() const { return RootDevice; }

	// 화면 관련 기능들, CreateDXGIFactory() 함수를 활용해 초기화 한다
	FORCEINLINE IDXGIFactory2* GetDXGIFactory2() const { return DxgiFactory2; }
}

// D3D12Adapter.cpp
void FD3D12Adapter::CreateRootDevice(bool bWithDebug)
{
	// 디버그 ( IID_PPV_ARGS 매크로는 자주 이용된다 )
	TRefCountPtr<ID3D12Debug> DebugController;
	if (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(DebugController.GetInitReference()))))
	{
		DebugController->EnableDebugLayer();
	}
}

// D3D12Device.h
class FD3D12Queue final
{
public:
	// 일감을 차곡차곡 기록했다가 한 방에 요청하는 것
	// ID3D12CommandAllocator, ID3D12GraphicsCommandList 와 친구 ( ID3D12GraphicsCommandList는 Close 함수를 활용해 무엇을 제출한다 )
	TRefCountPtr<ID3D12CommandQueue> D3DCommandQueue;
}

// D3D12Viewport.h
class FD3D12FramePacing : public FRunnable, public FD3D12AdapterChild
{
private:
	// CPU와 GPU 동기화를 위한 간단한 도구
	TRefCountPtr<ID3D12Fence> Fence;
}

// D3D12Viewport.cpp
FD3D12Texture* GetSwapChainSurface(FD3D12Device* Parent, EPixelFormat PixelFormat, uint32 SizeX, uint32 SizeY, IDXGISwapChain* SwapChain, uint32 BackBufferIndex, TRefCountPtr<ID3D12Resource> BackBufferResourceOverride)
{
	// Grab the back buffer
	TRefCountPtr<ID3D12Resource> BackBufferResource;
	if (SwapChain)
	{
#if D3D12_VIEWPORT_EXPOSES_SWAP_CHAIN
		// 여기서 렌더 타겟(Back Buffer)과 스왑체인이 연동된다
		VERIFYD3D12RESULT_EX(SwapChain->GetBuffer(BackBufferIndex, IID_PPV_ARGS(BackBufferResource.GetInitReference())), Parent->GetDevice());
#else // #if D3D12_VIEWPORT_EXPOSES_SWAP_CHAIN
	}
}

// D3D12Submission.cpp
FD3D12DynamicRHI::FProcessResult FD3D12DynamicRHI::ProcessInterruptQueue()
{
	if (InterruptThread && !CurrentQueue.Fence.bInterruptAwaited)
	{
		// 여기서 D3DFence와 Event를 활용해 동기화 수행
		VERIFYD3D12RESULT(CurrentQueue.Fence.D3DFence->SetEventOnCompletion(Payload->CompletionFenceValue, InterruptThread->Event));
		CurrentQueue.Fence.bInterruptAwaited = true;
	}
}

// D3D12View.cpp
void FD3D12ViewDescriptorHandle::CreateView(const D3D12_RENDER_TARGET_VIEW_DESC& Desc, ID3D12Resource* Resource)
{
	check(HeapType == ERHIDescriptorHeapType::RenderTarget);

	// 렌더 타겟이 Resource 에 담긴다 ( 렌더 타겟은 스왑체인에 활용되는 BackBuffer를 의미하는 듯 )
	GetParentDevice()->GetDevice()->CreateRenderTargetView(Resource, &Desc, OfflineCpuHandle);
}

// WindowsD3D12Viewport.cpp
void FD3D12Viewport::Init()
{
	// 이 안에서 스왑체인 세팅이 이루어진다
	bNeedSwapChain = !FParse::Param(FCommandLine::Get(), TEXT("RenderOffScreen"));
	if (bNeedSwapChain)
	{
		if (FD3D12DynamicRHI::GetD3DRHI()->IsQuadBufferStereoEnabled())
		{
			if (Factory2->IsWindowedStereoEnabled())
			{
				DXGI_SWAP_CHAIN_DESC1 SwapChainDesc1{};

				// 버퍼 카운트
				SwapChainDesc1.BufferCount = NumBackBuffers;
			}
		}
	}
}
```

- ( 50 : 00 )

<br>

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}
